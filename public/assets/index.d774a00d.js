(function () { const s = document.createElement("link").relList; if (s && s.supports && s.supports("modulepreload")) return; for (const et of document.querySelectorAll('link[rel="modulepreload"]')) c(et); new MutationObserver(et => { for (const at of et) if (at.type === "childList") for (const lt of at.addedNodes) lt.tagName === "LINK" && lt.rel === "modulepreload" && c(lt) }).observe(document, { childList: !0, subtree: !0 }); function o(et) { const at = {}; return et.integrity && (at.integrity = et.integrity), et.referrerpolicy && (at.referrerPolicy = et.referrerpolicy), et.crossorigin === "use-credentials" ? at.credentials = "include" : et.crossorigin === "anonymous" ? at.credentials = "omit" : at.credentials = "same-origin", at } function c(et) { if (et.ep) return; et.ep = !0; const at = o(et); fetch(et.href, at) } })(); var commonjsGlobal$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; function getDefaultExportFromCjs(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } function getAugmentedNamespace(e) { var s = e.default; if (typeof s == "function") { var o = function () { return s.apply(this, arguments) }; o.prototype = s.prototype } else o = {}; return Object.defineProperty(o, "__esModule", { value: !0 }), Object.keys(e).forEach(function (c) { var et = Object.getOwnPropertyDescriptor(e, c); Object.defineProperty(o, c, et.get ? et : { enumerable: !0, get: function () { return e[c] } }) }), o } var react = { exports: {} }, react_production_min = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var l$2 = Symbol.for("react.element"), n$1 = Symbol.for("react.portal"), p$4 = Symbol.for("react.fragment"), q$4 = Symbol.for("react.strict_mode"), r$1 = Symbol.for("react.profiler"), t$1 = Symbol.for("react.provider"), u$1 = Symbol.for("react.context"), v$4 = Symbol.for("react.forward_ref"), w$1 = Symbol.for("react.suspense"), x$2 = Symbol.for("react.memo"), y$2 = Symbol.for("react.lazy"), z$4 = Symbol.iterator; function A$3(e) { return e === null || typeof e != "object" ? null : (e = z$4 && e[z$4] || e["@@iterator"], typeof e == "function" ? e : null) } var B$4 = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, C$4 = Object.assign, D$3 = {}; function E$3(e, s, o) { this.props = e, this.context = s, this.refs = D$3, this.updater = o || B$4 } E$3.prototype.isReactComponent = {}; E$3.prototype.setState = function (e, s) { if (typeof e != "object" && typeof e != "function" && e != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, e, s, "setState") }; E$3.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, "forceUpdate") }; function F$1() { } F$1.prototype = E$3.prototype; function G$3(e, s, o) { this.props = e, this.context = s, this.refs = D$3, this.updater = o || B$4 } var H$4 = G$3.prototype = new F$1; H$4.constructor = G$3; C$4(H$4, E$3.prototype); H$4.isPureReactComponent = !0; var I$3 = Array.isArray, J$1 = Object.prototype.hasOwnProperty, K$3 = { current: null }, L$4 = { key: !0, ref: !0, __self: !0, __source: !0 }; function M$4(e, s, o) { var c, et = {}, at = null, lt = null; if (s != null) for (c in s.ref !== void 0 && (lt = s.ref), s.key !== void 0 && (at = "" + s.key), s) J$1.call(s, c) && !L$4.hasOwnProperty(c) && (et[c] = s[c]); var ft = arguments.length - 2; if (ft === 1) et.children = o; else if (1 < ft) { for (var dt = Array(ft), ht = 0; ht < ft; ht++)dt[ht] = arguments[ht + 2]; et.children = dt } if (e && e.defaultProps) for (c in ft = e.defaultProps, ft) et[c] === void 0 && (et[c] = ft[c]); return { $$typeof: l$2, type: e, key: at, ref: lt, props: et, _owner: K$3.current } } function N$4(e, s) { return { $$typeof: l$2, type: e.type, key: s, ref: e.ref, props: e.props, _owner: e._owner } } function O$4(e) { return typeof e == "object" && e !== null && e.$$typeof === l$2 } function escape(e) { var s = { "=": "=0", ":": "=2" }; return "$" + e.replace(/[=:]/g, function (o) { return s[o] }) } var P$4 = /\/+/g; function Q$4(e, s) { return typeof e == "object" && e !== null && e.key != null ? escape("" + e.key) : s.toString(36) } function R$3(e, s, o, c, et) { var at = typeof e; (at === "undefined" || at === "boolean") && (e = null); var lt = !1; if (e === null) lt = !0; else switch (at) { case "string": case "number": lt = !0; break; case "object": switch (e.$$typeof) { case l$2: case n$1: lt = !0 } }if (lt) return lt = e, et = et(lt), e = c === "" ? "." + Q$4(lt, 0) : c, I$3(et) ? (o = "", e != null && (o = e.replace(P$4, "$&/") + "/"), R$3(et, s, o, "", function (ht) { return ht })) : et != null && (O$4(et) && (et = N$4(et, o + (!et.key || lt && lt.key === et.key ? "" : ("" + et.key).replace(P$4, "$&/") + "/") + e)), s.push(et)), 1; if (lt = 0, c = c === "" ? "." : c + ":", I$3(e)) for (var ft = 0; ft < e.length; ft++) { at = e[ft]; var dt = c + Q$4(at, ft); lt += R$3(at, s, o, dt, et) } else if (dt = A$3(e), typeof dt == "function") for (e = dt.call(e), ft = 0; !(at = e.next()).done;)at = at.value, dt = c + Q$4(at, ft++), lt += R$3(at, s, o, dt, et); else if (at === "object") throw s = String(e), Error("Objects are not valid as a React child (found: " + (s === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : s) + "). If you meant to render a collection of children, use an array instead."); return lt } function S$4(e, s, o) { if (e == null) return e; var c = [], et = 0; return R$3(e, c, "", "", function (at) { return s.call(o, at, et++) }), c } function T$3(e) { if (e._status === -1) { var s = e._result; s = s(), s.then(function (o) { (e._status === 0 || e._status === -1) && (e._status = 1, e._result = o) }, function (o) { (e._status === 0 || e._status === -1) && (e._status = 2, e._result = o) }), e._status === -1 && (e._status = 0, e._result = s) } if (e._status === 1) return e._result.default; throw e._result } var U$3 = { current: null }, V$3 = { transition: null }, W$3 = { ReactCurrentDispatcher: U$3, ReactCurrentBatchConfig: V$3, ReactCurrentOwner: K$3 }; react_production_min.Children = { map: S$4, forEach: function (e, s, o) { S$4(e, function () { s.apply(this, arguments) }, o) }, count: function (e) { var s = 0; return S$4(e, function () { s++ }), s }, toArray: function (e) { return S$4(e, function (s) { return s }) || [] }, only: function (e) { if (!O$4(e)) throw Error("React.Children.only expected to receive a single React element child."); return e } }; react_production_min.Component = E$3; react_production_min.Fragment = p$4; react_production_min.Profiler = r$1; react_production_min.PureComponent = G$3; react_production_min.StrictMode = q$4; react_production_min.Suspense = w$1; react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$3; react_production_min.cloneElement = function (e, s, o) { if (e == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + "."); var c = C$4({}, e.props), et = e.key, at = e.ref, lt = e._owner; if (s != null) { if (s.ref !== void 0 && (at = s.ref, lt = K$3.current), s.key !== void 0 && (et = "" + s.key), e.type && e.type.defaultProps) var ft = e.type.defaultProps; for (dt in s) J$1.call(s, dt) && !L$4.hasOwnProperty(dt) && (c[dt] = s[dt] === void 0 && ft !== void 0 ? ft[dt] : s[dt]) } var dt = arguments.length - 2; if (dt === 1) c.children = o; else if (1 < dt) { ft = Array(dt); for (var ht = 0; ht < dt; ht++)ft[ht] = arguments[ht + 2]; c.children = ft } return { $$typeof: l$2, type: e.type, key: et, ref: at, props: c, _owner: lt } }; react_production_min.createContext = function (e) { return e = { $$typeof: u$1, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, e.Provider = { $$typeof: t$1, _context: e }, e.Consumer = e }; react_production_min.createElement = M$4; react_production_min.createFactory = function (e) { var s = M$4.bind(null, e); return s.type = e, s }; react_production_min.createRef = function () { return { current: null } }; react_production_min.forwardRef = function (e) { return { $$typeof: v$4, render: e } }; react_production_min.isValidElement = O$4; react_production_min.lazy = function (e) { return { $$typeof: y$2, _payload: { _status: -1, _result: e }, _init: T$3 } }; react_production_min.memo = function (e, s) { return { $$typeof: x$2, type: e, compare: s === void 0 ? null : s } }; react_production_min.startTransition = function (e) { var s = V$3.transition; V$3.transition = {}; try { e() } finally { V$3.transition = s } }; react_production_min.unstable_act = function () { throw Error("act(...) is not supported in production builds of React.") }; react_production_min.useCallback = function (e, s) { return U$3.current.useCallback(e, s) }; react_production_min.useContext = function (e) { return U$3.current.useContext(e) }; react_production_min.useDebugValue = function () { }; react_production_min.useDeferredValue = function (e) { return U$3.current.useDeferredValue(e) }; react_production_min.useEffect = function (e, s) { return U$3.current.useEffect(e, s) }; react_production_min.useId = function () { return U$3.current.useId() }; react_production_min.useImperativeHandle = function (e, s, o) { return U$3.current.useImperativeHandle(e, s, o) }; react_production_min.useInsertionEffect = function (e, s) { return U$3.current.useInsertionEffect(e, s) }; react_production_min.useLayoutEffect = function (e, s) { return U$3.current.useLayoutEffect(e, s) }; react_production_min.useMemo = function (e, s) { return U$3.current.useMemo(e, s) }; react_production_min.useReducer = function (e, s, o) { return U$3.current.useReducer(e, s, o) }; react_production_min.useRef = function (e) { return U$3.current.useRef(e) }; react_production_min.useState = function (e) { return U$3.current.useState(e) }; react_production_min.useSyncExternalStore = function (e, s, o) { return U$3.current.useSyncExternalStore(e, s, o) }; react_production_min.useTransition = function () { return U$3.current.useTransition() }; react_production_min.version = "18.2.0"; (function (e) { e.exports = react_production_min })(react); const React = getDefaultExportFromCjs(react.exports); var client = {}, reactDom = { exports: {} }, reactDom_production_min = {}, scheduler = { exports: {} }, scheduler_production_min = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (e) { function s(_n, ir) { var or = _n.length; _n.push(ir); e: for (; 0 < or;) { var ur = or - 1 >>> 1, hr = _n[ur]; if (0 < et(hr, ir)) _n[ur] = ir, _n[or] = hr, or = ur; else break e } } function o(_n) { return _n.length === 0 ? null : _n[0] } function c(_n) { if (_n.length === 0) return null; var ir = _n[0], or = _n.pop(); if (or !== ir) { _n[0] = or; e: for (var ur = 0, hr = _n.length, cr = hr >>> 1; ur < cr;) { var mr = 2 * (ur + 1) - 1, gr = _n[mr], $r = mr + 1, Er = _n[$r]; if (0 > et(gr, or)) $r < hr && 0 > et(Er, gr) ? (_n[ur] = Er, _n[$r] = or, ur = $r) : (_n[ur] = gr, _n[mr] = or, ur = mr); else if ($r < hr && 0 > et(Er, or)) _n[ur] = Er, _n[$r] = or, ur = $r; else break e } } return ir } function et(_n, ir) { var or = _n.sortIndex - ir.sortIndex; return or !== 0 ? or : _n.id - ir.id } if (typeof performance == "object" && typeof performance.now == "function") { var at = performance; e.unstable_now = function () { return at.now() } } else { var lt = Date, ft = lt.now(); e.unstable_now = function () { return lt.now() - ft } } var dt = [], ht = [], vt = 1, wt = null, St = 3, _t = !1, Nt = !1, kt = !1, Dt = typeof setTimeout == "function" ? setTimeout : null, xt = typeof clearTimeout == "function" ? clearTimeout : null, Ct = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function bt(_n) { for (var ir = o(ht); ir !== null;) { if (ir.callback === null) c(ht); else if (ir.startTime <= _n) c(ht), ir.sortIndex = ir.expirationTime, s(dt, ir); else break; ir = o(ht) } } function Pt(_n) { if (kt = !1, bt(_n), !Nt) if (o(dt) !== null) Nt = !0, rr(Rt); else { var ir = o(ht); ir !== null && ar(Pt, ir.startTime - _n) } } function Rt(_n, ir) { Nt = !1, kt && (kt = !1, xt(Zt), Zt = -1), _t = !0; var or = St; try { for (bt(ir), wt = o(dt); wt !== null && (!(wt.expirationTime > ir) || _n && !xn());) { var ur = wt.callback; if (typeof ur == "function") { wt.callback = null, St = wt.priorityLevel; var hr = ur(wt.expirationTime <= ir); ir = e.unstable_now(), typeof hr == "function" ? wt.callback = hr : wt === o(dt) && c(dt), bt(ir) } else c(dt); wt = o(dt) } if (wt !== null) var cr = !0; else { var mr = o(ht); mr !== null && ar(Pt, mr.startTime - ir), cr = !1 } return cr } finally { wt = null, St = or, _t = !1 } } var Jn = !1, er = null, Zt = -1, lr = 5, tr = -1; function xn() { return !(e.unstable_now() - tr < lr) } function jt() { if (er !== null) { var _n = e.unstable_now(); tr = _n; var ir = !0; try { ir = er(!0, _n) } finally { ir ? Gt() : (Jn = !1, er = null) } } else Jn = !1 } var Gt; if (typeof Ct == "function") Gt = function () { Ct(jt) }; else if (typeof MessageChannel < "u") { var nr = new MessageChannel, sr = nr.port2; nr.port1.onmessage = jt, Gt = function () { sr.postMessage(null) } } else Gt = function () { Dt(jt, 0) }; function rr(_n) { er = _n, Jn || (Jn = !0, Gt()) } function ar(_n, ir) { Zt = Dt(function () { _n(e.unstable_now()) }, ir) } e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function (_n) { _n.callback = null }, e.unstable_continueExecution = function () { Nt || _t || (Nt = !0, rr(Rt)) }, e.unstable_forceFrameRate = function (_n) { 0 > _n || 125 < _n ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : lr = 0 < _n ? Math.floor(1e3 / _n) : 5 }, e.unstable_getCurrentPriorityLevel = function () { return St }, e.unstable_getFirstCallbackNode = function () { return o(dt) }, e.unstable_next = function (_n) { switch (St) { case 1: case 2: case 3: var ir = 3; break; default: ir = St }var or = St; St = ir; try { return _n() } finally { St = or } }, e.unstable_pauseExecution = function () { }, e.unstable_requestPaint = function () { }, e.unstable_runWithPriority = function (_n, ir) { switch (_n) { case 1: case 2: case 3: case 4: case 5: break; default: _n = 3 }var or = St; St = _n; try { return ir() } finally { St = or } }, e.unstable_scheduleCallback = function (_n, ir, or) { var ur = e.unstable_now(); switch (typeof or == "object" && or !== null ? (or = or.delay, or = typeof or == "number" && 0 < or ? ur + or : ur) : or = ur, _n) { case 1: var hr = -1; break; case 2: hr = 250; break; case 5: hr = 1073741823; break; case 4: hr = 1e4; break; default: hr = 5e3 }return hr = or + hr, _n = { id: vt++, callback: ir, priorityLevel: _n, startTime: or, expirationTime: hr, sortIndex: -1 }, or > ur ? (_n.sortIndex = or, s(ht, _n), o(dt) === null && _n === o(ht) && (kt ? (xt(Zt), Zt = -1) : kt = !0, ar(Pt, or - ur))) : (_n.sortIndex = hr, s(dt, _n), Nt || _t || (Nt = !0, rr(Rt))), _n }, e.unstable_shouldYield = xn, e.unstable_wrapCallback = function (_n) { var ir = St; return function () { var or = St; St = ir; try { return _n.apply(this, arguments) } finally { St = or } } } })(scheduler_production_min); (function (e) { e.exports = scheduler_production_min })(scheduler);/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var aa$1 = react.exports, ca$1 = scheduler.exports; function p$3(e) { for (var s = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, o = 1; o < arguments.length; o++)s += "&args[]=" + encodeURIComponent(arguments[o]); return "Minified React error #" + e + "; visit " + s + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var da$1 = new Set, ea$2 = {}; function fa$1(e, s) { ha$1(e, s), ha$1(e + "Capture", s) } function ha$1(e, s) { for (ea$2[e] = s, e = 0; e < s.length; e++)da$1.add(s[e]) } var ia$1 = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), ja$1 = Object.prototype.hasOwnProperty, ka$1 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la$1 = {}, ma$2 = {}; function oa$1(e) { return ja$1.call(ma$2, e) ? !0 : ja$1.call(la$1, e) ? !1 : ka$1.test(e) ? ma$2[e] = !0 : (la$1[e] = !0, !1) } function pa$1(e, s, o, c) { if (o !== null && o.type === 0) return !1; switch (typeof s) { case "function": case "symbol": return !0; case "boolean": return c ? !1 : o !== null ? !o.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-"); default: return !1 } } function qa$2(e, s, o, c) { if (s === null || typeof s > "u" || pa$1(e, s, o, c)) return !0; if (c) return !1; if (o !== null) switch (o.type) { case 3: return !s; case 4: return s === !1; case 5: return isNaN(s); case 6: return isNaN(s) || 1 > s }return !1 } function v$3(e, s, o, c, et, at, lt) { this.acceptsBooleans = s === 2 || s === 3 || s === 4, this.attributeName = c, this.attributeNamespace = et, this.mustUseProperty = o, this.propertyName = e, this.type = s, this.sanitizeURL = at, this.removeEmptyString = lt } var z$3 = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) { z$3[e] = new v$3(e, 0, !1, e, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (e) { var s = e[0]; z$3[s] = new v$3(s, 1, !1, e[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) { z$3[e] = new v$3(e, 2, !1, e.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) { z$3[e] = new v$3(e, 2, !1, e, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) { z$3[e] = new v$3(e, 3, !1, e.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (e) { z$3[e] = new v$3(e, 3, !0, e, null, !1, !1) });["capture", "download"].forEach(function (e) { z$3[e] = new v$3(e, 4, !1, e, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (e) { z$3[e] = new v$3(e, 6, !1, e, null, !1, !1) });["rowSpan", "start"].forEach(function (e) { z$3[e] = new v$3(e, 5, !1, e.toLowerCase(), null, !1, !1) }); var ra$1 = /[\-:]([a-z])/g; function sa$2(e) { return e[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) { var s = e.replace(ra$1, sa$2); z$3[s] = new v$3(s, 1, !1, e, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) { var s = e.replace(ra$1, sa$2); z$3[s] = new v$3(s, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (e) { var s = e.replace(ra$1, sa$2); z$3[s] = new v$3(s, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (e) { z$3[e] = new v$3(e, 1, !1, e.toLowerCase(), null, !1, !1) }); z$3.xlinkHref = new v$3("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (e) { z$3[e] = new v$3(e, 1, !1, e.toLowerCase(), null, !0, !0) }); function ta$2(e, s, o, c) { var et = z$3.hasOwnProperty(s) ? z$3[s] : null; (et !== null ? et.type !== 0 : c || !(2 < s.length) || s[0] !== "o" && s[0] !== "O" || s[1] !== "n" && s[1] !== "N") && (qa$2(s, o, et, c) && (o = null), c || et === null ? oa$1(s) && (o === null ? e.removeAttribute(s) : e.setAttribute(s, "" + o)) : et.mustUseProperty ? e[et.propertyName] = o === null ? et.type === 3 ? !1 : "" : o : (s = et.attributeName, c = et.attributeNamespace, o === null ? e.removeAttribute(s) : (et = et.type, o = et === 3 || et === 4 && o === !0 ? "" : "" + o, c ? e.setAttributeNS(c, s, o) : e.setAttribute(s, o)))) } var ua$1 = aa$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va$1 = Symbol.for("react.element"), wa$2 = Symbol.for("react.portal"), ya$2 = Symbol.for("react.fragment"), za$1 = Symbol.for("react.strict_mode"), Aa$1 = Symbol.for("react.profiler"), Ba$1 = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea$2 = Symbol.for("react.suspense"), Fa$1 = Symbol.for("react.suspense_list"), Ga$1 = Symbol.for("react.memo"), Ha$1 = Symbol.for("react.lazy"), Ia$1 = Symbol.for("react.offscreen"), Ja$1 = Symbol.iterator; function Ka$1(e) { return e === null || typeof e != "object" ? null : (e = Ja$1 && e[Ja$1] || e["@@iterator"], typeof e == "function" ? e : null) } var A$2 = Object.assign, La$2; function Ma$1(e) {
	if (La$2 === void 0) try { throw Error() } catch (o) { var s = o.stack.trim().match(/\n( *(at )?)/); La$2 = s && s[1] || "" } return `
`+ La$2 + e
} var Na$1 = !1; function Oa$1(e, s) {
	if (!e || Na$1) return ""; Na$1 = !0; var o = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (s) if (s = function () { throw Error() }, Object.defineProperty(s.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(s, []) } catch (ht) { var c = ht } Reflect.construct(e, [], s) } else { try { s.call() } catch (ht) { c = ht } e.call(s.prototype) } else { try { throw Error() } catch (ht) { c = ht } e() } } catch (ht) {
		if (ht && c && typeof ht.stack == "string") {
			for (var et = ht.stack.split(`
`), at = c.stack.split(`
`), lt = et.length - 1, ft = at.length - 1; 1 <= lt && 0 <= ft && et[lt] !== at[ft];)ft--; for (; 1 <= lt && 0 <= ft; lt--, ft--)if (et[lt] !== at[ft]) {
				if (lt !== 1 || ft !== 1) do if (lt--, ft--, 0 > ft || et[lt] !== at[ft]) {
					var dt = `
`+ et[lt].replace(" at new ", " at "); return e.displayName && dt.includes("<anonymous>") && (dt = dt.replace("<anonymous>", e.displayName)), dt
				} while (1 <= lt && 0 <= ft); break
			}
		}
	} finally { Na$1 = !1, Error.prepareStackTrace = o } return (e = e ? e.displayName || e.name : "") ? Ma$1(e) : ""
} function Pa$1(e) { switch (e.tag) { case 5: return Ma$1(e.type); case 16: return Ma$1("Lazy"); case 13: return Ma$1("Suspense"); case 19: return Ma$1("SuspenseList"); case 0: case 2: case 15: return e = Oa$1(e.type, !1), e; case 11: return e = Oa$1(e.type.render, !1), e; case 1: return e = Oa$1(e.type, !0), e; default: return "" } } function Qa$1(e) { if (e == null) return null; if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e; switch (e) { case ya$2: return "Fragment"; case wa$2: return "Portal"; case Aa$1: return "Profiler"; case za$1: return "StrictMode"; case Ea$2: return "Suspense"; case Fa$1: return "SuspenseList" }if (typeof e == "object") switch (e.$$typeof) { case Ca: return (e.displayName || "Context") + ".Consumer"; case Ba$1: return (e._context.displayName || "Context") + ".Provider"; case Da: var s = e.render; return e = e.displayName, e || (e = s.displayName || s.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case Ga$1: return s = e.displayName || null, s !== null ? s : Qa$1(e.type) || "Memo"; case Ha$1: s = e._payload, e = e._init; try { return Qa$1(e(s)) } catch { } }return null } function Ra$1(e) { var s = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (s.displayName || "Context") + ".Consumer"; case 10: return (s._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = s.render, e = e.displayName || e.name || "", s.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return s; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return Qa$1(s); case 8: return s === za$1 ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof s == "function") return s.displayName || s.name || null; if (typeof s == "string") return s }return null } function Sa$1(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": return e; case "object": return e; default: return "" } } function Ta$1(e) { var s = e.type; return (e = e.nodeName) && e.toLowerCase() === "input" && (s === "checkbox" || s === "radio") } function Ua$2(e) { var s = Ta$1(e) ? "checked" : "value", o = Object.getOwnPropertyDescriptor(e.constructor.prototype, s), c = "" + e[s]; if (!e.hasOwnProperty(s) && typeof o < "u" && typeof o.get == "function" && typeof o.set == "function") { var et = o.get, at = o.set; return Object.defineProperty(e, s, { configurable: !0, get: function () { return et.call(this) }, set: function (lt) { c = "" + lt, at.call(this, lt) } }), Object.defineProperty(e, s, { enumerable: o.enumerable }), { getValue: function () { return c }, setValue: function (lt) { c = "" + lt }, stopTracking: function () { e._valueTracker = null, delete e[s] } } } } function Va$1(e) { e._valueTracker || (e._valueTracker = Ua$2(e)) } function Wa$1(e) { if (!e) return !1; var s = e._valueTracker; if (!s) return !0; var o = s.getValue(), c = ""; return e && (c = Ta$1(e) ? e.checked ? "true" : "false" : e.value), e = c, e !== o ? (s.setValue(e), !0) : !1 } function Xa$1(e) { if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null; try { return e.activeElement || e.body } catch { return e.body } } function Ya$1(e, s) { var o = s.checked; return A$2({}, s, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: o != null ? o : e._wrapperState.initialChecked }) } function Za(e, s) { var o = s.defaultValue == null ? "" : s.defaultValue, c = s.checked != null ? s.checked : s.defaultChecked; o = Sa$1(s.value != null ? s.value : o), e._wrapperState = { initialChecked: c, initialValue: o, controlled: s.type === "checkbox" || s.type === "radio" ? s.checked != null : s.value != null } } function ab$1(e, s) { s = s.checked, s != null && ta$2(e, "checked", s, !1) } function bb$1(e, s) { ab$1(e, s); var o = Sa$1(s.value), c = s.type; if (o != null) c === "number" ? (o === 0 && e.value === "" || e.value != o) && (e.value = "" + o) : e.value !== "" + o && (e.value = "" + o); else if (c === "submit" || c === "reset") { e.removeAttribute("value"); return } s.hasOwnProperty("value") ? cb$1(e, s.type, o) : s.hasOwnProperty("defaultValue") && cb$1(e, s.type, Sa$1(s.defaultValue)), s.checked == null && s.defaultChecked != null && (e.defaultChecked = !!s.defaultChecked) } function db$2(e, s, o) { if (s.hasOwnProperty("value") || s.hasOwnProperty("defaultValue")) { var c = s.type; if (!(c !== "submit" && c !== "reset" || s.value !== void 0 && s.value !== null)) return; s = "" + e._wrapperState.initialValue, o || s === e.value || (e.value = s), e.defaultValue = s } o = e.name, o !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, o !== "" && (e.name = o) } function cb$1(e, s, o) { (s !== "number" || Xa$1(e.ownerDocument) !== e) && (o == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + o && (e.defaultValue = "" + o)) } var eb$1 = Array.isArray; function fb$1(e, s, o, c) { if (e = e.options, s) { s = {}; for (var et = 0; et < o.length; et++)s["$" + o[et]] = !0; for (o = 0; o < e.length; o++)et = s.hasOwnProperty("$" + e[o].value), e[o].selected !== et && (e[o].selected = et), et && c && (e[o].defaultSelected = !0) } else { for (o = "" + Sa$1(o), s = null, et = 0; et < e.length; et++) { if (e[et].value === o) { e[et].selected = !0, c && (e[et].defaultSelected = !0); return } s !== null || e[et].disabled || (s = e[et]) } s !== null && (s.selected = !0) } } function gb$1(e, s) { if (s.dangerouslySetInnerHTML != null) throw Error(p$3(91)); return A$2({}, s, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function hb$1(e, s) { var o = s.value; if (o == null) { if (o = s.children, s = s.defaultValue, o != null) { if (s != null) throw Error(p$3(92)); if (eb$1(o)) { if (1 < o.length) throw Error(p$3(93)); o = o[0] } s = o } s == null && (s = ""), o = s } e._wrapperState = { initialValue: Sa$1(o) } } function ib$1(e, s) { var o = Sa$1(s.value), c = Sa$1(s.defaultValue); o != null && (o = "" + o, o !== e.value && (e.value = o), s.defaultValue == null && e.defaultValue !== o && (e.defaultValue = o)), c != null && (e.defaultValue = "" + c) } function jb$1(e) { var s = e.textContent; s === e._wrapperState.initialValue && s !== "" && s !== null && (e.value = s) } function kb$1(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function lb$1(e, s) { return e == null || e === "http://www.w3.org/1999/xhtml" ? kb$1(s) : e === "http://www.w3.org/2000/svg" && s === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e } var mb$1, nb$1 = function (e) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (s, o, c, et) { MSApp.execUnsafeLocalFunction(function () { return e(s, o, c, et) }) } : e }(function (e, s) { if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = s; else { for (mb$1 = mb$1 || document.createElement("div"), mb$1.innerHTML = "<svg>" + s.valueOf().toString() + "</svg>", s = mb$1.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; s.firstChild;)e.appendChild(s.firstChild) } }); function ob$1(e, s) { if (s) { var o = e.firstChild; if (o && o === e.lastChild && o.nodeType === 3) { o.nodeValue = s; return } } e.textContent = s } var pb$1 = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, qb$1 = ["Webkit", "ms", "Moz", "O"]; Object.keys(pb$1).forEach(function (e) { qb$1.forEach(function (s) { s = s + e.charAt(0).toUpperCase() + e.substring(1), pb$1[s] = pb$1[e] }) }); function rb$1(e, s, o) { return s == null || typeof s == "boolean" || s === "" ? "" : o || typeof s != "number" || s === 0 || pb$1.hasOwnProperty(e) && pb$1[e] ? ("" + s).trim() : s + "px" } function sb$1(e, s) { e = e.style; for (var o in s) if (s.hasOwnProperty(o)) { var c = o.indexOf("--") === 0, et = rb$1(o, s[o], c); o === "float" && (o = "cssFloat"), c ? e.setProperty(o, et) : e[o] = et } } var tb = A$2({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function ub$1(e, s) { if (s) { if (tb[e] && (s.children != null || s.dangerouslySetInnerHTML != null)) throw Error(p$3(137, e)); if (s.dangerouslySetInnerHTML != null) { if (s.children != null) throw Error(p$3(60)); if (typeof s.dangerouslySetInnerHTML != "object" || !("__html" in s.dangerouslySetInnerHTML)) throw Error(p$3(61)) } if (s.style != null && typeof s.style != "object") throw Error(p$3(62)) } } function vb$1(e, s) { if (e.indexOf("-") === -1) return typeof s.is == "string"; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var wb$1 = null; function xb$1(e) { return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e } var yb$1 = null, zb$1 = null, Ab$1 = null; function Bb$1(e) { if (e = Cb$1(e)) { if (typeof yb$1 != "function") throw Error(p$3(280)); var s = e.stateNode; s && (s = Db$1(s), yb$1(e.stateNode, e.type, s)) } } function Eb$1(e) { zb$1 ? Ab$1 ? Ab$1.push(e) : Ab$1 = [e] : zb$1 = e } function Fb$1() { if (zb$1) { var e = zb$1, s = Ab$1; if (Ab$1 = zb$1 = null, Bb$1(e), s) for (e = 0; e < s.length; e++)Bb$1(s[e]) } } function Gb$1(e, s) { return e(s) } function Hb$1() { } var Ib$1 = !1; function Jb$1(e, s, o) { if (Ib$1) return e(s, o); Ib$1 = !0; try { return Gb$1(e, s, o) } finally { Ib$1 = !1, (zb$1 !== null || Ab$1 !== null) && (Hb$1(), Fb$1()) } } function Kb$1(e, s) { var o = e.stateNode; if (o === null) return null; var c = Db$1(o); if (c === null) return null; o = c[s]; e: switch (s) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (c = !c.disabled) || (e = e.type, c = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !c; break e; default: e = !1 }if (e) return null; if (o && typeof o != "function") throw Error(p$3(231, s, typeof o)); return o } var Lb$1 = !1; if (ia$1) try { var Mb$1 = {}; Object.defineProperty(Mb$1, "passive", { get: function () { Lb$1 = !0 } }), window.addEventListener("test", Mb$1, Mb$1), window.removeEventListener("test", Mb$1, Mb$1) } catch { Lb$1 = !1 } function Nb$1(e, s, o, c, et, at, lt, ft, dt) { var ht = Array.prototype.slice.call(arguments, 3); try { s.apply(o, ht) } catch (vt) { this.onError(vt) } } var Ob$1 = !1, Pb$1 = null, Qb$1 = !1, Rb$1 = null, Sb$1 = { onError: function (e) { Ob$1 = !0, Pb$1 = e } }; function Tb$1(e, s, o, c, et, at, lt, ft, dt) { Ob$1 = !1, Pb$1 = null, Nb$1.apply(Sb$1, arguments) } function Ub$1(e, s, o, c, et, at, lt, ft, dt) { if (Tb$1.apply(this, arguments), Ob$1) { if (Ob$1) { var ht = Pb$1; Ob$1 = !1, Pb$1 = null } else throw Error(p$3(198)); Qb$1 || (Qb$1 = !0, Rb$1 = ht) } } function Vb$1(e) { var s = e, o = e; if (e.alternate) for (; s.return;)s = s.return; else { e = s; do s = e, (s.flags & 4098) !== 0 && (o = s.return), e = s.return; while (e) } return s.tag === 3 ? o : null } function Wb$1(e) { if (e.tag === 13) { var s = e.memoizedState; if (s === null && (e = e.alternate, e !== null && (s = e.memoizedState)), s !== null) return s.dehydrated } return null } function Xb$1(e) { if (Vb$1(e) !== e) throw Error(p$3(188)) } function Yb$1(e) { var s = e.alternate; if (!s) { if (s = Vb$1(e), s === null) throw Error(p$3(188)); return s !== e ? null : e } for (var o = e, c = s; ;) { var et = o.return; if (et === null) break; var at = et.alternate; if (at === null) { if (c = et.return, c !== null) { o = c; continue } break } if (et.child === at.child) { for (at = et.child; at;) { if (at === o) return Xb$1(et), e; if (at === c) return Xb$1(et), s; at = at.sibling } throw Error(p$3(188)) } if (o.return !== c.return) o = et, c = at; else { for (var lt = !1, ft = et.child; ft;) { if (ft === o) { lt = !0, o = et, c = at; break } if (ft === c) { lt = !0, c = et, o = at; break } ft = ft.sibling } if (!lt) { for (ft = at.child; ft;) { if (ft === o) { lt = !0, o = at, c = et; break } if (ft === c) { lt = !0, c = at, o = et; break } ft = ft.sibling } if (!lt) throw Error(p$3(189)) } } if (o.alternate !== c) throw Error(p$3(190)) } if (o.tag !== 3) throw Error(p$3(188)); return o.stateNode.current === o ? e : s } function Zb$1(e) { return e = Yb$1(e), e !== null ? $b$1(e) : null } function $b$1(e) { if (e.tag === 5 || e.tag === 6) return e; for (e = e.child; e !== null;) { var s = $b$1(e); if (s !== null) return s; e = e.sibling } return null } var ac$1 = ca$1.unstable_scheduleCallback, bc$1 = ca$1.unstable_cancelCallback, cc$2 = ca$1.unstable_shouldYield, dc$2 = ca$1.unstable_requestPaint, B$3 = ca$1.unstable_now, ec$1 = ca$1.unstable_getCurrentPriorityLevel, fc$2 = ca$1.unstable_ImmediatePriority, gc$1 = ca$1.unstable_UserBlockingPriority, hc$2 = ca$1.unstable_NormalPriority, ic$2 = ca$1.unstable_LowPriority, jc$2 = ca$1.unstable_IdlePriority, kc$1 = null, lc$1 = null; function mc$2(e) { if (lc$1 && typeof lc$1.onCommitFiberRoot == "function") try { lc$1.onCommitFiberRoot(kc$1, e, void 0, (e.current.flags & 128) === 128) } catch { } } var oc$1 = Math.clz32 ? Math.clz32 : nc$1, pc$1 = Math.log, qc$2 = Math.LN2; function nc$1(e) { return e >>>= 0, e === 0 ? 32 : 31 - (pc$1(e) / qc$2 | 0) | 0 } var rc$1 = 64, sc$1 = 4194304; function tc$1(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return e & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function uc$1(e, s) { var o = e.pendingLanes; if (o === 0) return 0; var c = 0, et = e.suspendedLanes, at = e.pingedLanes, lt = o & 268435455; if (lt !== 0) { var ft = lt & ~et; ft !== 0 ? c = tc$1(ft) : (at &= lt, at !== 0 && (c = tc$1(at))) } else lt = o & ~et, lt !== 0 ? c = tc$1(lt) : at !== 0 && (c = tc$1(at)); if (c === 0) return 0; if (s !== 0 && s !== c && (s & et) === 0 && (et = c & -c, at = s & -s, et >= at || et === 16 && (at & 4194240) !== 0)) return s; if ((c & 4) !== 0 && (c |= o & 16), s = e.entangledLanes, s !== 0) for (e = e.entanglements, s &= c; 0 < s;)o = 31 - oc$1(s), et = 1 << o, c |= e[o], s &= ~et; return c } function vc$1(e, s) { switch (e) { case 1: case 2: case 4: return s + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return s + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function wc$2(e, s) { for (var o = e.suspendedLanes, c = e.pingedLanes, et = e.expirationTimes, at = e.pendingLanes; 0 < at;) { var lt = 31 - oc$1(at), ft = 1 << lt, dt = et[lt]; dt === -1 ? ((ft & o) === 0 || (ft & c) !== 0) && (et[lt] = vc$1(ft, s)) : dt <= s && (e.expiredLanes |= ft), at &= ~ft } } function xc$1(e) { return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0 } function yc$1() { var e = rc$1; return rc$1 <<= 1, (rc$1 & 4194240) === 0 && (rc$1 = 64), e } function zc$2(e) { for (var s = [], o = 0; 31 > o; o++)s.push(e); return s } function Ac$2(e, s, o) { e.pendingLanes |= s, s !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, s = 31 - oc$1(s), e[s] = o } function Bc$1(e, s) { var o = e.pendingLanes & ~s; e.pendingLanes = s, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= s, e.mutableReadLanes &= s, e.entangledLanes &= s, s = e.entanglements; var c = e.eventTimes; for (e = e.expirationTimes; 0 < o;) { var et = 31 - oc$1(o), at = 1 << et; s[et] = 0, c[et] = -1, e[et] = -1, o &= ~at } } function Cc$1(e, s) { var o = e.entangledLanes |= s; for (e = e.entanglements; o;) { var c = 31 - oc$1(o), et = 1 << c; et & s | e[c] & s && (e[c] |= s), o &= ~et } } var C$3 = 0; function Dc$1(e) { return e &= -e, 1 < e ? 4 < e ? (e & 268435455) !== 0 ? 16 : 536870912 : 4 : 1 } var Ec$2, Fc$2, Gc$2, Hc$2, Ic$1, Jc$2 = !1, Kc$2 = [], Lc$2 = null, Mc$1 = null, Nc$1 = null, Oc$2 = new Map, Pc$1 = new Map, Qc$2 = [], Rc$1 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function Sc$1(e, s) { switch (e) { case "focusin": case "focusout": Lc$2 = null; break; case "dragenter": case "dragleave": Mc$1 = null; break; case "mouseover": case "mouseout": Nc$1 = null; break; case "pointerover": case "pointerout": Oc$2.delete(s.pointerId); break; case "gotpointercapture": case "lostpointercapture": Pc$1.delete(s.pointerId) } } function Tc$1(e, s, o, c, et, at) { return e === null || e.nativeEvent !== at ? (e = { blockedOn: s, domEventName: o, eventSystemFlags: c, nativeEvent: at, targetContainers: [et] }, s !== null && (s = Cb$1(s), s !== null && Fc$2(s)), e) : (e.eventSystemFlags |= c, s = e.targetContainers, et !== null && s.indexOf(et) === -1 && s.push(et), e) } function Uc$2(e, s, o, c, et) { switch (s) { case "focusin": return Lc$2 = Tc$1(Lc$2, e, s, o, c, et), !0; case "dragenter": return Mc$1 = Tc$1(Mc$1, e, s, o, c, et), !0; case "mouseover": return Nc$1 = Tc$1(Nc$1, e, s, o, c, et), !0; case "pointerover": var at = et.pointerId; return Oc$2.set(at, Tc$1(Oc$2.get(at) || null, e, s, o, c, et)), !0; case "gotpointercapture": return at = et.pointerId, Pc$1.set(at, Tc$1(Pc$1.get(at) || null, e, s, o, c, et)), !0 }return !1 } function Vc$1(e) { var s = Wc$1(e.target); if (s !== null) { var o = Vb$1(s); if (o !== null) { if (s = o.tag, s === 13) { if (s = Wb$1(o), s !== null) { e.blockedOn = s, Ic$1(e.priority, function () { Gc$2(o) }); return } } else if (s === 3 && o.stateNode.current.memoizedState.isDehydrated) { e.blockedOn = o.tag === 3 ? o.stateNode.containerInfo : null; return } } } e.blockedOn = null } function Xc$2(e) { if (e.blockedOn !== null) return !1; for (var s = e.targetContainers; 0 < s.length;) { var o = Yc$2(e.domEventName, e.eventSystemFlags, s[0], e.nativeEvent); if (o === null) { o = e.nativeEvent; var c = new o.constructor(o.type, o); wb$1 = c, o.target.dispatchEvent(c), wb$1 = null } else return s = Cb$1(o), s !== null && Fc$2(s), e.blockedOn = o, !1; s.shift() } return !0 } function Zc$2(e, s, o) { Xc$2(e) && o.delete(s) } function $c$1() { Jc$2 = !1, Lc$2 !== null && Xc$2(Lc$2) && (Lc$2 = null), Mc$1 !== null && Xc$2(Mc$1) && (Mc$1 = null), Nc$1 !== null && Xc$2(Nc$1) && (Nc$1 = null), Oc$2.forEach(Zc$2), Pc$1.forEach(Zc$2) } function ad$1(e, s) { e.blockedOn === s && (e.blockedOn = null, Jc$2 || (Jc$2 = !0, ca$1.unstable_scheduleCallback(ca$1.unstable_NormalPriority, $c$1))) } function bd$1(e) { function s(et) { return ad$1(et, e) } if (0 < Kc$2.length) { ad$1(Kc$2[0], e); for (var o = 1; o < Kc$2.length; o++) { var c = Kc$2[o]; c.blockedOn === e && (c.blockedOn = null) } } for (Lc$2 !== null && ad$1(Lc$2, e), Mc$1 !== null && ad$1(Mc$1, e), Nc$1 !== null && ad$1(Nc$1, e), Oc$2.forEach(s), Pc$1.forEach(s), o = 0; o < Qc$2.length; o++)c = Qc$2[o], c.blockedOn === e && (c.blockedOn = null); for (; 0 < Qc$2.length && (o = Qc$2[0], o.blockedOn === null);)Vc$1(o), o.blockedOn === null && Qc$2.shift() } var cd$1 = ua$1.ReactCurrentBatchConfig, dd$1 = !0; function ed$1(e, s, o, c) { var et = C$3, at = cd$1.transition; cd$1.transition = null; try { C$3 = 1, fd$1(e, s, o, c) } finally { C$3 = et, cd$1.transition = at } } function gd$1(e, s, o, c) { var et = C$3, at = cd$1.transition; cd$1.transition = null; try { C$3 = 4, fd$1(e, s, o, c) } finally { C$3 = et, cd$1.transition = at } } function fd$1(e, s, o, c) { if (dd$1) { var et = Yc$2(e, s, o, c); if (et === null) hd$1(e, s, c, id$1, o), Sc$1(e, c); else if (Uc$2(et, e, s, o, c)) c.stopPropagation(); else if (Sc$1(e, c), s & 4 && -1 < Rc$1.indexOf(e)) { for (; et !== null;) { var at = Cb$1(et); if (at !== null && Ec$2(at), at = Yc$2(e, s, o, c), at === null && hd$1(e, s, c, id$1, o), at === et) break; et = at } et !== null && c.stopPropagation() } else hd$1(e, s, c, null, o) } } var id$1 = null; function Yc$2(e, s, o, c) { if (id$1 = null, e = xb$1(c), e = Wc$1(e), e !== null) if (s = Vb$1(e), s === null) e = null; else if (o = s.tag, o === 13) { if (e = Wb$1(s), e !== null) return e; e = null } else if (o === 3) { if (s.stateNode.current.memoizedState.isDehydrated) return s.tag === 3 ? s.stateNode.containerInfo : null; e = null } else s !== e && (e = null); return id$1 = e, null } function jd$1(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (ec$1()) { case fc$2: return 1; case gc$1: return 4; case hc$2: case ic$2: return 16; case jc$2: return 536870912; default: return 16 }default: return 16 } } var kd$1 = null, ld$1 = null, md$1 = null; function nd$1() { if (md$1) return md$1; var e, s = ld$1, o = s.length, c, et = "value" in kd$1 ? kd$1.value : kd$1.textContent, at = et.length; for (e = 0; e < o && s[e] === et[e]; e++); var lt = o - e; for (c = 1; c <= lt && s[o - c] === et[at - c]; c++); return md$1 = et.slice(e, 1 < c ? 1 - c : void 0) } function od$1(e) { var s = e.keyCode; return "charCode" in e ? (e = e.charCode, e === 0 && s === 13 && (e = 13)) : e = s, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0 } function pd$1() { return !0 } function qd$1() { return !1 } function rd$1(e) { function s(o, c, et, at, lt) { this._reactName = o, this._targetInst = et, this.type = c, this.nativeEvent = at, this.target = lt, this.currentTarget = null; for (var ft in e) e.hasOwnProperty(ft) && (o = e[ft], this[ft] = o ? o(at) : at[ft]); return this.isDefaultPrevented = (at.defaultPrevented != null ? at.defaultPrevented : at.returnValue === !1) ? pd$1 : qd$1, this.isPropagationStopped = qd$1, this } return A$2(s.prototype, { preventDefault: function () { this.defaultPrevented = !0; var o = this.nativeEvent; o && (o.preventDefault ? o.preventDefault() : typeof o.returnValue != "unknown" && (o.returnValue = !1), this.isDefaultPrevented = pd$1) }, stopPropagation: function () { var o = this.nativeEvent; o && (o.stopPropagation ? o.stopPropagation() : typeof o.cancelBubble != "unknown" && (o.cancelBubble = !0), this.isPropagationStopped = pd$1) }, persist: function () { }, isPersistent: pd$1 }), s } var sd$1 = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, td$1 = rd$1(sd$1), ud$1 = A$2({}, sd$1, { view: 0, detail: 0 }), vd$1 = rd$1(ud$1), wd$1, xd$1, yd$1, Ad$1 = A$2({}, ud$1, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd$1, button: 0, buttons: 0, relatedTarget: function (e) { return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== yd$1 && (yd$1 && e.type === "mousemove" ? (wd$1 = e.screenX - yd$1.screenX, xd$1 = e.screenY - yd$1.screenY) : xd$1 = wd$1 = 0, yd$1 = e), wd$1) }, movementY: function (e) { return "movementY" in e ? e.movementY : xd$1 } }), Bd$1 = rd$1(Ad$1), Cd$1 = A$2({}, Ad$1, { dataTransfer: 0 }), Dd$1 = rd$1(Cd$1), Ed$1 = A$2({}, ud$1, { relatedTarget: 0 }), Fd$1 = rd$1(Ed$1), Gd$1 = A$2({}, sd$1, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd$1 = rd$1(Gd$1), Id$1 = A$2({}, sd$1, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), Jd$1 = rd$1(Id$1), Kd = A$2({}, sd$1, { data: 0 }), Ld = rd$1(Kd), Md = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, Nd = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function Pd(e) { var s = this.nativeEvent; return s.getModifierState ? s.getModifierState(e) : (e = Od[e]) ? !!s[e] : !1 } function zd$1() { return Pd } var Qd = A$2({}, ud$1, { key: function (e) { if (e.key) { var s = Md[e.key] || e.key; if (s !== "Unidentified") return s } return e.type === "keypress" ? (e = od$1(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? Nd[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd$1, charCode: function (e) { return e.type === "keypress" ? od$1(e) : 0 }, keyCode: function (e) { return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 }, which: function (e) { return e.type === "keypress" ? od$1(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 } }), Rd = rd$1(Qd), Sd = A$2({}, Ad$1, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd$1(Sd), Ud = A$2({}, ud$1, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd$1 }), Vd = rd$1(Ud), Wd = A$2({}, sd$1, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd$1(Wd), Yd = A$2({}, Ad$1, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), Zd = rd$1(Yd), $d = [9, 13, 27, 32], ae$1 = ia$1 && "CompositionEvent" in window, be = null; ia$1 && "documentMode" in document && (be = document.documentMode); var ce$1 = ia$1 && "TextEvent" in window && !be, de$1 = ia$1 && (!ae$1 || be && 8 < be && 11 >= be), ee$1 = String.fromCharCode(32), fe$1 = !1; function ge$1(e, s) { switch (e) { case "keyup": return $d.indexOf(s.keyCode) !== -1; case "keydown": return s.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function he$1(e) { return e = e.detail, typeof e == "object" && "data" in e ? e.data : null } var ie$1 = !1; function je$1(e, s) { switch (e) { case "compositionend": return he$1(s); case "keypress": return s.which !== 32 ? null : (fe$1 = !0, ee$1); case "textInput": return e = s.data, e === ee$1 && fe$1 ? null : e; default: return null } } function ke$1(e, s) { if (ie$1) return e === "compositionend" || !ae$1 && ge$1(e, s) ? (e = nd$1(), md$1 = ld$1 = kd$1 = null, ie$1 = !1, e) : null; switch (e) { case "paste": return null; case "keypress": if (!(s.ctrlKey || s.altKey || s.metaKey) || s.ctrlKey && s.altKey) { if (s.char && 1 < s.char.length) return s.char; if (s.which) return String.fromCharCode(s.which) } return null; case "compositionend": return de$1 && s.locale !== "ko" ? null : s.data; default: return null } } var le$1 = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function me$1(e) { var s = e && e.nodeName && e.nodeName.toLowerCase(); return s === "input" ? !!le$1[e.type] : s === "textarea" } function ne$1(e, s, o, c) { Eb$1(c), s = oe$1(s, "onChange"), 0 < s.length && (o = new td$1("onChange", "change", null, o, c), e.push({ event: o, listeners: s })) } var pe = null, qe$1 = null; function re$1(e) { se$1(e, 0) } function te$1(e) { var s = ue(e); if (Wa$1(s)) return e } function ve$1(e, s) { if (e === "change") return s } var we = !1; if (ia$1) { var xe$1; if (ia$1) { var ye = "oninput" in document; if (!ye) { var ze$1 = document.createElement("div"); ze$1.setAttribute("oninput", "return;"), ye = typeof ze$1.oninput == "function" } xe$1 = ye } else xe$1 = !1; we = xe$1 && (!document.documentMode || 9 < document.documentMode) } function Ae() { pe && (pe.detachEvent("onpropertychange", Be$1), qe$1 = pe = null) } function Be$1(e) { if (e.propertyName === "value" && te$1(qe$1)) { var s = []; ne$1(s, qe$1, e, xb$1(e)), Jb$1(re$1, s) } } function Ce$1(e, s, o) { e === "focusin" ? (Ae(), pe = s, qe$1 = o, pe.attachEvent("onpropertychange", Be$1)) : e === "focusout" && Ae() } function De$1(e) { if (e === "selectionchange" || e === "keyup" || e === "keydown") return te$1(qe$1) } function Ee$1(e, s) { if (e === "click") return te$1(s) } function Fe(e, s) { if (e === "input" || e === "change") return te$1(s) } function Ge$1(e, s) { return e === s && (e !== 0 || 1 / e === 1 / s) || e !== e && s !== s } var He$1 = typeof Object.is == "function" ? Object.is : Ge$1; function Ie$1(e, s) { if (He$1(e, s)) return !0; if (typeof e != "object" || e === null || typeof s != "object" || s === null) return !1; var o = Object.keys(e), c = Object.keys(s); if (o.length !== c.length) return !1; for (c = 0; c < o.length; c++) { var et = o[c]; if (!ja$1.call(s, et) || !He$1(e[et], s[et])) return !1 } return !0 } function Je$1(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function Ke$1(e, s) { var o = Je$1(e); e = 0; for (var c; o;) { if (o.nodeType === 3) { if (c = e + o.textContent.length, e <= s && c >= s) return { node: o, offset: s - e }; e = c } e: { for (; o;) { if (o.nextSibling) { o = o.nextSibling; break e } o = o.parentNode } o = void 0 } o = Je$1(o) } } function Le$1(e, s) { return e && s ? e === s ? !0 : e && e.nodeType === 3 ? !1 : s && s.nodeType === 3 ? Le$1(e, s.parentNode) : "contains" in e ? e.contains(s) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(s) & 16) : !1 : !1 } function Me() { for (var e = window, s = Xa$1(); s instanceof e.HTMLIFrameElement;) { try { var o = typeof s.contentWindow.location.href == "string" } catch { o = !1 } if (o) e = s.contentWindow; else break; s = Xa$1(e.document) } return s } function Ne$1(e) { var s = e && e.nodeName && e.nodeName.toLowerCase(); return s && (s === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || s === "textarea" || e.contentEditable === "true") } function Oe(e) { var s = Me(), o = e.focusedElem, c = e.selectionRange; if (s !== o && o && o.ownerDocument && Le$1(o.ownerDocument.documentElement, o)) { if (c !== null && Ne$1(o)) { if (s = c.start, e = c.end, e === void 0 && (e = s), "selectionStart" in o) o.selectionStart = s, o.selectionEnd = Math.min(e, o.value.length); else if (e = (s = o.ownerDocument || document) && s.defaultView || window, e.getSelection) { e = e.getSelection(); var et = o.textContent.length, at = Math.min(c.start, et); c = c.end === void 0 ? at : Math.min(c.end, et), !e.extend && at > c && (et = c, c = at, at = et), et = Ke$1(o, at); var lt = Ke$1(o, c); et && lt && (e.rangeCount !== 1 || e.anchorNode !== et.node || e.anchorOffset !== et.offset || e.focusNode !== lt.node || e.focusOffset !== lt.offset) && (s = s.createRange(), s.setStart(et.node, et.offset), e.removeAllRanges(), at > c ? (e.addRange(s), e.extend(lt.node, lt.offset)) : (s.setEnd(lt.node, lt.offset), e.addRange(s))) } } for (s = [], e = o; e = e.parentNode;)e.nodeType === 1 && s.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for (typeof o.focus == "function" && o.focus(), o = 0; o < s.length; o++)e = s[o], e.element.scrollLeft = e.left, e.element.scrollTop = e.top } } var Pe = ia$1 && "documentMode" in document && 11 >= document.documentMode, Qe$1 = null, Re = null, Se$1 = null, Te$1 = !1; function Ue$1(e, s, o) { var c = o.window === o ? o.document : o.nodeType === 9 ? o : o.ownerDocument; Te$1 || Qe$1 == null || Qe$1 !== Xa$1(c) || (c = Qe$1, "selectionStart" in c && Ne$1(c) ? c = { start: c.selectionStart, end: c.selectionEnd } : (c = (c.ownerDocument && c.ownerDocument.defaultView || window).getSelection(), c = { anchorNode: c.anchorNode, anchorOffset: c.anchorOffset, focusNode: c.focusNode, focusOffset: c.focusOffset }), Se$1 && Ie$1(Se$1, c) || (Se$1 = c, c = oe$1(Re, "onSelect"), 0 < c.length && (s = new td$1("onSelect", "select", null, s, o), e.push({ event: s, listeners: c }), s.target = Qe$1))) } function Ve$1(e, s) { var o = {}; return o[e.toLowerCase()] = s.toLowerCase(), o["Webkit" + e] = "webkit" + s, o["Moz" + e] = "moz" + s, o } var We$1 = { animationend: Ve$1("Animation", "AnimationEnd"), animationiteration: Ve$1("Animation", "AnimationIteration"), animationstart: Ve$1("Animation", "AnimationStart"), transitionend: Ve$1("Transition", "TransitionEnd") }, Xe$1 = {}, Ye$1 = {}; ia$1 && (Ye$1 = document.createElement("div").style, "AnimationEvent" in window || (delete We$1.animationend.animation, delete We$1.animationiteration.animation, delete We$1.animationstart.animation), "TransitionEvent" in window || delete We$1.transitionend.transition); function Ze$1(e) { if (Xe$1[e]) return Xe$1[e]; if (!We$1[e]) return e; var s = We$1[e], o; for (o in s) if (s.hasOwnProperty(o) && o in Ye$1) return Xe$1[e] = s[o]; return e } var $e = Ze$1("animationend"), af = Ze$1("animationiteration"), bf = Ze$1("animationstart"), cf = Ze$1("transitionend"), df = new Map, ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function ff(e, s) { df.set(e, s), fa$1(s, [e]) } for (var gf = 0; gf < ef.length; gf++) { var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1); ff(jf, "on" + kf) } ff($e, "onAnimationEnd"); ff(af, "onAnimationIteration"); ff(bf, "onAnimationStart"); ff("dblclick", "onDoubleClick"); ff("focusin", "onFocus"); ff("focusout", "onBlur"); ff(cf, "onTransitionEnd"); ha$1("onMouseEnter", ["mouseout", "mouseover"]); ha$1("onMouseLeave", ["mouseout", "mouseover"]); ha$1("onPointerEnter", ["pointerout", "pointerover"]); ha$1("onPointerLeave", ["pointerout", "pointerover"]); fa$1("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); fa$1("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); fa$1("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); fa$1("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); fa$1("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); fa$1("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf)); function nf(e, s, o) { var c = e.type || "unknown-event"; e.currentTarget = o, Ub$1(c, s, void 0, e), e.currentTarget = null } function se$1(e, s) { s = (s & 4) !== 0; for (var o = 0; o < e.length; o++) { var c = e[o], et = c.event; c = c.listeners; e: { var at = void 0; if (s) for (var lt = c.length - 1; 0 <= lt; lt--) { var ft = c[lt], dt = ft.instance, ht = ft.currentTarget; if (ft = ft.listener, dt !== at && et.isPropagationStopped()) break e; nf(et, ft, ht), at = dt } else for (lt = 0; lt < c.length; lt++) { if (ft = c[lt], dt = ft.instance, ht = ft.currentTarget, ft = ft.listener, dt !== at && et.isPropagationStopped()) break e; nf(et, ft, ht), at = dt } } } if (Qb$1) throw e = Rb$1, Qb$1 = !1, Rb$1 = null, e } function D$2(e, s) { var o = s[of]; o === void 0 && (o = s[of] = new Set); var c = e + "__bubble"; o.has(c) || (pf(s, e, 2, !1), o.add(c)) } function qf(e, s, o) { var c = 0; s && (c |= 4), pf(o, e, c, s) } var rf = "_reactListening" + Math.random().toString(36).slice(2); function sf(e) { if (!e[rf]) { e[rf] = !0, da$1.forEach(function (o) { o !== "selectionchange" && (mf.has(o) || qf(o, !1, e), qf(o, !0, e)) }); var s = e.nodeType === 9 ? e : e.ownerDocument; s === null || s[rf] || (s[rf] = !0, qf("selectionchange", !1, s)) } } function pf(e, s, o, c) { switch (jd$1(s)) { case 1: var et = ed$1; break; case 4: et = gd$1; break; default: et = fd$1 }o = et.bind(null, s, o, e), et = void 0, !Lb$1 || s !== "touchstart" && s !== "touchmove" && s !== "wheel" || (et = !0), c ? et !== void 0 ? e.addEventListener(s, o, { capture: !0, passive: et }) : e.addEventListener(s, o, !0) : et !== void 0 ? e.addEventListener(s, o, { passive: et }) : e.addEventListener(s, o, !1) } function hd$1(e, s, o, c, et) { var at = c; if ((s & 1) === 0 && (s & 2) === 0 && c !== null) e: for (; ;) { if (c === null) return; var lt = c.tag; if (lt === 3 || lt === 4) { var ft = c.stateNode.containerInfo; if (ft === et || ft.nodeType === 8 && ft.parentNode === et) break; if (lt === 4) for (lt = c.return; lt !== null;) { var dt = lt.tag; if ((dt === 3 || dt === 4) && (dt = lt.stateNode.containerInfo, dt === et || dt.nodeType === 8 && dt.parentNode === et)) return; lt = lt.return } for (; ft !== null;) { if (lt = Wc$1(ft), lt === null) return; if (dt = lt.tag, dt === 5 || dt === 6) { c = at = lt; continue e } ft = ft.parentNode } } c = c.return } Jb$1(function () { var ht = at, vt = xb$1(o), wt = []; e: { var St = df.get(e); if (St !== void 0) { var _t = td$1, Nt = e; switch (e) { case "keypress": if (od$1(o) === 0) break e; case "keydown": case "keyup": _t = Rd; break; case "focusin": Nt = "focus", _t = Fd$1; break; case "focusout": Nt = "blur", _t = Fd$1; break; case "beforeblur": case "afterblur": _t = Fd$1; break; case "click": if (o.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": _t = Bd$1; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": _t = Dd$1; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": _t = Vd; break; case $e: case af: case bf: _t = Hd$1; break; case cf: _t = Xd; break; case "scroll": _t = vd$1; break; case "wheel": _t = Zd; break; case "copy": case "cut": case "paste": _t = Jd$1; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": _t = Td }var kt = (s & 4) !== 0, Dt = !kt && e === "scroll", xt = kt ? St !== null ? St + "Capture" : null : St; kt = []; for (var Ct = ht, bt; Ct !== null;) { bt = Ct; var Pt = bt.stateNode; if (bt.tag === 5 && Pt !== null && (bt = Pt, xt !== null && (Pt = Kb$1(Ct, xt), Pt != null && kt.push(tf(Ct, Pt, bt)))), Dt) break; Ct = Ct.return } 0 < kt.length && (St = new _t(St, Nt, null, o, vt), wt.push({ event: St, listeners: kt })) } } if ((s & 7) === 0) { e: { if (St = e === "mouseover" || e === "pointerover", _t = e === "mouseout" || e === "pointerout", St && o !== wb$1 && (Nt = o.relatedTarget || o.fromElement) && (Wc$1(Nt) || Nt[uf])) break e; if ((_t || St) && (St = vt.window === vt ? vt : (St = vt.ownerDocument) ? St.defaultView || St.parentWindow : window, _t ? (Nt = o.relatedTarget || o.toElement, _t = ht, Nt = Nt ? Wc$1(Nt) : null, Nt !== null && (Dt = Vb$1(Nt), Nt !== Dt || Nt.tag !== 5 && Nt.tag !== 6) && (Nt = null)) : (_t = null, Nt = ht), _t !== Nt)) { if (kt = Bd$1, Pt = "onMouseLeave", xt = "onMouseEnter", Ct = "mouse", (e === "pointerout" || e === "pointerover") && (kt = Td, Pt = "onPointerLeave", xt = "onPointerEnter", Ct = "pointer"), Dt = _t == null ? St : ue(_t), bt = Nt == null ? St : ue(Nt), St = new kt(Pt, Ct + "leave", _t, o, vt), St.target = Dt, St.relatedTarget = bt, Pt = null, Wc$1(vt) === ht && (kt = new kt(xt, Ct + "enter", Nt, o, vt), kt.target = bt, kt.relatedTarget = Dt, Pt = kt), Dt = Pt, _t && Nt) t: { for (kt = _t, xt = Nt, Ct = 0, bt = kt; bt; bt = vf(bt))Ct++; for (bt = 0, Pt = xt; Pt; Pt = vf(Pt))bt++; for (; 0 < Ct - bt;)kt = vf(kt), Ct--; for (; 0 < bt - Ct;)xt = vf(xt), bt--; for (; Ct--;) { if (kt === xt || xt !== null && kt === xt.alternate) break t; kt = vf(kt), xt = vf(xt) } kt = null } else kt = null; _t !== null && wf(wt, St, _t, kt, !1), Nt !== null && Dt !== null && wf(wt, Dt, Nt, kt, !0) } } e: { if (St = ht ? ue(ht) : window, _t = St.nodeName && St.nodeName.toLowerCase(), _t === "select" || _t === "input" && St.type === "file") var Rt = ve$1; else if (me$1(St)) if (we) Rt = Fe; else { Rt = De$1; var Jn = Ce$1 } else (_t = St.nodeName) && _t.toLowerCase() === "input" && (St.type === "checkbox" || St.type === "radio") && (Rt = Ee$1); if (Rt && (Rt = Rt(e, ht))) { ne$1(wt, Rt, o, vt); break e } Jn && Jn(e, St, ht), e === "focusout" && (Jn = St._wrapperState) && Jn.controlled && St.type === "number" && cb$1(St, "number", St.value) } switch (Jn = ht ? ue(ht) : window, e) { case "focusin": (me$1(Jn) || Jn.contentEditable === "true") && (Qe$1 = Jn, Re = ht, Se$1 = null); break; case "focusout": Se$1 = Re = Qe$1 = null; break; case "mousedown": Te$1 = !0; break; case "contextmenu": case "mouseup": case "dragend": Te$1 = !1, Ue$1(wt, o, vt); break; case "selectionchange": if (Pe) break; case "keydown": case "keyup": Ue$1(wt, o, vt) }var er; if (ae$1) e: { switch (e) { case "compositionstart": var Zt = "onCompositionStart"; break e; case "compositionend": Zt = "onCompositionEnd"; break e; case "compositionupdate": Zt = "onCompositionUpdate"; break e }Zt = void 0 } else ie$1 ? ge$1(e, o) && (Zt = "onCompositionEnd") : e === "keydown" && o.keyCode === 229 && (Zt = "onCompositionStart"); Zt && (de$1 && o.locale !== "ko" && (ie$1 || Zt !== "onCompositionStart" ? Zt === "onCompositionEnd" && ie$1 && (er = nd$1()) : (kd$1 = vt, ld$1 = "value" in kd$1 ? kd$1.value : kd$1.textContent, ie$1 = !0)), Jn = oe$1(ht, Zt), 0 < Jn.length && (Zt = new Ld(Zt, e, null, o, vt), wt.push({ event: Zt, listeners: Jn }), er ? Zt.data = er : (er = he$1(o), er !== null && (Zt.data = er)))), (er = ce$1 ? je$1(e, o) : ke$1(e, o)) && (ht = oe$1(ht, "onBeforeInput"), 0 < ht.length && (vt = new Ld("onBeforeInput", "beforeinput", null, o, vt), wt.push({ event: vt, listeners: ht }), vt.data = er)) } se$1(wt, s) }) } function tf(e, s, o) { return { instance: e, listener: s, currentTarget: o } } function oe$1(e, s) { for (var o = s + "Capture", c = []; e !== null;) { var et = e, at = et.stateNode; et.tag === 5 && at !== null && (et = at, at = Kb$1(e, o), at != null && c.unshift(tf(e, at, et)), at = Kb$1(e, s), at != null && c.push(tf(e, at, et))), e = e.return } return c } function vf(e) { if (e === null) return null; do e = e.return; while (e && e.tag !== 5); return e || null } function wf(e, s, o, c, et) { for (var at = s._reactName, lt = []; o !== null && o !== c;) { var ft = o, dt = ft.alternate, ht = ft.stateNode; if (dt !== null && dt === c) break; ft.tag === 5 && ht !== null && (ft = ht, et ? (dt = Kb$1(o, at), dt != null && lt.unshift(tf(o, dt, ft))) : et || (dt = Kb$1(o, at), dt != null && lt.push(tf(o, dt, ft)))), o = o.return } lt.length !== 0 && e.push({ event: s, listeners: lt }) } var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g; function zf(e) {
	return (typeof e == "string" ? e : "" + e).replace(xf, `
`).replace(yf, "")
} function Af(e, s, o) { if (s = zf(s), zf(e) !== s && o) throw Error(p$3(425)) } function Bf() { } var Cf = null, Df = null; function Ef(e, s) { return e === "textarea" || e === "noscript" || typeof s.children == "string" || typeof s.children == "number" || typeof s.dangerouslySetInnerHTML == "object" && s.dangerouslySetInnerHTML !== null && s.dangerouslySetInnerHTML.__html != null } var Ff = typeof setTimeout == "function" ? setTimeout : void 0, Gf = typeof clearTimeout == "function" ? clearTimeout : void 0, Hf = typeof Promise == "function" ? Promise : void 0, Jf = typeof queueMicrotask == "function" ? queueMicrotask : typeof Hf < "u" ? function (e) { return Hf.resolve(null).then(e).catch(If) } : Ff; function If(e) { setTimeout(function () { throw e }) } function Kf(e, s) { var o = s, c = 0; do { var et = o.nextSibling; if (e.removeChild(o), et && et.nodeType === 8) if (o = et.data, o === "/$") { if (c === 0) { e.removeChild(et), bd$1(s); return } c-- } else o !== "$" && o !== "$?" && o !== "$!" || c++; o = et } while (o); bd$1(s) } function Lf(e) { for (; e != null; e = e.nextSibling) { var s = e.nodeType; if (s === 1 || s === 3) break; if (s === 8) { if (s = e.data, s === "$" || s === "$!" || s === "$?") break; if (s === "/$") return null } } return e } function Mf(e) { e = e.previousSibling; for (var s = 0; e;) { if (e.nodeType === 8) { var o = e.data; if (o === "$" || o === "$!" || o === "$?") { if (s === 0) return e; s-- } else o === "/$" && s++ } e = e.previousSibling } return null } var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf; function Wc$1(e) { var s = e[Of]; if (s) return s; for (var o = e.parentNode; o;) { if (s = o[uf] || o[Of]) { if (o = s.alternate, s.child !== null || o !== null && o.child !== null) for (e = Mf(e); e !== null;) { if (o = e[Of]) return o; e = Mf(e) } return s } e = o, o = e.parentNode } return null } function Cb$1(e) { return e = e[Of] || e[uf], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e } function ue(e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; throw Error(p$3(33)) } function Db$1(e) { return e[Pf] || null } var Sf = [], Tf = -1; function Uf(e) { return { current: e } } function E$2(e) { 0 > Tf || (e.current = Sf[Tf], Sf[Tf] = null, Tf--) } function G$2(e, s) { Tf++, Sf[Tf] = e.current, e.current = s } var Vf = {}, H$3 = Uf(Vf), Wf = Uf(!1), Xf = Vf; function Yf(e, s) { var o = e.type.contextTypes; if (!o) return Vf; var c = e.stateNode; if (c && c.__reactInternalMemoizedUnmaskedChildContext === s) return c.__reactInternalMemoizedMaskedChildContext; var et = {}, at; for (at in o) et[at] = s[at]; return c && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = s, e.__reactInternalMemoizedMaskedChildContext = et), et } function Zf(e) { return e = e.childContextTypes, e != null } function $f() { E$2(Wf), E$2(H$3) } function ag(e, s, o) { if (H$3.current !== Vf) throw Error(p$3(168)); G$2(H$3, s), G$2(Wf, o) } function bg(e, s, o) { var c = e.stateNode; if (s = s.childContextTypes, typeof c.getChildContext != "function") return o; c = c.getChildContext(); for (var et in c) if (!(et in s)) throw Error(p$3(108, Ra$1(e) || "Unknown", et)); return A$2({}, o, c) } function cg(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || Vf, Xf = H$3.current, G$2(H$3, e), G$2(Wf, Wf.current), !0 } function dg(e, s, o) { var c = e.stateNode; if (!c) throw Error(p$3(169)); o ? (e = bg(e, s, Xf), c.__reactInternalMemoizedMergedChildContext = e, E$2(Wf), E$2(H$3), G$2(H$3, e)) : E$2(Wf), G$2(Wf, o) } var eg = null, fg = !1, gg = !1; function hg(e) { eg === null ? eg = [e] : eg.push(e) } function ig(e) { fg = !0, hg(e) } function jg() { if (!gg && eg !== null) { gg = !0; var e = 0, s = C$3; try { var o = eg; for (C$3 = 1; e < o.length; e++) { var c = o[e]; do c = c(!0); while (c !== null) } eg = null, fg = !1 } catch (et) { throw eg !== null && (eg = eg.slice(e + 1)), ac$1(fc$2, jg), et } finally { C$3 = s, gg = !1 } } return null } var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = ""; function tg(e, s) { kg[lg++] = ng, kg[lg++] = mg, mg = e, ng = s } function ug(e, s, o) { og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, qg = e; var c = rg; e = sg; var et = 32 - oc$1(c) - 1; c &= ~(1 << et), o += 1; var at = 32 - oc$1(s) + et; if (30 < at) { var lt = et - et % 5; at = (c & (1 << lt) - 1).toString(32), c >>= lt, et -= lt, rg = 1 << 32 - oc$1(s) + et | o << et | c, sg = at + e } else rg = 1 << at | o << et | c, sg = e } function vg(e) { e.return !== null && (tg(e, 1), ug(e, 1, 0)) } function wg(e) { for (; e === mg;)mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null; for (; e === qg;)qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null } var xg = null, yg = null, I$2 = !1, zg = null; function Ag(e, s) { var o = Bg(5, null, null, 0); o.elementType = "DELETED", o.stateNode = s, o.return = e, s = e.deletions, s === null ? (e.deletions = [o], e.flags |= 16) : s.push(o) } function Cg(e, s) { switch (e.tag) { case 5: var o = e.type; return s = s.nodeType !== 1 || o.toLowerCase() !== s.nodeName.toLowerCase() ? null : s, s !== null ? (e.stateNode = s, xg = e, yg = Lf(s.firstChild), !0) : !1; case 6: return s = e.pendingProps === "" || s.nodeType !== 3 ? null : s, s !== null ? (e.stateNode = s, xg = e, yg = null, !0) : !1; case 13: return s = s.nodeType !== 8 ? null : s, s !== null ? (o = qg !== null ? { id: rg, overflow: sg } : null, e.memoizedState = { dehydrated: s, treeContext: o, retryLane: 1073741824 }, o = Bg(18, null, null, 0), o.stateNode = s, o.return = e, e.child = o, xg = e, yg = null, !0) : !1; default: return !1 } } function Dg(e) { return (e.mode & 1) !== 0 && (e.flags & 128) === 0 } function Eg(e) { if (I$2) { var s = yg; if (s) { var o = s; if (!Cg(e, s)) { if (Dg(e)) throw Error(p$3(418)); s = Lf(o.nextSibling); var c = xg; s && Cg(e, s) ? Ag(c, o) : (e.flags = e.flags & -4097 | 2, I$2 = !1, xg = e) } } else { if (Dg(e)) throw Error(p$3(418)); e.flags = e.flags & -4097 | 2, I$2 = !1, xg = e } } } function Fg(e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)e = e.return; xg = e } function Gg(e) { if (e !== xg) return !1; if (!I$2) return Fg(e), I$2 = !0, !1; var s; if ((s = e.tag !== 3) && !(s = e.tag !== 5) && (s = e.type, s = s !== "head" && s !== "body" && !Ef(e.type, e.memoizedProps)), s && (s = yg)) { if (Dg(e)) throw Hg(), Error(p$3(418)); for (; s;)Ag(e, s), s = Lf(s.nextSibling) } if (Fg(e), e.tag === 13) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(p$3(317)); e: { for (e = e.nextSibling, s = 0; e;) { if (e.nodeType === 8) { var o = e.data; if (o === "/$") { if (s === 0) { yg = Lf(e.nextSibling); break e } s-- } else o !== "$" && o !== "$!" && o !== "$?" || s++ } e = e.nextSibling } yg = null } } else yg = xg ? Lf(e.stateNode.nextSibling) : null; return !0 } function Hg() { for (var e = yg; e;)e = Lf(e.nextSibling) } function Ig() { yg = xg = null, I$2 = !1 } function Jg(e) { zg === null ? zg = [e] : zg.push(e) } var Kg = ua$1.ReactCurrentBatchConfig; function Lg(e, s) { if (e && e.defaultProps) { s = A$2({}, s), e = e.defaultProps; for (var o in e) s[o] === void 0 && (s[o] = e[o]); return s } return s } var Mg = Uf(null), Ng = null, Og = null, Pg = null; function Qg() { Pg = Og = Ng = null } function Rg(e) { var s = Mg.current; E$2(Mg), e._currentValue = s } function Sg(e, s, o) { for (; e !== null;) { var c = e.alternate; if ((e.childLanes & s) !== s ? (e.childLanes |= s, c !== null && (c.childLanes |= s)) : c !== null && (c.childLanes & s) !== s && (c.childLanes |= s), e === o) break; e = e.return } } function Tg(e, s) { Ng = e, Pg = Og = null, e = e.dependencies, e !== null && e.firstContext !== null && ((e.lanes & s) !== 0 && (Ug = !0), e.firstContext = null) } function Vg(e) { var s = e._currentValue; if (Pg !== e) if (e = { context: e, memoizedValue: s, next: null }, Og === null) { if (Ng === null) throw Error(p$3(308)); Og = e, Ng.dependencies = { lanes: 0, firstContext: e } } else Og = Og.next = e; return s } var Wg = null; function Xg(e) { Wg === null ? Wg = [e] : Wg.push(e) } function Yg(e, s, o, c) { var et = s.interleaved; return et === null ? (o.next = o, Xg(s)) : (o.next = et.next, et.next = o), s.interleaved = o, Zg(e, c) } function Zg(e, s) { e.lanes |= s; var o = e.alternate; for (o !== null && (o.lanes |= s), o = e, e = e.return; e !== null;)e.childLanes |= s, o = e.alternate, o !== null && (o.childLanes |= s), o = e, e = e.return; return o.tag === 3 ? o.stateNode : null } var $g = !1; function ah$1(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function bh$1(e, s) { e = e.updateQueue, s.updateQueue === e && (s.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function ch$1(e, s) { return { eventTime: e, lane: s, tag: 0, payload: null, callback: null, next: null } } function dh(e, s, o) { var c = e.updateQueue; if (c === null) return null; if (c = c.shared, (K$2 & 2) !== 0) { var et = c.pending; return et === null ? s.next = s : (s.next = et.next, et.next = s), c.pending = s, Zg(e, o) } return et = c.interleaved, et === null ? (s.next = s, Xg(c)) : (s.next = et.next, et.next = s), c.interleaved = s, Zg(e, o) } function eh$1(e, s, o) { if (s = s.updateQueue, s !== null && (s = s.shared, (o & 4194240) !== 0)) { var c = s.lanes; c &= e.pendingLanes, o |= c, s.lanes = o, Cc$1(e, o) } } function fh$1(e, s) { var o = e.updateQueue, c = e.alternate; if (c !== null && (c = c.updateQueue, o === c)) { var et = null, at = null; if (o = o.firstBaseUpdate, o !== null) { do { var lt = { eventTime: o.eventTime, lane: o.lane, tag: o.tag, payload: o.payload, callback: o.callback, next: null }; at === null ? et = at = lt : at = at.next = lt, o = o.next } while (o !== null); at === null ? et = at = s : at = at.next = s } else et = at = s; o = { baseState: c.baseState, firstBaseUpdate: et, lastBaseUpdate: at, shared: c.shared, effects: c.effects }, e.updateQueue = o; return } e = o.lastBaseUpdate, e === null ? o.firstBaseUpdate = s : e.next = s, o.lastBaseUpdate = s } function gh(e, s, o, c) { var et = e.updateQueue; $g = !1; var at = et.firstBaseUpdate, lt = et.lastBaseUpdate, ft = et.shared.pending; if (ft !== null) { et.shared.pending = null; var dt = ft, ht = dt.next; dt.next = null, lt === null ? at = ht : lt.next = ht, lt = dt; var vt = e.alternate; vt !== null && (vt = vt.updateQueue, ft = vt.lastBaseUpdate, ft !== lt && (ft === null ? vt.firstBaseUpdate = ht : ft.next = ht, vt.lastBaseUpdate = dt)) } if (at !== null) { var wt = et.baseState; lt = 0, vt = ht = dt = null, ft = at; do { var St = ft.lane, _t = ft.eventTime; if ((c & St) === St) { vt !== null && (vt = vt.next = { eventTime: _t, lane: 0, tag: ft.tag, payload: ft.payload, callback: ft.callback, next: null }); e: { var Nt = e, kt = ft; switch (St = s, _t = o, kt.tag) { case 1: if (Nt = kt.payload, typeof Nt == "function") { wt = Nt.call(_t, wt, St); break e } wt = Nt; break e; case 3: Nt.flags = Nt.flags & -65537 | 128; case 0: if (Nt = kt.payload, St = typeof Nt == "function" ? Nt.call(_t, wt, St) : Nt, St == null) break e; wt = A$2({}, wt, St); break e; case 2: $g = !0 } } ft.callback !== null && ft.lane !== 0 && (e.flags |= 64, St = et.effects, St === null ? et.effects = [ft] : St.push(ft)) } else _t = { eventTime: _t, lane: St, tag: ft.tag, payload: ft.payload, callback: ft.callback, next: null }, vt === null ? (ht = vt = _t, dt = wt) : vt = vt.next = _t, lt |= St; if (ft = ft.next, ft === null) { if (ft = et.shared.pending, ft === null) break; St = ft, ft = St.next, St.next = null, et.lastBaseUpdate = St, et.shared.pending = null } } while (1); if (vt === null && (dt = wt), et.baseState = dt, et.firstBaseUpdate = ht, et.lastBaseUpdate = vt, s = et.shared.interleaved, s !== null) { et = s; do lt |= et.lane, et = et.next; while (et !== s) } else at === null && (et.shared.lanes = 0); hh$1 |= lt, e.lanes = lt, e.memoizedState = wt } } function ih$1(e, s, o) { if (e = s.effects, s.effects = null, e !== null) for (s = 0; s < e.length; s++) { var c = e[s], et = c.callback; if (et !== null) { if (c.callback = null, c = o, typeof et != "function") throw Error(p$3(191, et)); et.call(c) } } } var jh = new aa$1.Component().refs; function kh(e, s, o, c) { s = e.memoizedState, o = o(c, s), o = o == null ? s : A$2({}, s, o), e.memoizedState = o, e.lanes === 0 && (e.updateQueue.baseState = o) } var nh = { isMounted: function (e) { return (e = e._reactInternals) ? Vb$1(e) === e : !1 }, enqueueSetState: function (e, s, o) { e = e._reactInternals; var c = L$3(), et = lh$1(e), at = ch$1(c, et); at.payload = s, o != null && (at.callback = o), s = dh(e, at, et), s !== null && (mh(s, e, et, c), eh$1(s, e, et)) }, enqueueReplaceState: function (e, s, o) { e = e._reactInternals; var c = L$3(), et = lh$1(e), at = ch$1(c, et); at.tag = 1, at.payload = s, o != null && (at.callback = o), s = dh(e, at, et), s !== null && (mh(s, e, et, c), eh$1(s, e, et)) }, enqueueForceUpdate: function (e, s) { e = e._reactInternals; var o = L$3(), c = lh$1(e), et = ch$1(o, c); et.tag = 2, s != null && (et.callback = s), s = dh(e, et, c), s !== null && (mh(s, e, c, o), eh$1(s, e, c)) } }; function oh$1(e, s, o, c, et, at, lt) { return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(c, at, lt) : s.prototype && s.prototype.isPureReactComponent ? !Ie$1(o, c) || !Ie$1(et, at) : !0 } function ph(e, s, o) { var c = !1, et = Vf, at = s.contextType; return typeof at == "object" && at !== null ? at = Vg(at) : (et = Zf(s) ? Xf : H$3.current, c = s.contextTypes, at = (c = c != null) ? Yf(e, et) : Vf), s = new s(o, at), e.memoizedState = s.state !== null && s.state !== void 0 ? s.state : null, s.updater = nh, e.stateNode = s, s._reactInternals = e, c && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = et, e.__reactInternalMemoizedMaskedChildContext = at), s } function qh(e, s, o, c) { e = s.state, typeof s.componentWillReceiveProps == "function" && s.componentWillReceiveProps(o, c), typeof s.UNSAFE_componentWillReceiveProps == "function" && s.UNSAFE_componentWillReceiveProps(o, c), s.state !== e && nh.enqueueReplaceState(s, s.state, null) } function rh$1(e, s, o, c) { var et = e.stateNode; et.props = o, et.state = e.memoizedState, et.refs = jh, ah$1(e); var at = s.contextType; typeof at == "object" && at !== null ? et.context = Vg(at) : (at = Zf(s) ? Xf : H$3.current, et.context = Yf(e, at)), et.state = e.memoizedState, at = s.getDerivedStateFromProps, typeof at == "function" && (kh(e, s, at, o), et.state = e.memoizedState), typeof s.getDerivedStateFromProps == "function" || typeof et.getSnapshotBeforeUpdate == "function" || typeof et.UNSAFE_componentWillMount != "function" && typeof et.componentWillMount != "function" || (s = et.state, typeof et.componentWillMount == "function" && et.componentWillMount(), typeof et.UNSAFE_componentWillMount == "function" && et.UNSAFE_componentWillMount(), s !== et.state && nh.enqueueReplaceState(et, et.state, null), gh(e, o, et, c), et.state = e.memoizedState), typeof et.componentDidMount == "function" && (e.flags |= 4194308) } function sh$1(e, s, o) { if (e = o.ref, e !== null && typeof e != "function" && typeof e != "object") { if (o._owner) { if (o = o._owner, o) { if (o.tag !== 1) throw Error(p$3(309)); var c = o.stateNode } if (!c) throw Error(p$3(147, e)); var et = c, at = "" + e; return s !== null && s.ref !== null && typeof s.ref == "function" && s.ref._stringRef === at ? s.ref : (s = function (lt) { var ft = et.refs; ft === jh && (ft = et.refs = {}), lt === null ? delete ft[at] : ft[at] = lt }, s._stringRef = at, s) } if (typeof e != "string") throw Error(p$3(284)); if (!o._owner) throw Error(p$3(290, e)) } return e } function th$1(e, s) { throw e = Object.prototype.toString.call(s), Error(p$3(31, e === "[object Object]" ? "object with keys {" + Object.keys(s).join(", ") + "}" : e)) } function uh(e) { var s = e._init; return s(e._payload) } function vh$1(e) { function s(xt, Ct) { if (e) { var bt = xt.deletions; bt === null ? (xt.deletions = [Ct], xt.flags |= 16) : bt.push(Ct) } } function o(xt, Ct) { if (!e) return null; for (; Ct !== null;)s(xt, Ct), Ct = Ct.sibling; return null } function c(xt, Ct) { for (xt = new Map; Ct !== null;)Ct.key !== null ? xt.set(Ct.key, Ct) : xt.set(Ct.index, Ct), Ct = Ct.sibling; return xt } function et(xt, Ct) { return xt = wh(xt, Ct), xt.index = 0, xt.sibling = null, xt } function at(xt, Ct, bt) { return xt.index = bt, e ? (bt = xt.alternate, bt !== null ? (bt = bt.index, bt < Ct ? (xt.flags |= 2, Ct) : bt) : (xt.flags |= 2, Ct)) : (xt.flags |= 1048576, Ct) } function lt(xt) { return e && xt.alternate === null && (xt.flags |= 2), xt } function ft(xt, Ct, bt, Pt) { return Ct === null || Ct.tag !== 6 ? (Ct = xh(bt, xt.mode, Pt), Ct.return = xt, Ct) : (Ct = et(Ct, bt), Ct.return = xt, Ct) } function dt(xt, Ct, bt, Pt) { var Rt = bt.type; return Rt === ya$2 ? vt(xt, Ct, bt.props.children, Pt, bt.key) : Ct !== null && (Ct.elementType === Rt || typeof Rt == "object" && Rt !== null && Rt.$$typeof === Ha$1 && uh(Rt) === Ct.type) ? (Pt = et(Ct, bt.props), Pt.ref = sh$1(xt, Ct, bt), Pt.return = xt, Pt) : (Pt = yh(bt.type, bt.key, bt.props, null, xt.mode, Pt), Pt.ref = sh$1(xt, Ct, bt), Pt.return = xt, Pt) } function ht(xt, Ct, bt, Pt) { return Ct === null || Ct.tag !== 4 || Ct.stateNode.containerInfo !== bt.containerInfo || Ct.stateNode.implementation !== bt.implementation ? (Ct = zh(bt, xt.mode, Pt), Ct.return = xt, Ct) : (Ct = et(Ct, bt.children || []), Ct.return = xt, Ct) } function vt(xt, Ct, bt, Pt, Rt) { return Ct === null || Ct.tag !== 7 ? (Ct = Ah$1(bt, xt.mode, Pt, Rt), Ct.return = xt, Ct) : (Ct = et(Ct, bt), Ct.return = xt, Ct) } function wt(xt, Ct, bt) { if (typeof Ct == "string" && Ct !== "" || typeof Ct == "number") return Ct = xh("" + Ct, xt.mode, bt), Ct.return = xt, Ct; if (typeof Ct == "object" && Ct !== null) { switch (Ct.$$typeof) { case va$1: return bt = yh(Ct.type, Ct.key, Ct.props, null, xt.mode, bt), bt.ref = sh$1(xt, null, Ct), bt.return = xt, bt; case wa$2: return Ct = zh(Ct, xt.mode, bt), Ct.return = xt, Ct; case Ha$1: var Pt = Ct._init; return wt(xt, Pt(Ct._payload), bt) }if (eb$1(Ct) || Ka$1(Ct)) return Ct = Ah$1(Ct, xt.mode, bt, null), Ct.return = xt, Ct; th$1(xt, Ct) } return null } function St(xt, Ct, bt, Pt) { var Rt = Ct !== null ? Ct.key : null; if (typeof bt == "string" && bt !== "" || typeof bt == "number") return Rt !== null ? null : ft(xt, Ct, "" + bt, Pt); if (typeof bt == "object" && bt !== null) { switch (bt.$$typeof) { case va$1: return bt.key === Rt ? dt(xt, Ct, bt, Pt) : null; case wa$2: return bt.key === Rt ? ht(xt, Ct, bt, Pt) : null; case Ha$1: return Rt = bt._init, St(xt, Ct, Rt(bt._payload), Pt) }if (eb$1(bt) || Ka$1(bt)) return Rt !== null ? null : vt(xt, Ct, bt, Pt, null); th$1(xt, bt) } return null } function _t(xt, Ct, bt, Pt, Rt) { if (typeof Pt == "string" && Pt !== "" || typeof Pt == "number") return xt = xt.get(bt) || null, ft(Ct, xt, "" + Pt, Rt); if (typeof Pt == "object" && Pt !== null) { switch (Pt.$$typeof) { case va$1: return xt = xt.get(Pt.key === null ? bt : Pt.key) || null, dt(Ct, xt, Pt, Rt); case wa$2: return xt = xt.get(Pt.key === null ? bt : Pt.key) || null, ht(Ct, xt, Pt, Rt); case Ha$1: var Jn = Pt._init; return _t(xt, Ct, bt, Jn(Pt._payload), Rt) }if (eb$1(Pt) || Ka$1(Pt)) return xt = xt.get(bt) || null, vt(Ct, xt, Pt, Rt, null); th$1(Ct, Pt) } return null } function Nt(xt, Ct, bt, Pt) { for (var Rt = null, Jn = null, er = Ct, Zt = Ct = 0, lr = null; er !== null && Zt < bt.length; Zt++) { er.index > Zt ? (lr = er, er = null) : lr = er.sibling; var tr = St(xt, er, bt[Zt], Pt); if (tr === null) { er === null && (er = lr); break } e && er && tr.alternate === null && s(xt, er), Ct = at(tr, Ct, Zt), Jn === null ? Rt = tr : Jn.sibling = tr, Jn = tr, er = lr } if (Zt === bt.length) return o(xt, er), I$2 && tg(xt, Zt), Rt; if (er === null) { for (; Zt < bt.length; Zt++)er = wt(xt, bt[Zt], Pt), er !== null && (Ct = at(er, Ct, Zt), Jn === null ? Rt = er : Jn.sibling = er, Jn = er); return I$2 && tg(xt, Zt), Rt } for (er = c(xt, er); Zt < bt.length; Zt++)lr = _t(er, xt, Zt, bt[Zt], Pt), lr !== null && (e && lr.alternate !== null && er.delete(lr.key === null ? Zt : lr.key), Ct = at(lr, Ct, Zt), Jn === null ? Rt = lr : Jn.sibling = lr, Jn = lr); return e && er.forEach(function (xn) { return s(xt, xn) }), I$2 && tg(xt, Zt), Rt } function kt(xt, Ct, bt, Pt) { var Rt = Ka$1(bt); if (typeof Rt != "function") throw Error(p$3(150)); if (bt = Rt.call(bt), bt == null) throw Error(p$3(151)); for (var Jn = Rt = null, er = Ct, Zt = Ct = 0, lr = null, tr = bt.next(); er !== null && !tr.done; Zt++, tr = bt.next()) { er.index > Zt ? (lr = er, er = null) : lr = er.sibling; var xn = St(xt, er, tr.value, Pt); if (xn === null) { er === null && (er = lr); break } e && er && xn.alternate === null && s(xt, er), Ct = at(xn, Ct, Zt), Jn === null ? Rt = xn : Jn.sibling = xn, Jn = xn, er = lr } if (tr.done) return o(xt, er), I$2 && tg(xt, Zt), Rt; if (er === null) { for (; !tr.done; Zt++, tr = bt.next())tr = wt(xt, tr.value, Pt), tr !== null && (Ct = at(tr, Ct, Zt), Jn === null ? Rt = tr : Jn.sibling = tr, Jn = tr); return I$2 && tg(xt, Zt), Rt } for (er = c(xt, er); !tr.done; Zt++, tr = bt.next())tr = _t(er, xt, Zt, tr.value, Pt), tr !== null && (e && tr.alternate !== null && er.delete(tr.key === null ? Zt : tr.key), Ct = at(tr, Ct, Zt), Jn === null ? Rt = tr : Jn.sibling = tr, Jn = tr); return e && er.forEach(function (jt) { return s(xt, jt) }), I$2 && tg(xt, Zt), Rt } function Dt(xt, Ct, bt, Pt) { if (typeof bt == "object" && bt !== null && bt.type === ya$2 && bt.key === null && (bt = bt.props.children), typeof bt == "object" && bt !== null) { switch (bt.$$typeof) { case va$1: e: { for (var Rt = bt.key, Jn = Ct; Jn !== null;) { if (Jn.key === Rt) { if (Rt = bt.type, Rt === ya$2) { if (Jn.tag === 7) { o(xt, Jn.sibling), Ct = et(Jn, bt.props.children), Ct.return = xt, xt = Ct; break e } } else if (Jn.elementType === Rt || typeof Rt == "object" && Rt !== null && Rt.$$typeof === Ha$1 && uh(Rt) === Jn.type) { o(xt, Jn.sibling), Ct = et(Jn, bt.props), Ct.ref = sh$1(xt, Jn, bt), Ct.return = xt, xt = Ct; break e } o(xt, Jn); break } else s(xt, Jn); Jn = Jn.sibling } bt.type === ya$2 ? (Ct = Ah$1(bt.props.children, xt.mode, Pt, bt.key), Ct.return = xt, xt = Ct) : (Pt = yh(bt.type, bt.key, bt.props, null, xt.mode, Pt), Pt.ref = sh$1(xt, Ct, bt), Pt.return = xt, xt = Pt) } return lt(xt); case wa$2: e: { for (Jn = bt.key; Ct !== null;) { if (Ct.key === Jn) if (Ct.tag === 4 && Ct.stateNode.containerInfo === bt.containerInfo && Ct.stateNode.implementation === bt.implementation) { o(xt, Ct.sibling), Ct = et(Ct, bt.children || []), Ct.return = xt, xt = Ct; break e } else { o(xt, Ct); break } else s(xt, Ct); Ct = Ct.sibling } Ct = zh(bt, xt.mode, Pt), Ct.return = xt, xt = Ct } return lt(xt); case Ha$1: return Jn = bt._init, Dt(xt, Ct, Jn(bt._payload), Pt) }if (eb$1(bt)) return Nt(xt, Ct, bt, Pt); if (Ka$1(bt)) return kt(xt, Ct, bt, Pt); th$1(xt, bt) } return typeof bt == "string" && bt !== "" || typeof bt == "number" ? (bt = "" + bt, Ct !== null && Ct.tag === 6 ? (o(xt, Ct.sibling), Ct = et(Ct, bt), Ct.return = xt, xt = Ct) : (o(xt, Ct), Ct = xh(bt, xt.mode, Pt), Ct.return = xt, xt = Ct), lt(xt)) : o(xt, Ct) } return Dt } var Bh = vh$1(!0), Ch = vh$1(!1), Dh$1 = {}, Eh$1 = Uf(Dh$1), Fh = Uf(Dh$1), Gh = Uf(Dh$1); function Hh(e) { if (e === Dh$1) throw Error(p$3(174)); return e } function Ih(e, s) { switch (G$2(Gh, s), G$2(Fh, e), G$2(Eh$1, Dh$1), e = s.nodeType, e) { case 9: case 11: s = (s = s.documentElement) ? s.namespaceURI : lb$1(null, ""); break; default: e = e === 8 ? s.parentNode : s, s = e.namespaceURI || null, e = e.tagName, s = lb$1(s, e) }E$2(Eh$1), G$2(Eh$1, s) } function Jh() { E$2(Eh$1), E$2(Fh), E$2(Gh) } function Kh(e) { Hh(Gh.current); var s = Hh(Eh$1.current), o = lb$1(s, e.type); s !== o && (G$2(Fh, e), G$2(Eh$1, o)) } function Lh(e) { Fh.current === e && (E$2(Eh$1), E$2(Fh)) } var M$3 = Uf(0); function Mh(e) { for (var s = e; s !== null;) { if (s.tag === 13) { var o = s.memoizedState; if (o !== null && (o = o.dehydrated, o === null || o.data === "$?" || o.data === "$!")) return s } else if (s.tag === 19 && s.memoizedProps.revealOrder !== void 0) { if ((s.flags & 128) !== 0) return s } else if (s.child !== null) { s.child.return = s, s = s.child; continue } if (s === e) break; for (; s.sibling === null;) { if (s.return === null || s.return === e) return null; s = s.return } s.sibling.return = s.return, s = s.sibling } return null } var Nh = []; function Oh() { for (var e = 0; e < Nh.length; e++)Nh[e]._workInProgressVersionPrimary = null; Nh.length = 0 } var Ph$1 = ua$1.ReactCurrentDispatcher, Qh = ua$1.ReactCurrentBatchConfig, Rh$1 = 0, N$3 = null, O$3 = null, P$3 = null, Sh$1 = !1, Th = !1, Uh = 0, Vh$1 = 0; function Q$3() { throw Error(p$3(321)) } function Wh(e, s) { if (s === null) return !1; for (var o = 0; o < s.length && o < e.length; o++)if (!He$1(e[o], s[o])) return !1; return !0 } function Xh(e, s, o, c, et, at) { if (Rh$1 = at, N$3 = s, s.memoizedState = null, s.updateQueue = null, s.lanes = 0, Ph$1.current = e === null || e.memoizedState === null ? Yh : Zh, e = o(c, et), Th) { at = 0; do { if (Th = !1, Uh = 0, 25 <= at) throw Error(p$3(301)); at += 1, P$3 = O$3 = null, s.updateQueue = null, Ph$1.current = $h, e = o(c, et) } while (Th) } if (Ph$1.current = ai, s = O$3 !== null && O$3.next !== null, Rh$1 = 0, P$3 = O$3 = N$3 = null, Sh$1 = !1, s) throw Error(p$3(300)); return e } function bi() { var e = Uh !== 0; return Uh = 0, e } function ci() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return P$3 === null ? N$3.memoizedState = P$3 = e : P$3 = P$3.next = e, P$3 } function di() { if (O$3 === null) { var e = N$3.alternate; e = e !== null ? e.memoizedState : null } else e = O$3.next; var s = P$3 === null ? N$3.memoizedState : P$3.next; if (s !== null) P$3 = s, O$3 = e; else { if (e === null) throw Error(p$3(310)); O$3 = e, e = { memoizedState: O$3.memoizedState, baseState: O$3.baseState, baseQueue: O$3.baseQueue, queue: O$3.queue, next: null }, P$3 === null ? N$3.memoizedState = P$3 = e : P$3 = P$3.next = e } return P$3 } function ei$1(e, s) { return typeof s == "function" ? s(e) : s } function fi(e) { var s = di(), o = s.queue; if (o === null) throw Error(p$3(311)); o.lastRenderedReducer = e; var c = O$3, et = c.baseQueue, at = o.pending; if (at !== null) { if (et !== null) { var lt = et.next; et.next = at.next, at.next = lt } c.baseQueue = et = at, o.pending = null } if (et !== null) { at = et.next, c = c.baseState; var ft = lt = null, dt = null, ht = at; do { var vt = ht.lane; if ((Rh$1 & vt) === vt) dt !== null && (dt = dt.next = { lane: 0, action: ht.action, hasEagerState: ht.hasEagerState, eagerState: ht.eagerState, next: null }), c = ht.hasEagerState ? ht.eagerState : e(c, ht.action); else { var wt = { lane: vt, action: ht.action, hasEagerState: ht.hasEagerState, eagerState: ht.eagerState, next: null }; dt === null ? (ft = dt = wt, lt = c) : dt = dt.next = wt, N$3.lanes |= vt, hh$1 |= vt } ht = ht.next } while (ht !== null && ht !== at); dt === null ? lt = c : dt.next = ft, He$1(c, s.memoizedState) || (Ug = !0), s.memoizedState = c, s.baseState = lt, s.baseQueue = dt, o.lastRenderedState = c } if (e = o.interleaved, e !== null) { et = e; do at = et.lane, N$3.lanes |= at, hh$1 |= at, et = et.next; while (et !== e) } else et === null && (o.lanes = 0); return [s.memoizedState, o.dispatch] } function gi(e) { var s = di(), o = s.queue; if (o === null) throw Error(p$3(311)); o.lastRenderedReducer = e; var c = o.dispatch, et = o.pending, at = s.memoizedState; if (et !== null) { o.pending = null; var lt = et = et.next; do at = e(at, lt.action), lt = lt.next; while (lt !== et); He$1(at, s.memoizedState) || (Ug = !0), s.memoizedState = at, s.baseQueue === null && (s.baseState = at), o.lastRenderedState = at } return [at, c] } function hi() { } function ii$1(e, s) { var o = N$3, c = di(), et = s(), at = !He$1(c.memoizedState, et); if (at && (c.memoizedState = et, Ug = !0), c = c.queue, ji(ki$1.bind(null, o, c, e), [e]), c.getSnapshot !== s || at || P$3 !== null && P$3.memoizedState.tag & 1) { if (o.flags |= 2048, li(9, mi.bind(null, o, c, et, s), void 0, null), R$2 === null) throw Error(p$3(349)); (Rh$1 & 30) !== 0 || ni$1(o, s, et) } return et } function ni$1(e, s, o) { e.flags |= 16384, e = { getSnapshot: s, value: o }, s = N$3.updateQueue, s === null ? (s = { lastEffect: null, stores: null }, N$3.updateQueue = s, s.stores = [e]) : (o = s.stores, o === null ? s.stores = [e] : o.push(e)) } function mi(e, s, o, c) { s.value = o, s.getSnapshot = c, oi(s) && pi(e) } function ki$1(e, s, o) { return o(function () { oi(s) && pi(e) }) } function oi(e) { var s = e.getSnapshot; e = e.value; try { var o = s(); return !He$1(e, o) } catch { return !0 } } function pi(e) { var s = Zg(e, 1); s !== null && mh(s, e, 1, -1) } function qi(e) { var s = ci(); return typeof e == "function" && (e = e()), s.memoizedState = s.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei$1, lastRenderedState: e }, s.queue = e, e = e.dispatch = ri.bind(null, N$3, e), [s.memoizedState, e] } function li(e, s, o, c) { return e = { tag: e, create: s, destroy: o, deps: c, next: null }, s = N$3.updateQueue, s === null ? (s = { lastEffect: null, stores: null }, N$3.updateQueue = s, s.lastEffect = e.next = e) : (o = s.lastEffect, o === null ? s.lastEffect = e.next = e : (c = o.next, o.next = e, e.next = c, s.lastEffect = e)), e } function si$1() { return di().memoizedState } function ti$1(e, s, o, c) { var et = ci(); N$3.flags |= e, et.memoizedState = li(1 | s, o, void 0, c === void 0 ? null : c) } function ui(e, s, o, c) { var et = di(); c = c === void 0 ? null : c; var at = void 0; if (O$3 !== null) { var lt = O$3.memoizedState; if (at = lt.destroy, c !== null && Wh(c, lt.deps)) { et.memoizedState = li(s, o, at, c); return } } N$3.flags |= e, et.memoizedState = li(1 | s, o, at, c) } function vi(e, s) { return ti$1(8390656, 8, e, s) } function ji(e, s) { return ui(2048, 8, e, s) } function wi(e, s) { return ui(4, 2, e, s) } function xi(e, s) { return ui(4, 4, e, s) } function yi(e, s) { if (typeof s == "function") return e = e(), s(e), function () { s(null) }; if (s != null) return e = e(), s.current = e, function () { s.current = null } } function zi(e, s, o) { return o = o != null ? o.concat([e]) : null, ui(4, 4, yi.bind(null, s, e), o) } function Ai() { } function Bi(e, s) { var o = di(); s = s === void 0 ? null : s; var c = o.memoizedState; return c !== null && s !== null && Wh(s, c[1]) ? c[0] : (o.memoizedState = [e, s], e) } function Ci(e, s) { var o = di(); s = s === void 0 ? null : s; var c = o.memoizedState; return c !== null && s !== null && Wh(s, c[1]) ? c[0] : (e = e(), o.memoizedState = [e, s], e) } function Di(e, s, o) { return (Rh$1 & 21) === 0 ? (e.baseState && (e.baseState = !1, Ug = !0), e.memoizedState = o) : (He$1(o, s) || (o = yc$1(), N$3.lanes |= o, hh$1 |= o, e.baseState = !0), s) } function Ei(e, s) { var o = C$3; C$3 = o !== 0 && 4 > o ? o : 4, e(!0); var c = Qh.transition; Qh.transition = {}; try { e(!1), s() } finally { C$3 = o, Qh.transition = c } } function Fi() { return di().memoizedState } function Gi(e, s, o) { var c = lh$1(e); if (o = { lane: c, action: o, hasEagerState: !1, eagerState: null, next: null }, Hi(e)) Ii(s, o); else if (o = Yg(e, s, o, c), o !== null) { var et = L$3(); mh(o, e, c, et), Ji(o, s, c) } } function ri(e, s, o) { var c = lh$1(e), et = { lane: c, action: o, hasEagerState: !1, eagerState: null, next: null }; if (Hi(e)) Ii(s, et); else { var at = e.alternate; if (e.lanes === 0 && (at === null || at.lanes === 0) && (at = s.lastRenderedReducer, at !== null)) try { var lt = s.lastRenderedState, ft = at(lt, o); if (et.hasEagerState = !0, et.eagerState = ft, He$1(ft, lt)) { var dt = s.interleaved; dt === null ? (et.next = et, Xg(s)) : (et.next = dt.next, dt.next = et), s.interleaved = et; return } } catch { } finally { } o = Yg(e, s, et, c), o !== null && (et = L$3(), mh(o, e, c, et), Ji(o, s, c)) } } function Hi(e) { var s = e.alternate; return e === N$3 || s !== null && s === N$3 } function Ii(e, s) { Th = Sh$1 = !0; var o = e.pending; o === null ? s.next = s : (s.next = o.next, o.next = s), e.pending = s } function Ji(e, s, o) { if ((o & 4194240) !== 0) { var c = s.lanes; c &= e.pendingLanes, o |= c, s.lanes = o, Cc$1(e, o) } } var ai = { readContext: Vg, useCallback: Q$3, useContext: Q$3, useEffect: Q$3, useImperativeHandle: Q$3, useInsertionEffect: Q$3, useLayoutEffect: Q$3, useMemo: Q$3, useReducer: Q$3, useRef: Q$3, useState: Q$3, useDebugValue: Q$3, useDeferredValue: Q$3, useTransition: Q$3, useMutableSource: Q$3, useSyncExternalStore: Q$3, useId: Q$3, unstable_isNewReconciler: !1 }, Yh = { readContext: Vg, useCallback: function (e, s) { return ci().memoizedState = [e, s === void 0 ? null : s], e }, useContext: Vg, useEffect: vi, useImperativeHandle: function (e, s, o) { return o = o != null ? o.concat([e]) : null, ti$1(4194308, 4, yi.bind(null, s, e), o) }, useLayoutEffect: function (e, s) { return ti$1(4194308, 4, e, s) }, useInsertionEffect: function (e, s) { return ti$1(4, 2, e, s) }, useMemo: function (e, s) { var o = ci(); return s = s === void 0 ? null : s, e = e(), o.memoizedState = [e, s], e }, useReducer: function (e, s, o) { var c = ci(); return s = o !== void 0 ? o(s) : s, c.memoizedState = c.baseState = s, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: s }, c.queue = e, e = e.dispatch = Gi.bind(null, N$3, e), [c.memoizedState, e] }, useRef: function (e) { var s = ci(); return e = { current: e }, s.memoizedState = e }, useState: qi, useDebugValue: Ai, useDeferredValue: function (e) { return ci().memoizedState = e }, useTransition: function () { var e = qi(!1), s = e[0]; return e = Ei.bind(null, e[1]), ci().memoizedState = e, [s, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, s, o) { var c = N$3, et = ci(); if (I$2) { if (o === void 0) throw Error(p$3(407)); o = o() } else { if (o = s(), R$2 === null) throw Error(p$3(349)); (Rh$1 & 30) !== 0 || ni$1(c, s, o) } et.memoizedState = o; var at = { value: o, getSnapshot: s }; return et.queue = at, vi(ki$1.bind(null, c, at, e), [e]), c.flags |= 2048, li(9, mi.bind(null, c, at, o, s), void 0, null), o }, useId: function () { var e = ci(), s = R$2.identifierPrefix; if (I$2) { var o = sg, c = rg; o = (c & ~(1 << 32 - oc$1(c) - 1)).toString(32) + o, s = ":" + s + "R" + o, o = Uh++, 0 < o && (s += "H" + o.toString(32)), s += ":" } else o = Vh$1++, s = ":" + s + "r" + o.toString(32) + ":"; return e.memoizedState = s }, unstable_isNewReconciler: !1 }, Zh = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: fi, useRef: si$1, useState: function () { return fi(ei$1) }, useDebugValue: Ai, useDeferredValue: function (e) { var s = di(); return Di(s, O$3.memoizedState, e) }, useTransition: function () { var e = fi(ei$1)[0], s = di().memoizedState; return [e, s] }, useMutableSource: hi, useSyncExternalStore: ii$1, useId: Fi, unstable_isNewReconciler: !1 }, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si$1, useState: function () { return gi(ei$1) }, useDebugValue: Ai, useDeferredValue: function (e) { var s = di(); return O$3 === null ? s.memoizedState = e : Di(s, O$3.memoizedState, e) }, useTransition: function () { var e = gi(ei$1)[0], s = di().memoizedState; return [e, s] }, useMutableSource: hi, useSyncExternalStore: ii$1, useId: Fi, unstable_isNewReconciler: !1 }; function Ki(e, s) {
	try { var o = "", c = s; do o += Pa$1(c), c = c.return; while (c); var et = o } catch (at) {
		et = `
Error generating stack: `+ at.message + `
`+ at.stack
	} return { value: e, source: s, stack: et, digest: null }
} function Li(e, s, o) { return { value: e, source: null, stack: o != null ? o : null, digest: s != null ? s : null } } function Mi$1(e, s) { try { console.error(s.value) } catch (o) { setTimeout(function () { throw o }) } } var Ni = typeof WeakMap == "function" ? WeakMap : Map; function Oi$1(e, s, o) { o = ch$1(-1, o), o.tag = 3, o.payload = { element: null }; var c = s.value; return o.callback = function () { Pi || (Pi = !0, Qi = c), Mi$1(e, s) }, o } function Ri(e, s, o) { o = ch$1(-1, o), o.tag = 3; var c = e.type.getDerivedStateFromError; if (typeof c == "function") { var et = s.value; o.payload = function () { return c(et) }, o.callback = function () { Mi$1(e, s) } } var at = e.stateNode; return at !== null && typeof at.componentDidCatch == "function" && (o.callback = function () { Mi$1(e, s), typeof c != "function" && (Si === null ? Si = new Set([this]) : Si.add(this)); var lt = s.stack; this.componentDidCatch(s.value, { componentStack: lt !== null ? lt : "" }) }), o } function Ti(e, s, o) { var c = e.pingCache; if (c === null) { c = e.pingCache = new Ni; var et = new Set; c.set(s, et) } else et = c.get(s), et === void 0 && (et = new Set, c.set(s, et)); et.has(o) || (et.add(o), e = Ui.bind(null, e, s, o), s.then(e, e)) } function Vi(e) { do { var s; if ((s = e.tag === 13) && (s = e.memoizedState, s = s !== null ? s.dehydrated !== null : !0), s) return e; e = e.return } while (e !== null); return null } function Wi$1(e, s, o, c, et) { return (e.mode & 1) === 0 ? (e === s ? e.flags |= 65536 : (e.flags |= 128, o.flags |= 131072, o.flags &= -52805, o.tag === 1 && (o.alternate === null ? o.tag = 17 : (s = ch$1(-1, 1), s.tag = 2, dh(o, s, 1))), o.lanes |= 1), e) : (e.flags |= 65536, e.lanes = et, e) } var Xi = ua$1.ReactCurrentOwner, Ug = !1; function Yi(e, s, o, c) { s.child = e === null ? Ch(s, null, o, c) : Bh(s, e.child, o, c) } function Zi(e, s, o, c, et) { o = o.render; var at = s.ref; return Tg(s, et), c = Xh(e, s, o, c, at, et), o = bi(), e !== null && !Ug ? (s.updateQueue = e.updateQueue, s.flags &= -2053, e.lanes &= ~et, $i$1(e, s, et)) : (I$2 && o && vg(s), s.flags |= 1, Yi(e, s, c, et), s.child) } function aj(e, s, o, c, et) { if (e === null) { var at = o.type; return typeof at == "function" && !bj(at) && at.defaultProps === void 0 && o.compare === null && o.defaultProps === void 0 ? (s.tag = 15, s.type = at, cj(e, s, at, c, et)) : (e = yh(o.type, null, c, s, s.mode, et), e.ref = s.ref, e.return = s, s.child = e) } if (at = e.child, (e.lanes & et) === 0) { var lt = at.memoizedProps; if (o = o.compare, o = o !== null ? o : Ie$1, o(lt, c) && e.ref === s.ref) return $i$1(e, s, et) } return s.flags |= 1, e = wh(at, c), e.ref = s.ref, e.return = s, s.child = e } function cj(e, s, o, c, et) { if (e !== null) { var at = e.memoizedProps; if (Ie$1(at, c) && e.ref === s.ref) if (Ug = !1, s.pendingProps = c = at, (e.lanes & et) !== 0) (e.flags & 131072) !== 0 && (Ug = !0); else return s.lanes = e.lanes, $i$1(e, s, et) } return dj(e, s, o, c, et) } function ej(e, s, o) { var c = s.pendingProps, et = c.children, at = e !== null ? e.memoizedState : null; if (c.mode === "hidden") if ((s.mode & 1) === 0) s.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$2(fj, gj), gj |= o; else { if ((o & 1073741824) === 0) return e = at !== null ? at.baseLanes | o : o, s.lanes = s.childLanes = 1073741824, s.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, s.updateQueue = null, G$2(fj, gj), gj |= e, null; s.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, c = at !== null ? at.baseLanes : o, G$2(fj, gj), gj |= c } else at !== null ? (c = at.baseLanes | o, s.memoizedState = null) : c = o, G$2(fj, gj), gj |= c; return Yi(e, s, et, o), s.child } function hj(e, s) { var o = s.ref; (e === null && o !== null || e !== null && e.ref !== o) && (s.flags |= 512, s.flags |= 2097152) } function dj(e, s, o, c, et) { var at = Zf(o) ? Xf : H$3.current; return at = Yf(s, at), Tg(s, et), o = Xh(e, s, o, c, at, et), c = bi(), e !== null && !Ug ? (s.updateQueue = e.updateQueue, s.flags &= -2053, e.lanes &= ~et, $i$1(e, s, et)) : (I$2 && c && vg(s), s.flags |= 1, Yi(e, s, o, et), s.child) } function ij(e, s, o, c, et) { if (Zf(o)) { var at = !0; cg(s) } else at = !1; if (Tg(s, et), s.stateNode === null) jj(e, s), ph(s, o, c), rh$1(s, o, c, et), c = !0; else if (e === null) { var lt = s.stateNode, ft = s.memoizedProps; lt.props = ft; var dt = lt.context, ht = o.contextType; typeof ht == "object" && ht !== null ? ht = Vg(ht) : (ht = Zf(o) ? Xf : H$3.current, ht = Yf(s, ht)); var vt = o.getDerivedStateFromProps, wt = typeof vt == "function" || typeof lt.getSnapshotBeforeUpdate == "function"; wt || typeof lt.UNSAFE_componentWillReceiveProps != "function" && typeof lt.componentWillReceiveProps != "function" || (ft !== c || dt !== ht) && qh(s, lt, c, ht), $g = !1; var St = s.memoizedState; lt.state = St, gh(s, c, lt, et), dt = s.memoizedState, ft !== c || St !== dt || Wf.current || $g ? (typeof vt == "function" && (kh(s, o, vt, c), dt = s.memoizedState), (ft = $g || oh$1(s, o, ft, c, St, dt, ht)) ? (wt || typeof lt.UNSAFE_componentWillMount != "function" && typeof lt.componentWillMount != "function" || (typeof lt.componentWillMount == "function" && lt.componentWillMount(), typeof lt.UNSAFE_componentWillMount == "function" && lt.UNSAFE_componentWillMount()), typeof lt.componentDidMount == "function" && (s.flags |= 4194308)) : (typeof lt.componentDidMount == "function" && (s.flags |= 4194308), s.memoizedProps = c, s.memoizedState = dt), lt.props = c, lt.state = dt, lt.context = ht, c = ft) : (typeof lt.componentDidMount == "function" && (s.flags |= 4194308), c = !1) } else { lt = s.stateNode, bh$1(e, s), ft = s.memoizedProps, ht = s.type === s.elementType ? ft : Lg(s.type, ft), lt.props = ht, wt = s.pendingProps, St = lt.context, dt = o.contextType, typeof dt == "object" && dt !== null ? dt = Vg(dt) : (dt = Zf(o) ? Xf : H$3.current, dt = Yf(s, dt)); var _t = o.getDerivedStateFromProps; (vt = typeof _t == "function" || typeof lt.getSnapshotBeforeUpdate == "function") || typeof lt.UNSAFE_componentWillReceiveProps != "function" && typeof lt.componentWillReceiveProps != "function" || (ft !== wt || St !== dt) && qh(s, lt, c, dt), $g = !1, St = s.memoizedState, lt.state = St, gh(s, c, lt, et); var Nt = s.memoizedState; ft !== wt || St !== Nt || Wf.current || $g ? (typeof _t == "function" && (kh(s, o, _t, c), Nt = s.memoizedState), (ht = $g || oh$1(s, o, ht, c, St, Nt, dt) || !1) ? (vt || typeof lt.UNSAFE_componentWillUpdate != "function" && typeof lt.componentWillUpdate != "function" || (typeof lt.componentWillUpdate == "function" && lt.componentWillUpdate(c, Nt, dt), typeof lt.UNSAFE_componentWillUpdate == "function" && lt.UNSAFE_componentWillUpdate(c, Nt, dt)), typeof lt.componentDidUpdate == "function" && (s.flags |= 4), typeof lt.getSnapshotBeforeUpdate == "function" && (s.flags |= 1024)) : (typeof lt.componentDidUpdate != "function" || ft === e.memoizedProps && St === e.memoizedState || (s.flags |= 4), typeof lt.getSnapshotBeforeUpdate != "function" || ft === e.memoizedProps && St === e.memoizedState || (s.flags |= 1024), s.memoizedProps = c, s.memoizedState = Nt), lt.props = c, lt.state = Nt, lt.context = dt, c = ht) : (typeof lt.componentDidUpdate != "function" || ft === e.memoizedProps && St === e.memoizedState || (s.flags |= 4), typeof lt.getSnapshotBeforeUpdate != "function" || ft === e.memoizedProps && St === e.memoizedState || (s.flags |= 1024), c = !1) } return kj(e, s, o, c, at, et) } function kj(e, s, o, c, et, at) { hj(e, s); var lt = (s.flags & 128) !== 0; if (!c && !lt) return et && dg(s, o, !1), $i$1(e, s, at); c = s.stateNode, Xi.current = s; var ft = lt && typeof o.getDerivedStateFromError != "function" ? null : c.render(); return s.flags |= 1, e !== null && lt ? (s.child = Bh(s, e.child, null, at), s.child = Bh(s, null, ft, at)) : Yi(e, s, ft, at), s.memoizedState = c.state, et && dg(s, o, !0), s.child } function lj(e) { var s = e.stateNode; s.pendingContext ? ag(e, s.pendingContext, s.pendingContext !== s.context) : s.context && ag(e, s.context, !1), Ih(e, s.containerInfo) } function mj(e, s, o, c, et) { return Ig(), Jg(et), s.flags |= 256, Yi(e, s, o, c), s.child } var nj = { dehydrated: null, treeContext: null, retryLane: 0 }; function oj(e) { return { baseLanes: e, cachePool: null, transitions: null } } function pj(e, s, o) { var c = s.pendingProps, et = M$3.current, at = !1, lt = (s.flags & 128) !== 0, ft; if ((ft = lt) || (ft = e !== null && e.memoizedState === null ? !1 : (et & 2) !== 0), ft ? (at = !0, s.flags &= -129) : (e === null || e.memoizedState !== null) && (et |= 1), G$2(M$3, et & 1), e === null) return Eg(s), e = s.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? ((s.mode & 1) === 0 ? s.lanes = 1 : e.data === "$!" ? s.lanes = 8 : s.lanes = 1073741824, null) : (lt = c.children, e = c.fallback, at ? (c = s.mode, at = s.child, lt = { mode: "hidden", children: lt }, (c & 1) === 0 && at !== null ? (at.childLanes = 0, at.pendingProps = lt) : at = qj(lt, c, 0, null), e = Ah$1(e, c, o, null), at.return = s, e.return = s, at.sibling = e, s.child = at, s.child.memoizedState = oj(o), s.memoizedState = nj, e) : rj(s, lt)); if (et = e.memoizedState, et !== null && (ft = et.dehydrated, ft !== null)) return sj(e, s, lt, c, ft, et, o); if (at) { at = c.fallback, lt = s.mode, et = e.child, ft = et.sibling; var dt = { mode: "hidden", children: c.children }; return (lt & 1) === 0 && s.child !== et ? (c = s.child, c.childLanes = 0, c.pendingProps = dt, s.deletions = null) : (c = wh(et, dt), c.subtreeFlags = et.subtreeFlags & 14680064), ft !== null ? at = wh(ft, at) : (at = Ah$1(at, lt, o, null), at.flags |= 2), at.return = s, c.return = s, c.sibling = at, s.child = c, c = at, at = s.child, lt = e.child.memoizedState, lt = lt === null ? oj(o) : { baseLanes: lt.baseLanes | o, cachePool: null, transitions: lt.transitions }, at.memoizedState = lt, at.childLanes = e.childLanes & ~o, s.memoizedState = nj, c } return at = e.child, e = at.sibling, c = wh(at, { mode: "visible", children: c.children }), (s.mode & 1) === 0 && (c.lanes = o), c.return = s, c.sibling = null, e !== null && (o = s.deletions, o === null ? (s.deletions = [e], s.flags |= 16) : o.push(e)), s.child = c, s.memoizedState = null, c } function rj(e, s) { return s = qj({ mode: "visible", children: s }, e.mode, 0, null), s.return = e, e.child = s } function tj(e, s, o, c) { return c !== null && Jg(c), Bh(s, e.child, null, o), e = rj(s, s.pendingProps.children), e.flags |= 2, s.memoizedState = null, e } function sj(e, s, o, c, et, at, lt) { if (o) return s.flags & 256 ? (s.flags &= -257, c = Li(Error(p$3(422))), tj(e, s, lt, c)) : s.memoizedState !== null ? (s.child = e.child, s.flags |= 128, null) : (at = c.fallback, et = s.mode, c = qj({ mode: "visible", children: c.children }, et, 0, null), at = Ah$1(at, et, lt, null), at.flags |= 2, c.return = s, at.return = s, c.sibling = at, s.child = c, (s.mode & 1) !== 0 && Bh(s, e.child, null, lt), s.child.memoizedState = oj(lt), s.memoizedState = nj, at); if ((s.mode & 1) === 0) return tj(e, s, lt, null); if (et.data === "$!") { if (c = et.nextSibling && et.nextSibling.dataset, c) var ft = c.dgst; return c = ft, at = Error(p$3(419)), c = Li(at, c, void 0), tj(e, s, lt, c) } if (ft = (lt & e.childLanes) !== 0, Ug || ft) { if (c = R$2, c !== null) { switch (lt & -lt) { case 4: et = 2; break; case 16: et = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: et = 32; break; case 536870912: et = 268435456; break; default: et = 0 }et = (et & (c.suspendedLanes | lt)) !== 0 ? 0 : et, et !== 0 && et !== at.retryLane && (at.retryLane = et, Zg(e, et), mh(c, e, et, -1)) } return uj(), c = Li(Error(p$3(421))), tj(e, s, lt, c) } return et.data === "$?" ? (s.flags |= 128, s.child = e.child, s = vj.bind(null, e), et._reactRetry = s, null) : (e = at.treeContext, yg = Lf(et.nextSibling), xg = s, I$2 = !0, zg = null, e !== null && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = e.id, sg = e.overflow, qg = s), s = rj(s, c.children), s.flags |= 4096, s) } function wj(e, s, o) { e.lanes |= s; var c = e.alternate; c !== null && (c.lanes |= s), Sg(e.return, s, o) } function xj(e, s, o, c, et) { var at = e.memoizedState; at === null ? e.memoizedState = { isBackwards: s, rendering: null, renderingStartTime: 0, last: c, tail: o, tailMode: et } : (at.isBackwards = s, at.rendering = null, at.renderingStartTime = 0, at.last = c, at.tail = o, at.tailMode = et) } function yj(e, s, o) { var c = s.pendingProps, et = c.revealOrder, at = c.tail; if (Yi(e, s, c.children, o), c = M$3.current, (c & 2) !== 0) c = c & 1 | 2, s.flags |= 128; else { if (e !== null && (e.flags & 128) !== 0) e: for (e = s.child; e !== null;) { if (e.tag === 13) e.memoizedState !== null && wj(e, o, s); else if (e.tag === 19) wj(e, o, s); else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === s) break e; for (; e.sibling === null;) { if (e.return === null || e.return === s) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } c &= 1 } if (G$2(M$3, c), (s.mode & 1) === 0) s.memoizedState = null; else switch (et) { case "forwards": for (o = s.child, et = null; o !== null;)e = o.alternate, e !== null && Mh(e) === null && (et = o), o = o.sibling; o = et, o === null ? (et = s.child, s.child = null) : (et = o.sibling, o.sibling = null), xj(s, !1, et, o, at); break; case "backwards": for (o = null, et = s.child, s.child = null; et !== null;) { if (e = et.alternate, e !== null && Mh(e) === null) { s.child = et; break } e = et.sibling, et.sibling = o, o = et, et = e } xj(s, !0, o, null, at); break; case "together": xj(s, !1, null, null, void 0); break; default: s.memoizedState = null }return s.child } function jj(e, s) { (s.mode & 1) === 0 && e !== null && (e.alternate = null, s.alternate = null, s.flags |= 2) } function $i$1(e, s, o) { if (e !== null && (s.dependencies = e.dependencies), hh$1 |= s.lanes, (o & s.childLanes) === 0) return null; if (e !== null && s.child !== e.child) throw Error(p$3(153)); if (s.child !== null) { for (e = s.child, o = wh(e, e.pendingProps), s.child = o, o.return = s; e.sibling !== null;)e = e.sibling, o = o.sibling = wh(e, e.pendingProps), o.return = s; o.sibling = null } return s.child } function zj(e, s, o) { switch (s.tag) { case 3: lj(s), Ig(); break; case 5: Kh(s); break; case 1: Zf(s.type) && cg(s); break; case 4: Ih(s, s.stateNode.containerInfo); break; case 10: var c = s.type._context, et = s.memoizedProps.value; G$2(Mg, c._currentValue), c._currentValue = et; break; case 13: if (c = s.memoizedState, c !== null) return c.dehydrated !== null ? (G$2(M$3, M$3.current & 1), s.flags |= 128, null) : (o & s.child.childLanes) !== 0 ? pj(e, s, o) : (G$2(M$3, M$3.current & 1), e = $i$1(e, s, o), e !== null ? e.sibling : null); G$2(M$3, M$3.current & 1); break; case 19: if (c = (o & s.childLanes) !== 0, (e.flags & 128) !== 0) { if (c) return yj(e, s, o); s.flags |= 128 } if (et = s.memoizedState, et !== null && (et.rendering = null, et.tail = null, et.lastEffect = null), G$2(M$3, M$3.current), c) break; return null; case 22: case 23: return s.lanes = 0, ej(e, s, o) }return $i$1(e, s, o) } var Aj, Bj, Cj, Dj; Aj = function (e, s) { for (var o = s.child; o !== null;) { if (o.tag === 5 || o.tag === 6) e.appendChild(o.stateNode); else if (o.tag !== 4 && o.child !== null) { o.child.return = o, o = o.child; continue } if (o === s) break; for (; o.sibling === null;) { if (o.return === null || o.return === s) return; o = o.return } o.sibling.return = o.return, o = o.sibling } }; Bj = function () { }; Cj = function (e, s, o, c) { var et = e.memoizedProps; if (et !== c) { e = s.stateNode, Hh(Eh$1.current); var at = null; switch (o) { case "input": et = Ya$1(e, et), c = Ya$1(e, c), at = []; break; case "select": et = A$2({}, et, { value: void 0 }), c = A$2({}, c, { value: void 0 }), at = []; break; case "textarea": et = gb$1(e, et), c = gb$1(e, c), at = []; break; default: typeof et.onClick != "function" && typeof c.onClick == "function" && (e.onclick = Bf) }ub$1(o, c); var lt; o = null; for (ht in et) if (!c.hasOwnProperty(ht) && et.hasOwnProperty(ht) && et[ht] != null) if (ht === "style") { var ft = et[ht]; for (lt in ft) ft.hasOwnProperty(lt) && (o || (o = {}), o[lt] = "") } else ht !== "dangerouslySetInnerHTML" && ht !== "children" && ht !== "suppressContentEditableWarning" && ht !== "suppressHydrationWarning" && ht !== "autoFocus" && (ea$2.hasOwnProperty(ht) ? at || (at = []) : (at = at || []).push(ht, null)); for (ht in c) { var dt = c[ht]; if (ft = et != null ? et[ht] : void 0, c.hasOwnProperty(ht) && dt !== ft && (dt != null || ft != null)) if (ht === "style") if (ft) { for (lt in ft) !ft.hasOwnProperty(lt) || dt && dt.hasOwnProperty(lt) || (o || (o = {}), o[lt] = ""); for (lt in dt) dt.hasOwnProperty(lt) && ft[lt] !== dt[lt] && (o || (o = {}), o[lt] = dt[lt]) } else o || (at || (at = []), at.push(ht, o)), o = dt; else ht === "dangerouslySetInnerHTML" ? (dt = dt ? dt.__html : void 0, ft = ft ? ft.__html : void 0, dt != null && ft !== dt && (at = at || []).push(ht, dt)) : ht === "children" ? typeof dt != "string" && typeof dt != "number" || (at = at || []).push(ht, "" + dt) : ht !== "suppressContentEditableWarning" && ht !== "suppressHydrationWarning" && (ea$2.hasOwnProperty(ht) ? (dt != null && ht === "onScroll" && D$2("scroll", e), at || ft === dt || (at = [])) : (at = at || []).push(ht, dt)) } o && (at = at || []).push("style", o); var ht = at; (s.updateQueue = ht) && (s.flags |= 4) } }; Dj = function (e, s, o, c) { o !== c && (s.flags |= 4) }; function Ej(e, s) { if (!I$2) switch (e.tailMode) { case "hidden": s = e.tail; for (var o = null; s !== null;)s.alternate !== null && (o = s), s = s.sibling; o === null ? e.tail = null : o.sibling = null; break; case "collapsed": o = e.tail; for (var c = null; o !== null;)o.alternate !== null && (c = o), o = o.sibling; c === null ? s || e.tail === null ? e.tail = null : e.tail.sibling = null : c.sibling = null } } function S$3(e) { var s = e.alternate !== null && e.alternate.child === e.child, o = 0, c = 0; if (s) for (var et = e.child; et !== null;)o |= et.lanes | et.childLanes, c |= et.subtreeFlags & 14680064, c |= et.flags & 14680064, et.return = e, et = et.sibling; else for (et = e.child; et !== null;)o |= et.lanes | et.childLanes, c |= et.subtreeFlags, c |= et.flags, et.return = e, et = et.sibling; return e.subtreeFlags |= c, e.childLanes = o, s } function Fj(e, s, o) { var c = s.pendingProps; switch (wg(s), s.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return S$3(s), null; case 1: return Zf(s.type) && $f(), S$3(s), null; case 3: return c = s.stateNode, Jh(), E$2(Wf), E$2(H$3), Oh(), c.pendingContext && (c.context = c.pendingContext, c.pendingContext = null), (e === null || e.child === null) && (Gg(s) ? s.flags |= 4 : e === null || e.memoizedState.isDehydrated && (s.flags & 256) === 0 || (s.flags |= 1024, zg !== null && (Gj(zg), zg = null))), Bj(e, s), S$3(s), null; case 5: Lh(s); var et = Hh(Gh.current); if (o = s.type, e !== null && s.stateNode != null) Cj(e, s, o, c, et), e.ref !== s.ref && (s.flags |= 512, s.flags |= 2097152); else { if (!c) { if (s.stateNode === null) throw Error(p$3(166)); return S$3(s), null } if (e = Hh(Eh$1.current), Gg(s)) { c = s.stateNode, o = s.type; var at = s.memoizedProps; switch (c[Of] = s, c[Pf] = at, e = (s.mode & 1) !== 0, o) { case "dialog": D$2("cancel", c), D$2("close", c); break; case "iframe": case "object": case "embed": D$2("load", c); break; case "video": case "audio": for (et = 0; et < lf.length; et++)D$2(lf[et], c); break; case "source": D$2("error", c); break; case "img": case "image": case "link": D$2("error", c), D$2("load", c); break; case "details": D$2("toggle", c); break; case "input": Za(c, at), D$2("invalid", c); break; case "select": c._wrapperState = { wasMultiple: !!at.multiple }, D$2("invalid", c); break; case "textarea": hb$1(c, at), D$2("invalid", c) }ub$1(o, at), et = null; for (var lt in at) if (at.hasOwnProperty(lt)) { var ft = at[lt]; lt === "children" ? typeof ft == "string" ? c.textContent !== ft && (at.suppressHydrationWarning !== !0 && Af(c.textContent, ft, e), et = ["children", ft]) : typeof ft == "number" && c.textContent !== "" + ft && (at.suppressHydrationWarning !== !0 && Af(c.textContent, ft, e), et = ["children", "" + ft]) : ea$2.hasOwnProperty(lt) && ft != null && lt === "onScroll" && D$2("scroll", c) } switch (o) { case "input": Va$1(c), db$2(c, at, !0); break; case "textarea": Va$1(c), jb$1(c); break; case "select": case "option": break; default: typeof at.onClick == "function" && (c.onclick = Bf) }c = et, s.updateQueue = c, c !== null && (s.flags |= 4) } else { lt = et.nodeType === 9 ? et : et.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = kb$1(o)), e === "http://www.w3.org/1999/xhtml" ? o === "script" ? (e = lt.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof c.is == "string" ? e = lt.createElement(o, { is: c.is }) : (e = lt.createElement(o), o === "select" && (lt = e, c.multiple ? lt.multiple = !0 : c.size && (lt.size = c.size))) : e = lt.createElementNS(e, o), e[Of] = s, e[Pf] = c, Aj(e, s, !1, !1), s.stateNode = e; e: { switch (lt = vb$1(o, c), o) { case "dialog": D$2("cancel", e), D$2("close", e), et = c; break; case "iframe": case "object": case "embed": D$2("load", e), et = c; break; case "video": case "audio": for (et = 0; et < lf.length; et++)D$2(lf[et], e); et = c; break; case "source": D$2("error", e), et = c; break; case "img": case "image": case "link": D$2("error", e), D$2("load", e), et = c; break; case "details": D$2("toggle", e), et = c; break; case "input": Za(e, c), et = Ya$1(e, c), D$2("invalid", e); break; case "option": et = c; break; case "select": e._wrapperState = { wasMultiple: !!c.multiple }, et = A$2({}, c, { value: void 0 }), D$2("invalid", e); break; case "textarea": hb$1(e, c), et = gb$1(e, c), D$2("invalid", e); break; default: et = c }ub$1(o, et), ft = et; for (at in ft) if (ft.hasOwnProperty(at)) { var dt = ft[at]; at === "style" ? sb$1(e, dt) : at === "dangerouslySetInnerHTML" ? (dt = dt ? dt.__html : void 0, dt != null && nb$1(e, dt)) : at === "children" ? typeof dt == "string" ? (o !== "textarea" || dt !== "") && ob$1(e, dt) : typeof dt == "number" && ob$1(e, "" + dt) : at !== "suppressContentEditableWarning" && at !== "suppressHydrationWarning" && at !== "autoFocus" && (ea$2.hasOwnProperty(at) ? dt != null && at === "onScroll" && D$2("scroll", e) : dt != null && ta$2(e, at, dt, lt)) } switch (o) { case "input": Va$1(e), db$2(e, c, !1); break; case "textarea": Va$1(e), jb$1(e); break; case "option": c.value != null && e.setAttribute("value", "" + Sa$1(c.value)); break; case "select": e.multiple = !!c.multiple, at = c.value, at != null ? fb$1(e, !!c.multiple, at, !1) : c.defaultValue != null && fb$1(e, !!c.multiple, c.defaultValue, !0); break; default: typeof et.onClick == "function" && (e.onclick = Bf) }switch (o) { case "button": case "input": case "select": case "textarea": c = !!c.autoFocus; break e; case "img": c = !0; break e; default: c = !1 } } c && (s.flags |= 4) } s.ref !== null && (s.flags |= 512, s.flags |= 2097152) } return S$3(s), null; case 6: if (e && s.stateNode != null) Dj(e, s, e.memoizedProps, c); else { if (typeof c != "string" && s.stateNode === null) throw Error(p$3(166)); if (o = Hh(Gh.current), Hh(Eh$1.current), Gg(s)) { if (c = s.stateNode, o = s.memoizedProps, c[Of] = s, (at = c.nodeValue !== o) && (e = xg, e !== null)) switch (e.tag) { case 3: Af(c.nodeValue, o, (e.mode & 1) !== 0); break; case 5: e.memoizedProps.suppressHydrationWarning !== !0 && Af(c.nodeValue, o, (e.mode & 1) !== 0) }at && (s.flags |= 4) } else c = (o.nodeType === 9 ? o : o.ownerDocument).createTextNode(c), c[Of] = s, s.stateNode = c } return S$3(s), null; case 13: if (E$2(M$3), c = s.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) { if (I$2 && yg !== null && (s.mode & 1) !== 0 && (s.flags & 128) === 0) Hg(), Ig(), s.flags |= 98560, at = !1; else if (at = Gg(s), c !== null && c.dehydrated !== null) { if (e === null) { if (!at) throw Error(p$3(318)); if (at = s.memoizedState, at = at !== null ? at.dehydrated : null, !at) throw Error(p$3(317)); at[Of] = s } else Ig(), (s.flags & 128) === 0 && (s.memoizedState = null), s.flags |= 4; S$3(s), at = !1 } else zg !== null && (Gj(zg), zg = null), at = !0; if (!at) return s.flags & 65536 ? s : null } return (s.flags & 128) !== 0 ? (s.lanes = o, s) : (c = c !== null, c !== (e !== null && e.memoizedState !== null) && c && (s.child.flags |= 8192, (s.mode & 1) !== 0 && (e === null || (M$3.current & 1) !== 0 ? T$2 === 0 && (T$2 = 3) : uj())), s.updateQueue !== null && (s.flags |= 4), S$3(s), null); case 4: return Jh(), Bj(e, s), e === null && sf(s.stateNode.containerInfo), S$3(s), null; case 10: return Rg(s.type._context), S$3(s), null; case 17: return Zf(s.type) && $f(), S$3(s), null; case 19: if (E$2(M$3), at = s.memoizedState, at === null) return S$3(s), null; if (c = (s.flags & 128) !== 0, lt = at.rendering, lt === null) if (c) Ej(at, !1); else { if (T$2 !== 0 || e !== null && (e.flags & 128) !== 0) for (e = s.child; e !== null;) { if (lt = Mh(e), lt !== null) { for (s.flags |= 128, Ej(at, !1), c = lt.updateQueue, c !== null && (s.updateQueue = c, s.flags |= 4), s.subtreeFlags = 0, c = o, o = s.child; o !== null;)at = o, e = c, at.flags &= 14680066, lt = at.alternate, lt === null ? (at.childLanes = 0, at.lanes = e, at.child = null, at.subtreeFlags = 0, at.memoizedProps = null, at.memoizedState = null, at.updateQueue = null, at.dependencies = null, at.stateNode = null) : (at.childLanes = lt.childLanes, at.lanes = lt.lanes, at.child = lt.child, at.subtreeFlags = 0, at.deletions = null, at.memoizedProps = lt.memoizedProps, at.memoizedState = lt.memoizedState, at.updateQueue = lt.updateQueue, at.type = lt.type, e = lt.dependencies, at.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), o = o.sibling; return G$2(M$3, M$3.current & 1 | 2), s.child } e = e.sibling } at.tail !== null && B$3() > Hj && (s.flags |= 128, c = !0, Ej(at, !1), s.lanes = 4194304) } else { if (!c) if (e = Mh(lt), e !== null) { if (s.flags |= 128, c = !0, o = e.updateQueue, o !== null && (s.updateQueue = o, s.flags |= 4), Ej(at, !0), at.tail === null && at.tailMode === "hidden" && !lt.alternate && !I$2) return S$3(s), null } else 2 * B$3() - at.renderingStartTime > Hj && o !== 1073741824 && (s.flags |= 128, c = !0, Ej(at, !1), s.lanes = 4194304); at.isBackwards ? (lt.sibling = s.child, s.child = lt) : (o = at.last, o !== null ? o.sibling = lt : s.child = lt, at.last = lt) } return at.tail !== null ? (s = at.tail, at.rendering = s, at.tail = s.sibling, at.renderingStartTime = B$3(), s.sibling = null, o = M$3.current, G$2(M$3, c ? o & 1 | 2 : o & 1), s) : (S$3(s), null); case 22: case 23: return Ij(), c = s.memoizedState !== null, e !== null && e.memoizedState !== null !== c && (s.flags |= 8192), c && (s.mode & 1) !== 0 ? (gj & 1073741824) !== 0 && (S$3(s), s.subtreeFlags & 6 && (s.flags |= 8192)) : S$3(s), null; case 24: return null; case 25: return null }throw Error(p$3(156, s.tag)) } function Jj(e, s) { switch (wg(s), s.tag) { case 1: return Zf(s.type) && $f(), e = s.flags, e & 65536 ? (s.flags = e & -65537 | 128, s) : null; case 3: return Jh(), E$2(Wf), E$2(H$3), Oh(), e = s.flags, (e & 65536) !== 0 && (e & 128) === 0 ? (s.flags = e & -65537 | 128, s) : null; case 5: return Lh(s), null; case 13: if (E$2(M$3), e = s.memoizedState, e !== null && e.dehydrated !== null) { if (s.alternate === null) throw Error(p$3(340)); Ig() } return e = s.flags, e & 65536 ? (s.flags = e & -65537 | 128, s) : null; case 19: return E$2(M$3), null; case 4: return Jh(), null; case 10: return Rg(s.type._context), null; case 22: case 23: return Ij(), null; case 24: return null; default: return null } } var Kj = !1, U$2 = !1, Lj = typeof WeakSet == "function" ? WeakSet : Set, V$2 = null; function Mj(e, s) { var o = e.ref; if (o !== null) if (typeof o == "function") try { o(null) } catch (c) { W$2(e, s, c) } else o.current = null } function Nj(e, s, o) { try { o() } catch (c) { W$2(e, s, c) } } var Oj = !1; function Pj(e, s) { if (Cf = dd$1, e = Me(), Ne$1(e)) { if ("selectionStart" in e) var o = { start: e.selectionStart, end: e.selectionEnd }; else e: { o = (o = e.ownerDocument) && o.defaultView || window; var c = o.getSelection && o.getSelection(); if (c && c.rangeCount !== 0) { o = c.anchorNode; var et = c.anchorOffset, at = c.focusNode; c = c.focusOffset; try { o.nodeType, at.nodeType } catch { o = null; break e } var lt = 0, ft = -1, dt = -1, ht = 0, vt = 0, wt = e, St = null; t: for (; ;) { for (var _t; wt !== o || et !== 0 && wt.nodeType !== 3 || (ft = lt + et), wt !== at || c !== 0 && wt.nodeType !== 3 || (dt = lt + c), wt.nodeType === 3 && (lt += wt.nodeValue.length), (_t = wt.firstChild) !== null;)St = wt, wt = _t; for (; ;) { if (wt === e) break t; if (St === o && ++ht === et && (ft = lt), St === at && ++vt === c && (dt = lt), (_t = wt.nextSibling) !== null) break; wt = St, St = wt.parentNode } wt = _t } o = ft === -1 || dt === -1 ? null : { start: ft, end: dt } } else o = null } o = o || { start: 0, end: 0 } } else o = null; for (Df = { focusedElem: e, selectionRange: o }, dd$1 = !1, V$2 = s; V$2 !== null;)if (s = V$2, e = s.child, (s.subtreeFlags & 1028) !== 0 && e !== null) e.return = s, V$2 = e; else for (; V$2 !== null;) { s = V$2; try { var Nt = s.alternate; if ((s.flags & 1024) !== 0) switch (s.tag) { case 0: case 11: case 15: break; case 1: if (Nt !== null) { var kt = Nt.memoizedProps, Dt = Nt.memoizedState, xt = s.stateNode, Ct = xt.getSnapshotBeforeUpdate(s.elementType === s.type ? kt : Lg(s.type, kt), Dt); xt.__reactInternalSnapshotBeforeUpdate = Ct } break; case 3: var bt = s.stateNode.containerInfo; bt.nodeType === 1 ? bt.textContent = "" : bt.nodeType === 9 && bt.documentElement && bt.removeChild(bt.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(p$3(163)) } } catch (Pt) { W$2(s, s.return, Pt) } if (e = s.sibling, e !== null) { e.return = s.return, V$2 = e; break } V$2 = s.return } return Nt = Oj, Oj = !1, Nt } function Qj(e, s, o) { var c = s.updateQueue; if (c = c !== null ? c.lastEffect : null, c !== null) { var et = c = c.next; do { if ((et.tag & e) === e) { var at = et.destroy; et.destroy = void 0, at !== void 0 && Nj(s, o, at) } et = et.next } while (et !== c) } } function Rj(e, s) { if (s = s.updateQueue, s = s !== null ? s.lastEffect : null, s !== null) { var o = s = s.next; do { if ((o.tag & e) === e) { var c = o.create; o.destroy = c() } o = o.next } while (o !== s) } } function Sj(e) { var s = e.ref; if (s !== null) { var o = e.stateNode; switch (e.tag) { case 5: e = o; break; default: e = o }typeof s == "function" ? s(e) : s.current = e } } function Tj(e) { var s = e.alternate; s !== null && (e.alternate = null, Tj(s)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (s = e.stateNode, s !== null && (delete s[Of], delete s[Pf], delete s[of], delete s[Qf], delete s[Rf])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function Uj(e) { return e.tag === 5 || e.tag === 3 || e.tag === 4 } function Vj(e) { e: for (; ;) { for (; e.sibling === null;) { if (e.return === null || Uj(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) { if (e.flags & 2 || e.child === null || e.tag === 4) continue e; e.child.return = e, e = e.child } if (!(e.flags & 2)) return e.stateNode } } function Wj(e, s, o) { var c = e.tag; if (c === 5 || c === 6) e = e.stateNode, s ? o.nodeType === 8 ? o.parentNode.insertBefore(e, s) : o.insertBefore(e, s) : (o.nodeType === 8 ? (s = o.parentNode, s.insertBefore(e, o)) : (s = o, s.appendChild(e)), o = o._reactRootContainer, o != null || s.onclick !== null || (s.onclick = Bf)); else if (c !== 4 && (e = e.child, e !== null)) for (Wj(e, s, o), e = e.sibling; e !== null;)Wj(e, s, o), e = e.sibling } function Xj(e, s, o) { var c = e.tag; if (c === 5 || c === 6) e = e.stateNode, s ? o.insertBefore(e, s) : o.appendChild(e); else if (c !== 4 && (e = e.child, e !== null)) for (Xj(e, s, o), e = e.sibling; e !== null;)Xj(e, s, o), e = e.sibling } var X$2 = null, Yj = !1; function Zj(e, s, o) { for (o = o.child; o !== null;)ak(e, s, o), o = o.sibling } function ak(e, s, o) { if (lc$1 && typeof lc$1.onCommitFiberUnmount == "function") try { lc$1.onCommitFiberUnmount(kc$1, o) } catch { } switch (o.tag) { case 5: U$2 || Mj(o, s); case 6: var c = X$2, et = Yj; X$2 = null, Zj(e, s, o), X$2 = c, Yj = et, X$2 !== null && (Yj ? (e = X$2, o = o.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(o) : e.removeChild(o)) : X$2.removeChild(o.stateNode)); break; case 18: X$2 !== null && (Yj ? (e = X$2, o = o.stateNode, e.nodeType === 8 ? Kf(e.parentNode, o) : e.nodeType === 1 && Kf(e, o), bd$1(e)) : Kf(X$2, o.stateNode)); break; case 4: c = X$2, et = Yj, X$2 = o.stateNode.containerInfo, Yj = !0, Zj(e, s, o), X$2 = c, Yj = et; break; case 0: case 11: case 14: case 15: if (!U$2 && (c = o.updateQueue, c !== null && (c = c.lastEffect, c !== null))) { et = c = c.next; do { var at = et, lt = at.destroy; at = at.tag, lt !== void 0 && ((at & 2) !== 0 || (at & 4) !== 0) && Nj(o, s, lt), et = et.next } while (et !== c) } Zj(e, s, o); break; case 1: if (!U$2 && (Mj(o, s), c = o.stateNode, typeof c.componentWillUnmount == "function")) try { c.props = o.memoizedProps, c.state = o.memoizedState, c.componentWillUnmount() } catch (ft) { W$2(o, s, ft) } Zj(e, s, o); break; case 21: Zj(e, s, o); break; case 22: o.mode & 1 ? (U$2 = (c = U$2) || o.memoizedState !== null, Zj(e, s, o), U$2 = c) : Zj(e, s, o); break; default: Zj(e, s, o) } } function bk(e) { var s = e.updateQueue; if (s !== null) { e.updateQueue = null; var o = e.stateNode; o === null && (o = e.stateNode = new Lj), s.forEach(function (c) { var et = ck.bind(null, e, c); o.has(c) || (o.add(c), c.then(et, et)) }) } } function dk(e, s) { var o = s.deletions; if (o !== null) for (var c = 0; c < o.length; c++) { var et = o[c]; try { var at = e, lt = s, ft = lt; e: for (; ft !== null;) { switch (ft.tag) { case 5: X$2 = ft.stateNode, Yj = !1; break e; case 3: X$2 = ft.stateNode.containerInfo, Yj = !0; break e; case 4: X$2 = ft.stateNode.containerInfo, Yj = !0; break e }ft = ft.return } if (X$2 === null) throw Error(p$3(160)); ak(at, lt, et), X$2 = null, Yj = !1; var dt = et.alternate; dt !== null && (dt.return = null), et.return = null } catch (ht) { W$2(et, s, ht) } } if (s.subtreeFlags & 12854) for (s = s.child; s !== null;)ek(s, e), s = s.sibling } function ek(e, s) { var o = e.alternate, c = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (dk(s, e), fk(e), c & 4) { try { Qj(3, e, e.return), Rj(3, e) } catch (kt) { W$2(e, e.return, kt) } try { Qj(5, e, e.return) } catch (kt) { W$2(e, e.return, kt) } } break; case 1: dk(s, e), fk(e), c & 512 && o !== null && Mj(o, o.return); break; case 5: if (dk(s, e), fk(e), c & 512 && o !== null && Mj(o, o.return), e.flags & 32) { var et = e.stateNode; try { ob$1(et, "") } catch (kt) { W$2(e, e.return, kt) } } if (c & 4 && (et = e.stateNode, et != null)) { var at = e.memoizedProps, lt = o !== null ? o.memoizedProps : at, ft = e.type, dt = e.updateQueue; if (e.updateQueue = null, dt !== null) try { ft === "input" && at.type === "radio" && at.name != null && ab$1(et, at), vb$1(ft, lt); var ht = vb$1(ft, at); for (lt = 0; lt < dt.length; lt += 2) { var vt = dt[lt], wt = dt[lt + 1]; vt === "style" ? sb$1(et, wt) : vt === "dangerouslySetInnerHTML" ? nb$1(et, wt) : vt === "children" ? ob$1(et, wt) : ta$2(et, vt, wt, ht) } switch (ft) { case "input": bb$1(et, at); break; case "textarea": ib$1(et, at); break; case "select": var St = et._wrapperState.wasMultiple; et._wrapperState.wasMultiple = !!at.multiple; var _t = at.value; _t != null ? fb$1(et, !!at.multiple, _t, !1) : St !== !!at.multiple && (at.defaultValue != null ? fb$1(et, !!at.multiple, at.defaultValue, !0) : fb$1(et, !!at.multiple, at.multiple ? [] : "", !1)) }et[Pf] = at } catch (kt) { W$2(e, e.return, kt) } } break; case 6: if (dk(s, e), fk(e), c & 4) { if (e.stateNode === null) throw Error(p$3(162)); et = e.stateNode, at = e.memoizedProps; try { et.nodeValue = at } catch (kt) { W$2(e, e.return, kt) } } break; case 3: if (dk(s, e), fk(e), c & 4 && o !== null && o.memoizedState.isDehydrated) try { bd$1(s.containerInfo) } catch (kt) { W$2(e, e.return, kt) } break; case 4: dk(s, e), fk(e); break; case 13: dk(s, e), fk(e), et = e.child, et.flags & 8192 && (at = et.memoizedState !== null, et.stateNode.isHidden = at, !at || et.alternate !== null && et.alternate.memoizedState !== null || (gk = B$3())), c & 4 && bk(e); break; case 22: if (vt = o !== null && o.memoizedState !== null, e.mode & 1 ? (U$2 = (ht = U$2) || vt, dk(s, e), U$2 = ht) : dk(s, e), fk(e), c & 8192) { if (ht = e.memoizedState !== null, (e.stateNode.isHidden = ht) && !vt && (e.mode & 1) !== 0) for (V$2 = e, vt = e.child; vt !== null;) { for (wt = V$2 = vt; V$2 !== null;) { switch (St = V$2, _t = St.child, St.tag) { case 0: case 11: case 14: case 15: Qj(4, St, St.return); break; case 1: Mj(St, St.return); var Nt = St.stateNode; if (typeof Nt.componentWillUnmount == "function") { c = St, o = St.return; try { s = c, Nt.props = s.memoizedProps, Nt.state = s.memoizedState, Nt.componentWillUnmount() } catch (kt) { W$2(c, o, kt) } } break; case 5: Mj(St, St.return); break; case 22: if (St.memoizedState !== null) { hk(wt); continue } }_t !== null ? (_t.return = St, V$2 = _t) : hk(wt) } vt = vt.sibling } e: for (vt = null, wt = e; ;) { if (wt.tag === 5) { if (vt === null) { vt = wt; try { et = wt.stateNode, ht ? (at = et.style, typeof at.setProperty == "function" ? at.setProperty("display", "none", "important") : at.display = "none") : (ft = wt.stateNode, dt = wt.memoizedProps.style, lt = dt != null && dt.hasOwnProperty("display") ? dt.display : null, ft.style.display = rb$1("display", lt)) } catch (kt) { W$2(e, e.return, kt) } } } else if (wt.tag === 6) { if (vt === null) try { wt.stateNode.nodeValue = ht ? "" : wt.memoizedProps } catch (kt) { W$2(e, e.return, kt) } } else if ((wt.tag !== 22 && wt.tag !== 23 || wt.memoizedState === null || wt === e) && wt.child !== null) { wt.child.return = wt, wt = wt.child; continue } if (wt === e) break e; for (; wt.sibling === null;) { if (wt.return === null || wt.return === e) break e; vt === wt && (vt = null), wt = wt.return } vt === wt && (vt = null), wt.sibling.return = wt.return, wt = wt.sibling } } break; case 19: dk(s, e), fk(e), c & 4 && bk(e); break; case 21: break; default: dk(s, e), fk(e) } } function fk(e) { var s = e.flags; if (s & 2) { try { e: { for (var o = e.return; o !== null;) { if (Uj(o)) { var c = o; break e } o = o.return } throw Error(p$3(160)) } switch (c.tag) { case 5: var et = c.stateNode; c.flags & 32 && (ob$1(et, ""), c.flags &= -33); var at = Vj(e); Xj(e, at, et); break; case 3: case 4: var lt = c.stateNode.containerInfo, ft = Vj(e); Wj(e, ft, lt); break; default: throw Error(p$3(161)) } } catch (dt) { W$2(e, e.return, dt) } e.flags &= -3 } s & 4096 && (e.flags &= -4097) } function ik(e, s, o) { V$2 = e, jk(e) } function jk(e, s, o) { for (var c = (e.mode & 1) !== 0; V$2 !== null;) { var et = V$2, at = et.child; if (et.tag === 22 && c) { var lt = et.memoizedState !== null || Kj; if (!lt) { var ft = et.alternate, dt = ft !== null && ft.memoizedState !== null || U$2; ft = Kj; var ht = U$2; if (Kj = lt, (U$2 = dt) && !ht) for (V$2 = et; V$2 !== null;)lt = V$2, dt = lt.child, lt.tag === 22 && lt.memoizedState !== null ? kk(et) : dt !== null ? (dt.return = lt, V$2 = dt) : kk(et); for (; at !== null;)V$2 = at, jk(at), at = at.sibling; V$2 = et, Kj = ft, U$2 = ht } lk(e) } else (et.subtreeFlags & 8772) !== 0 && at !== null ? (at.return = et, V$2 = at) : lk(e) } } function lk(e) { for (; V$2 !== null;) { var s = V$2; if ((s.flags & 8772) !== 0) { var o = s.alternate; try { if ((s.flags & 8772) !== 0) switch (s.tag) { case 0: case 11: case 15: U$2 || Rj(5, s); break; case 1: var c = s.stateNode; if (s.flags & 4 && !U$2) if (o === null) c.componentDidMount(); else { var et = s.elementType === s.type ? o.memoizedProps : Lg(s.type, o.memoizedProps); c.componentDidUpdate(et, o.memoizedState, c.__reactInternalSnapshotBeforeUpdate) } var at = s.updateQueue; at !== null && ih$1(s, at, c); break; case 3: var lt = s.updateQueue; if (lt !== null) { if (o = null, s.child !== null) switch (s.child.tag) { case 5: o = s.child.stateNode; break; case 1: o = s.child.stateNode }ih$1(s, lt, o) } break; case 5: var ft = s.stateNode; if (o === null && s.flags & 4) { o = ft; var dt = s.memoizedProps; switch (s.type) { case "button": case "input": case "select": case "textarea": dt.autoFocus && o.focus(); break; case "img": dt.src && (o.src = dt.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (s.memoizedState === null) { var ht = s.alternate; if (ht !== null) { var vt = ht.memoizedState; if (vt !== null) { var wt = vt.dehydrated; wt !== null && bd$1(wt) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(p$3(163)) }U$2 || s.flags & 512 && Sj(s) } catch (St) { W$2(s, s.return, St) } } if (s === e) { V$2 = null; break } if (o = s.sibling, o !== null) { o.return = s.return, V$2 = o; break } V$2 = s.return } } function hk(e) { for (; V$2 !== null;) { var s = V$2; if (s === e) { V$2 = null; break } var o = s.sibling; if (o !== null) { o.return = s.return, V$2 = o; break } V$2 = s.return } } function kk(e) { for (; V$2 !== null;) { var s = V$2; try { switch (s.tag) { case 0: case 11: case 15: var o = s.return; try { Rj(4, s) } catch (dt) { W$2(s, o, dt) } break; case 1: var c = s.stateNode; if (typeof c.componentDidMount == "function") { var et = s.return; try { c.componentDidMount() } catch (dt) { W$2(s, et, dt) } } var at = s.return; try { Sj(s) } catch (dt) { W$2(s, at, dt) } break; case 5: var lt = s.return; try { Sj(s) } catch (dt) { W$2(s, lt, dt) } } } catch (dt) { W$2(s, s.return, dt) } if (s === e) { V$2 = null; break } var ft = s.sibling; if (ft !== null) { ft.return = s.return, V$2 = ft; break } V$2 = s.return } } var mk = Math.ceil, nk = ua$1.ReactCurrentDispatcher, ok = ua$1.ReactCurrentOwner, pk = ua$1.ReactCurrentBatchConfig, K$2 = 0, R$2 = null, Y$2 = null, Z$1 = 0, gj = 0, fj = Uf(0), T$2 = 0, qk = null, hh$1 = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = 1 / 0, vk = null, Pi = !1, Qi = null, Si = null, wk = !1, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0; function L$3() { return (K$2 & 6) !== 0 ? B$3() : Bk !== -1 ? Bk : Bk = B$3() } function lh$1(e) { return (e.mode & 1) === 0 ? 1 : (K$2 & 2) !== 0 && Z$1 !== 0 ? Z$1 & -Z$1 : Kg.transition !== null ? (Ck === 0 && (Ck = yc$1()), Ck) : (e = C$3, e !== 0 || (e = window.event, e = e === void 0 ? 16 : jd$1(e.type)), e) } function mh(e, s, o, c) { if (50 < zk) throw zk = 0, Ak = null, Error(p$3(185)); Ac$2(e, o, c), ((K$2 & 2) === 0 || e !== R$2) && (e === R$2 && ((K$2 & 2) === 0 && (rk |= o), T$2 === 4 && Dk(e, Z$1)), Ek(e, c), o === 1 && K$2 === 0 && (s.mode & 1) === 0 && (Hj = B$3() + 500, fg && jg())) } function Ek(e, s) { var o = e.callbackNode; wc$2(e, s); var c = uc$1(e, e === R$2 ? Z$1 : 0); if (c === 0) o !== null && bc$1(o), e.callbackNode = null, e.callbackPriority = 0; else if (s = c & -c, e.callbackPriority !== s) { if (o != null && bc$1(o), s === 1) e.tag === 0 ? ig(Fk.bind(null, e)) : hg(Fk.bind(null, e)), Jf(function () { (K$2 & 6) === 0 && jg() }), o = null; else { switch (Dc$1(c)) { case 1: o = fc$2; break; case 4: o = gc$1; break; case 16: o = hc$2; break; case 536870912: o = jc$2; break; default: o = hc$2 }o = Gk(o, Hk.bind(null, e)) } e.callbackPriority = s, e.callbackNode = o } } function Hk(e, s) { if (Bk = -1, Ck = 0, (K$2 & 6) !== 0) throw Error(p$3(327)); var o = e.callbackNode; if (Ik() && e.callbackNode !== o) return null; var c = uc$1(e, e === R$2 ? Z$1 : 0); if (c === 0) return null; if ((c & 30) !== 0 || (c & e.expiredLanes) !== 0 || s) s = Jk(e, c); else { s = c; var et = K$2; K$2 |= 2; var at = Kk(); (R$2 !== e || Z$1 !== s) && (vk = null, Hj = B$3() + 500, Lk(e, s)); do try { Mk(); break } catch (ft) { Nk(e, ft) } while (1); Qg(), nk.current = at, K$2 = et, Y$2 !== null ? s = 0 : (R$2 = null, Z$1 = 0, s = T$2) } if (s !== 0) { if (s === 2 && (et = xc$1(e), et !== 0 && (c = et, s = Ok(e, et))), s === 1) throw o = qk, Lk(e, 0), Dk(e, c), Ek(e, B$3()), o; if (s === 6) Dk(e, c); else { if (et = e.current.alternate, (c & 30) === 0 && !Pk(et) && (s = Jk(e, c), s === 2 && (at = xc$1(e), at !== 0 && (c = at, s = Ok(e, at))), s === 1)) throw o = qk, Lk(e, 0), Dk(e, c), Ek(e, B$3()), o; switch (e.finishedWork = et, e.finishedLanes = c, s) { case 0: case 1: throw Error(p$3(345)); case 2: Qk(e, uk, vk); break; case 3: if (Dk(e, c), (c & 130023424) === c && (s = gk + 500 - B$3(), 10 < s)) { if (uc$1(e, 0) !== 0) break; if (et = e.suspendedLanes, (et & c) !== c) { L$3(), e.pingedLanes |= e.suspendedLanes & et; break } e.timeoutHandle = Ff(Qk.bind(null, e, uk, vk), s); break } Qk(e, uk, vk); break; case 4: if (Dk(e, c), (c & 4194240) === c) break; for (s = e.eventTimes, et = -1; 0 < c;) { var lt = 31 - oc$1(c); at = 1 << lt, lt = s[lt], lt > et && (et = lt), c &= ~at } if (c = et, c = B$3() - c, c = (120 > c ? 120 : 480 > c ? 480 : 1080 > c ? 1080 : 1920 > c ? 1920 : 3e3 > c ? 3e3 : 4320 > c ? 4320 : 1960 * mk(c / 1960)) - c, 10 < c) { e.timeoutHandle = Ff(Qk.bind(null, e, uk, vk), c); break } Qk(e, uk, vk); break; case 5: Qk(e, uk, vk); break; default: throw Error(p$3(329)) } } } return Ek(e, B$3()), e.callbackNode === o ? Hk.bind(null, e) : null } function Ok(e, s) { var o = tk; return e.current.memoizedState.isDehydrated && (Lk(e, s).flags |= 256), e = Jk(e, s), e !== 2 && (s = uk, uk = o, s !== null && Gj(s)), e } function Gj(e) { uk === null ? uk = e : uk.push.apply(uk, e) } function Pk(e) { for (var s = e; ;) { if (s.flags & 16384) { var o = s.updateQueue; if (o !== null && (o = o.stores, o !== null)) for (var c = 0; c < o.length; c++) { var et = o[c], at = et.getSnapshot; et = et.value; try { if (!He$1(at(), et)) return !1 } catch { return !1 } } } if (o = s.child, s.subtreeFlags & 16384 && o !== null) o.return = s, s = o; else { if (s === e) break; for (; s.sibling === null;) { if (s.return === null || s.return === e) return !0; s = s.return } s.sibling.return = s.return, s = s.sibling } } return !0 } function Dk(e, s) { for (s &= ~sk, s &= ~rk, e.suspendedLanes |= s, e.pingedLanes &= ~s, e = e.expirationTimes; 0 < s;) { var o = 31 - oc$1(s), c = 1 << o; e[o] = -1, s &= ~c } } function Fk(e) { if ((K$2 & 6) !== 0) throw Error(p$3(327)); Ik(); var s = uc$1(e, 0); if ((s & 1) === 0) return Ek(e, B$3()), null; var o = Jk(e, s); if (e.tag !== 0 && o === 2) { var c = xc$1(e); c !== 0 && (s = c, o = Ok(e, c)) } if (o === 1) throw o = qk, Lk(e, 0), Dk(e, s), Ek(e, B$3()), o; if (o === 6) throw Error(p$3(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = s, Qk(e, uk, vk), Ek(e, B$3()), null } function Rk(e, s) { var o = K$2; K$2 |= 1; try { return e(s) } finally { K$2 = o, K$2 === 0 && (Hj = B$3() + 500, fg && jg()) } } function Sk(e) { xk !== null && xk.tag === 0 && (K$2 & 6) === 0 && Ik(); var s = K$2; K$2 |= 1; var o = pk.transition, c = C$3; try { if (pk.transition = null, C$3 = 1, e) return e() } finally { C$3 = c, pk.transition = o, K$2 = s, (K$2 & 6) === 0 && jg() } } function Ij() { gj = fj.current, E$2(fj) } function Lk(e, s) { e.finishedWork = null, e.finishedLanes = 0; var o = e.timeoutHandle; if (o !== -1 && (e.timeoutHandle = -1, Gf(o)), Y$2 !== null) for (o = Y$2.return; o !== null;) { var c = o; switch (wg(c), c.tag) { case 1: c = c.type.childContextTypes, c != null && $f(); break; case 3: Jh(), E$2(Wf), E$2(H$3), Oh(); break; case 5: Lh(c); break; case 4: Jh(); break; case 13: E$2(M$3); break; case 19: E$2(M$3); break; case 10: Rg(c.type._context); break; case 22: case 23: Ij() }o = o.return } if (R$2 = e, Y$2 = e = wh(e.current, null), Z$1 = gj = s, T$2 = 0, qk = null, sk = rk = hh$1 = 0, uk = tk = null, Wg !== null) { for (s = 0; s < Wg.length; s++)if (o = Wg[s], c = o.interleaved, c !== null) { o.interleaved = null; var et = c.next, at = o.pending; if (at !== null) { var lt = at.next; at.next = et, c.next = lt } o.pending = c } Wg = null } return e } function Nk(e, s) { do { var o = Y$2; try { if (Qg(), Ph$1.current = ai, Sh$1) { for (var c = N$3.memoizedState; c !== null;) { var et = c.queue; et !== null && (et.pending = null), c = c.next } Sh$1 = !1 } if (Rh$1 = 0, P$3 = O$3 = N$3 = null, Th = !1, Uh = 0, ok.current = null, o === null || o.return === null) { T$2 = 1, qk = s, Y$2 = null; break } e: { var at = e, lt = o.return, ft = o, dt = s; if (s = Z$1, ft.flags |= 32768, dt !== null && typeof dt == "object" && typeof dt.then == "function") { var ht = dt, vt = ft, wt = vt.tag; if ((vt.mode & 1) === 0 && (wt === 0 || wt === 11 || wt === 15)) { var St = vt.alternate; St ? (vt.updateQueue = St.updateQueue, vt.memoizedState = St.memoizedState, vt.lanes = St.lanes) : (vt.updateQueue = null, vt.memoizedState = null) } var _t = Vi(lt); if (_t !== null) { _t.flags &= -257, Wi$1(_t, lt, ft, at, s), _t.mode & 1 && Ti(at, ht, s), s = _t, dt = ht; var Nt = s.updateQueue; if (Nt === null) { var kt = new Set; kt.add(dt), s.updateQueue = kt } else Nt.add(dt); break e } else { if ((s & 1) === 0) { Ti(at, ht, s), uj(); break e } dt = Error(p$3(426)) } } else if (I$2 && ft.mode & 1) { var Dt = Vi(lt); if (Dt !== null) { (Dt.flags & 65536) === 0 && (Dt.flags |= 256), Wi$1(Dt, lt, ft, at, s), Jg(Ki(dt, ft)); break e } } at = dt = Ki(dt, ft), T$2 !== 4 && (T$2 = 2), tk === null ? tk = [at] : tk.push(at), at = lt; do { switch (at.tag) { case 3: at.flags |= 65536, s &= -s, at.lanes |= s; var xt = Oi$1(at, dt, s); fh$1(at, xt); break e; case 1: ft = dt; var Ct = at.type, bt = at.stateNode; if ((at.flags & 128) === 0 && (typeof Ct.getDerivedStateFromError == "function" || bt !== null && typeof bt.componentDidCatch == "function" && (Si === null || !Si.has(bt)))) { at.flags |= 65536, s &= -s, at.lanes |= s; var Pt = Ri(at, ft, s); fh$1(at, Pt); break e } }at = at.return } while (at !== null) } Tk(o) } catch (Rt) { s = Rt, Y$2 === o && o !== null && (Y$2 = o = o.return); continue } break } while (1) } function Kk() { var e = nk.current; return nk.current = ai, e === null ? ai : e } function uj() { (T$2 === 0 || T$2 === 3 || T$2 === 2) && (T$2 = 4), R$2 === null || (hh$1 & 268435455) === 0 && (rk & 268435455) === 0 || Dk(R$2, Z$1) } function Jk(e, s) { var o = K$2; K$2 |= 2; var c = Kk(); (R$2 !== e || Z$1 !== s) && (vk = null, Lk(e, s)); do try { Uk(); break } catch (et) { Nk(e, et) } while (1); if (Qg(), K$2 = o, nk.current = c, Y$2 !== null) throw Error(p$3(261)); return R$2 = null, Z$1 = 0, T$2 } function Uk() { for (; Y$2 !== null;)Vk(Y$2) } function Mk() { for (; Y$2 !== null && !cc$2();)Vk(Y$2) } function Vk(e) { var s = Wk(e.alternate, e, gj); e.memoizedProps = e.pendingProps, s === null ? Tk(e) : Y$2 = s, ok.current = null } function Tk(e) { var s = e; do { var o = s.alternate; if (e = s.return, (s.flags & 32768) === 0) { if (o = Fj(o, s, gj), o !== null) { Y$2 = o; return } } else { if (o = Jj(o, s), o !== null) { o.flags &= 32767, Y$2 = o; return } if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null; else { T$2 = 6, Y$2 = null; return } } if (s = s.sibling, s !== null) { Y$2 = s; return } Y$2 = s = e } while (s !== null); T$2 === 0 && (T$2 = 5) } function Qk(e, s, o) { var c = C$3, et = pk.transition; try { pk.transition = null, C$3 = 1, Xk(e, s, o, c) } finally { pk.transition = et, C$3 = c } return null } function Xk(e, s, o, c) { do Ik(); while (xk !== null); if ((K$2 & 6) !== 0) throw Error(p$3(327)); o = e.finishedWork; var et = e.finishedLanes; if (o === null) return null; if (e.finishedWork = null, e.finishedLanes = 0, o === e.current) throw Error(p$3(177)); e.callbackNode = null, e.callbackPriority = 0; var at = o.lanes | o.childLanes; if (Bc$1(e, at), e === R$2 && (Y$2 = R$2 = null, Z$1 = 0), (o.subtreeFlags & 2064) === 0 && (o.flags & 2064) === 0 || wk || (wk = !0, Gk(hc$2, function () { return Ik(), null })), at = (o.flags & 15990) !== 0, (o.subtreeFlags & 15990) !== 0 || at) { at = pk.transition, pk.transition = null; var lt = C$3; C$3 = 1; var ft = K$2; K$2 |= 4, ok.current = null, Pj(e, o), ek(o, e), Oe(Df), dd$1 = !!Cf, Df = Cf = null, e.current = o, ik(o), dc$2(), K$2 = ft, C$3 = lt, pk.transition = at } else e.current = o; if (wk && (wk = !1, xk = e, yk = et), at = e.pendingLanes, at === 0 && (Si = null), mc$2(o.stateNode), Ek(e, B$3()), s !== null) for (c = e.onRecoverableError, o = 0; o < s.length; o++)et = s[o], c(et.value, { componentStack: et.stack, digest: et.digest }); if (Pi) throw Pi = !1, e = Qi, Qi = null, e; return (yk & 1) !== 0 && e.tag !== 0 && Ik(), at = e.pendingLanes, (at & 1) !== 0 ? e === Ak ? zk++ : (zk = 0, Ak = e) : zk = 0, jg(), null } function Ik() { if (xk !== null) { var e = Dc$1(yk), s = pk.transition, o = C$3; try { if (pk.transition = null, C$3 = 16 > e ? 16 : e, xk === null) var c = !1; else { if (e = xk, xk = null, yk = 0, (K$2 & 6) !== 0) throw Error(p$3(331)); var et = K$2; for (K$2 |= 4, V$2 = e.current; V$2 !== null;) { var at = V$2, lt = at.child; if ((V$2.flags & 16) !== 0) { var ft = at.deletions; if (ft !== null) { for (var dt = 0; dt < ft.length; dt++) { var ht = ft[dt]; for (V$2 = ht; V$2 !== null;) { var vt = V$2; switch (vt.tag) { case 0: case 11: case 15: Qj(8, vt, at) }var wt = vt.child; if (wt !== null) wt.return = vt, V$2 = wt; else for (; V$2 !== null;) { vt = V$2; var St = vt.sibling, _t = vt.return; if (Tj(vt), vt === ht) { V$2 = null; break } if (St !== null) { St.return = _t, V$2 = St; break } V$2 = _t } } } var Nt = at.alternate; if (Nt !== null) { var kt = Nt.child; if (kt !== null) { Nt.child = null; do { var Dt = kt.sibling; kt.sibling = null, kt = Dt } while (kt !== null) } } V$2 = at } } if ((at.subtreeFlags & 2064) !== 0 && lt !== null) lt.return = at, V$2 = lt; else e: for (; V$2 !== null;) { if (at = V$2, (at.flags & 2048) !== 0) switch (at.tag) { case 0: case 11: case 15: Qj(9, at, at.return) }var xt = at.sibling; if (xt !== null) { xt.return = at.return, V$2 = xt; break e } V$2 = at.return } } var Ct = e.current; for (V$2 = Ct; V$2 !== null;) { lt = V$2; var bt = lt.child; if ((lt.subtreeFlags & 2064) !== 0 && bt !== null) bt.return = lt, V$2 = bt; else e: for (lt = Ct; V$2 !== null;) { if (ft = V$2, (ft.flags & 2048) !== 0) try { switch (ft.tag) { case 0: case 11: case 15: Rj(9, ft) } } catch (Rt) { W$2(ft, ft.return, Rt) } if (ft === lt) { V$2 = null; break e } var Pt = ft.sibling; if (Pt !== null) { Pt.return = ft.return, V$2 = Pt; break e } V$2 = ft.return } } if (K$2 = et, jg(), lc$1 && typeof lc$1.onPostCommitFiberRoot == "function") try { lc$1.onPostCommitFiberRoot(kc$1, e) } catch { } c = !0 } return c } finally { C$3 = o, pk.transition = s } } return !1 } function Yk(e, s, o) { s = Ki(o, s), s = Oi$1(e, s, 1), e = dh(e, s, 1), s = L$3(), e !== null && (Ac$2(e, 1, s), Ek(e, s)) } function W$2(e, s, o) { if (e.tag === 3) Yk(e, e, o); else for (; s !== null;) { if (s.tag === 3) { Yk(s, e, o); break } else if (s.tag === 1) { var c = s.stateNode; if (typeof s.type.getDerivedStateFromError == "function" || typeof c.componentDidCatch == "function" && (Si === null || !Si.has(c))) { e = Ki(o, e), e = Ri(s, e, 1), s = dh(s, e, 1), e = L$3(), s !== null && (Ac$2(s, 1, e), Ek(s, e)); break } } s = s.return } } function Ui(e, s, o) { var c = e.pingCache; c !== null && c.delete(s), s = L$3(), e.pingedLanes |= e.suspendedLanes & o, R$2 === e && (Z$1 & o) === o && (T$2 === 4 || T$2 === 3 && (Z$1 & 130023424) === Z$1 && 500 > B$3() - gk ? Lk(e, 0) : sk |= o), Ek(e, s) } function Zk(e, s) { s === 0 && ((e.mode & 1) === 0 ? s = 1 : (s = sc$1, sc$1 <<= 1, (sc$1 & 130023424) === 0 && (sc$1 = 4194304))); var o = L$3(); e = Zg(e, s), e !== null && (Ac$2(e, s, o), Ek(e, o)) } function vj(e) { var s = e.memoizedState, o = 0; s !== null && (o = s.retryLane), Zk(e, o) } function ck(e, s) { var o = 0; switch (e.tag) { case 13: var c = e.stateNode, et = e.memoizedState; et !== null && (o = et.retryLane); break; case 19: c = e.stateNode; break; default: throw Error(p$3(314)) }c !== null && c.delete(s), Zk(e, o) } var Wk; Wk = function (e, s, o) { if (e !== null) if (e.memoizedProps !== s.pendingProps || Wf.current) Ug = !0; else { if ((e.lanes & o) === 0 && (s.flags & 128) === 0) return Ug = !1, zj(e, s, o); Ug = (e.flags & 131072) !== 0 } else Ug = !1, I$2 && (s.flags & 1048576) !== 0 && ug(s, ng, s.index); switch (s.lanes = 0, s.tag) { case 2: var c = s.type; jj(e, s), e = s.pendingProps; var et = Yf(s, H$3.current); Tg(s, o), et = Xh(null, s, c, e, et, o); var at = bi(); return s.flags |= 1, typeof et == "object" && et !== null && typeof et.render == "function" && et.$$typeof === void 0 ? (s.tag = 1, s.memoizedState = null, s.updateQueue = null, Zf(c) ? (at = !0, cg(s)) : at = !1, s.memoizedState = et.state !== null && et.state !== void 0 ? et.state : null, ah$1(s), et.updater = nh, s.stateNode = et, et._reactInternals = s, rh$1(s, c, e, o), s = kj(null, s, c, !0, at, o)) : (s.tag = 0, I$2 && at && vg(s), Yi(null, s, et, o), s = s.child), s; case 16: c = s.elementType; e: { switch (jj(e, s), e = s.pendingProps, et = c._init, c = et(c._payload), s.type = c, et = s.tag = $k(c), e = Lg(c, e), et) { case 0: s = dj(null, s, c, e, o); break e; case 1: s = ij(null, s, c, e, o); break e; case 11: s = Zi(null, s, c, e, o); break e; case 14: s = aj(null, s, c, Lg(c.type, e), o); break e }throw Error(p$3(306, c, "")) } return s; case 0: return c = s.type, et = s.pendingProps, et = s.elementType === c ? et : Lg(c, et), dj(e, s, c, et, o); case 1: return c = s.type, et = s.pendingProps, et = s.elementType === c ? et : Lg(c, et), ij(e, s, c, et, o); case 3: e: { if (lj(s), e === null) throw Error(p$3(387)); c = s.pendingProps, at = s.memoizedState, et = at.element, bh$1(e, s), gh(s, c, null, o); var lt = s.memoizedState; if (c = lt.element, at.isDehydrated) if (at = { element: c, isDehydrated: !1, cache: lt.cache, pendingSuspenseBoundaries: lt.pendingSuspenseBoundaries, transitions: lt.transitions }, s.updateQueue.baseState = at, s.memoizedState = at, s.flags & 256) { et = Ki(Error(p$3(423)), s), s = mj(e, s, c, o, et); break e } else if (c !== et) { et = Ki(Error(p$3(424)), s), s = mj(e, s, c, o, et); break e } else for (yg = Lf(s.stateNode.containerInfo.firstChild), xg = s, I$2 = !0, zg = null, o = Ch(s, null, c, o), s.child = o; o;)o.flags = o.flags & -3 | 4096, o = o.sibling; else { if (Ig(), c === et) { s = $i$1(e, s, o); break e } Yi(e, s, c, o) } s = s.child } return s; case 5: return Kh(s), e === null && Eg(s), c = s.type, et = s.pendingProps, at = e !== null ? e.memoizedProps : null, lt = et.children, Ef(c, et) ? lt = null : at !== null && Ef(c, at) && (s.flags |= 32), hj(e, s), Yi(e, s, lt, o), s.child; case 6: return e === null && Eg(s), null; case 13: return pj(e, s, o); case 4: return Ih(s, s.stateNode.containerInfo), c = s.pendingProps, e === null ? s.child = Bh(s, null, c, o) : Yi(e, s, c, o), s.child; case 11: return c = s.type, et = s.pendingProps, et = s.elementType === c ? et : Lg(c, et), Zi(e, s, c, et, o); case 7: return Yi(e, s, s.pendingProps, o), s.child; case 8: return Yi(e, s, s.pendingProps.children, o), s.child; case 12: return Yi(e, s, s.pendingProps.children, o), s.child; case 10: e: { if (c = s.type._context, et = s.pendingProps, at = s.memoizedProps, lt = et.value, G$2(Mg, c._currentValue), c._currentValue = lt, at !== null) if (He$1(at.value, lt)) { if (at.children === et.children && !Wf.current) { s = $i$1(e, s, o); break e } } else for (at = s.child, at !== null && (at.return = s); at !== null;) { var ft = at.dependencies; if (ft !== null) { lt = at.child; for (var dt = ft.firstContext; dt !== null;) { if (dt.context === c) { if (at.tag === 1) { dt = ch$1(-1, o & -o), dt.tag = 2; var ht = at.updateQueue; if (ht !== null) { ht = ht.shared; var vt = ht.pending; vt === null ? dt.next = dt : (dt.next = vt.next, vt.next = dt), ht.pending = dt } } at.lanes |= o, dt = at.alternate, dt !== null && (dt.lanes |= o), Sg(at.return, o, s), ft.lanes |= o; break } dt = dt.next } } else if (at.tag === 10) lt = at.type === s.type ? null : at.child; else if (at.tag === 18) { if (lt = at.return, lt === null) throw Error(p$3(341)); lt.lanes |= o, ft = lt.alternate, ft !== null && (ft.lanes |= o), Sg(lt, o, s), lt = at.sibling } else lt = at.child; if (lt !== null) lt.return = at; else for (lt = at; lt !== null;) { if (lt === s) { lt = null; break } if (at = lt.sibling, at !== null) { at.return = lt.return, lt = at; break } lt = lt.return } at = lt } Yi(e, s, et.children, o), s = s.child } return s; case 9: return et = s.type, c = s.pendingProps.children, Tg(s, o), et = Vg(et), c = c(et), s.flags |= 1, Yi(e, s, c, o), s.child; case 14: return c = s.type, et = Lg(c, s.pendingProps), et = Lg(c.type, et), aj(e, s, c, et, o); case 15: return cj(e, s, s.type, s.pendingProps, o); case 17: return c = s.type, et = s.pendingProps, et = s.elementType === c ? et : Lg(c, et), jj(e, s), s.tag = 1, Zf(c) ? (e = !0, cg(s)) : e = !1, Tg(s, o), ph(s, c, et), rh$1(s, c, et, o), kj(null, s, c, !0, e, o); case 19: return yj(e, s, o); case 22: return ej(e, s, o) }throw Error(p$3(156, s.tag)) }; function Gk(e, s) { return ac$1(e, s) } function al(e, s, o, c) { this.tag = e, this.key = o, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = s, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = c, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Bg(e, s, o, c) { return new al(e, s, o, c) } function bj(e) { return e = e.prototype, !(!e || !e.isReactComponent) } function $k(e) { if (typeof e == "function") return bj(e) ? 1 : 0; if (e != null) { if (e = e.$$typeof, e === Da) return 11; if (e === Ga$1) return 14 } return 2 } function wh(e, s) { var o = e.alternate; return o === null ? (o = Bg(e.tag, s, e.key, e.mode), o.elementType = e.elementType, o.type = e.type, o.stateNode = e.stateNode, o.alternate = e, e.alternate = o) : (o.pendingProps = s, o.type = e.type, o.flags = 0, o.subtreeFlags = 0, o.deletions = null), o.flags = e.flags & 14680064, o.childLanes = e.childLanes, o.lanes = e.lanes, o.child = e.child, o.memoizedProps = e.memoizedProps, o.memoizedState = e.memoizedState, o.updateQueue = e.updateQueue, s = e.dependencies, o.dependencies = s === null ? null : { lanes: s.lanes, firstContext: s.firstContext }, o.sibling = e.sibling, o.index = e.index, o.ref = e.ref, o } function yh(e, s, o, c, et, at) { var lt = 2; if (c = e, typeof e == "function") bj(e) && (lt = 1); else if (typeof e == "string") lt = 5; else e: switch (e) { case ya$2: return Ah$1(o.children, et, at, s); case za$1: lt = 8, et |= 8; break; case Aa$1: return e = Bg(12, o, s, et | 2), e.elementType = Aa$1, e.lanes = at, e; case Ea$2: return e = Bg(13, o, s, et), e.elementType = Ea$2, e.lanes = at, e; case Fa$1: return e = Bg(19, o, s, et), e.elementType = Fa$1, e.lanes = at, e; case Ia$1: return qj(o, et, at, s); default: if (typeof e == "object" && e !== null) switch (e.$$typeof) { case Ba$1: lt = 10; break e; case Ca: lt = 9; break e; case Da: lt = 11; break e; case Ga$1: lt = 14; break e; case Ha$1: lt = 16, c = null; break e }throw Error(p$3(130, e == null ? e : typeof e, "")) }return s = Bg(lt, o, s, et), s.elementType = e, s.type = c, s.lanes = at, s } function Ah$1(e, s, o, c) { return e = Bg(7, e, c, s), e.lanes = o, e } function qj(e, s, o, c) { return e = Bg(22, e, c, s), e.elementType = Ia$1, e.lanes = o, e.stateNode = { isHidden: !1 }, e } function xh(e, s, o) { return e = Bg(6, e, null, s), e.lanes = o, e } function zh(e, s, o) { return s = Bg(4, e.children !== null ? e.children : [], e.key, s), s.lanes = o, s.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, s } function bl(e, s, o, c, et) { this.tag = s, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = zc$2(0), this.expirationTimes = zc$2(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = zc$2(0), this.identifierPrefix = c, this.onRecoverableError = et, this.mutableSourceEagerHydrationData = null } function cl(e, s, o, c, et, at, lt, ft, dt) { return e = new bl(e, s, o, ft, dt), s === 1 ? (s = 1, at === !0 && (s |= 8)) : s = 0, at = Bg(3, null, null, s), e.current = at, at.stateNode = e, at.memoizedState = { element: c, isDehydrated: o, cache: null, transitions: null, pendingSuspenseBoundaries: null }, ah$1(at), e } function dl(e, s, o) { var c = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: wa$2, key: c == null ? null : "" + c, children: e, containerInfo: s, implementation: o } } function el$1(e) { if (!e) return Vf; e = e._reactInternals; e: { if (Vb$1(e) !== e || e.tag !== 1) throw Error(p$3(170)); var s = e; do { switch (s.tag) { case 3: s = s.stateNode.context; break e; case 1: if (Zf(s.type)) { s = s.stateNode.__reactInternalMemoizedMergedChildContext; break e } }s = s.return } while (s !== null); throw Error(p$3(171)) } if (e.tag === 1) { var o = e.type; if (Zf(o)) return bg(e, o, s) } return s } function fl(e, s, o, c, et, at, lt, ft, dt) { return e = cl(o, c, !0, e, et, at, lt, ft, dt), e.context = el$1(null), o = e.current, c = L$3(), et = lh$1(o), at = ch$1(c, et), at.callback = s != null ? s : null, dh(o, at, et), e.current.lanes = et, Ac$2(e, et, c), Ek(e, c), e } function gl(e, s, o, c) { var et = s.current, at = L$3(), lt = lh$1(et); return o = el$1(o), s.context === null ? s.context = o : s.pendingContext = o, s = ch$1(at, lt), s.payload = { element: e }, c = c === void 0 ? null : c, c !== null && (s.callback = c), e = dh(et, s, lt), e !== null && (mh(e, et, lt, at), eh$1(e, et, lt)), lt } function hl(e) { if (e = e.current, !e.child) return null; switch (e.child.tag) { case 5: return e.child.stateNode; default: return e.child.stateNode } } function il(e, s) { if (e = e.memoizedState, e !== null && e.dehydrated !== null) { var o = e.retryLane; e.retryLane = o !== 0 && o < s ? o : s } } function jl(e, s) { il(e, s), (e = e.alternate) && il(e, s) } function kl() { return null } var ll = typeof reportError == "function" ? reportError : function (e) { console.error(e) }; function ml(e) { this._internalRoot = e } nl.prototype.render = ml.prototype.render = function (e) { var s = this._internalRoot; if (s === null) throw Error(p$3(409)); gl(e, s, null, null) }; nl.prototype.unmount = ml.prototype.unmount = function () { var e = this._internalRoot; if (e !== null) { this._internalRoot = null; var s = e.containerInfo; Sk(function () { gl(null, e, null, null) }), s[uf] = null } }; function nl(e) { this._internalRoot = e } nl.prototype.unstable_scheduleHydration = function (e) { if (e) { var s = Hc$2(); e = { blockedOn: null, target: e, priority: s }; for (var o = 0; o < Qc$2.length && s !== 0 && s < Qc$2[o].priority; o++); Qc$2.splice(o, 0, e), o === 0 && Vc$1(e) } }; function ol(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11) } function pl$1(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable ")) } function ql() { } function rl(e, s, o, c, et) { if (et) { if (typeof c == "function") { var at = c; c = function () { var ht = hl(lt); at.call(ht) } } var lt = fl(s, c, e, 0, null, !1, !1, "", ql); return e._reactRootContainer = lt, e[uf] = lt.current, sf(e.nodeType === 8 ? e.parentNode : e), Sk(), lt } for (; et = e.lastChild;)e.removeChild(et); if (typeof c == "function") { var ft = c; c = function () { var ht = hl(dt); ft.call(ht) } } var dt = cl(e, 0, !1, null, null, !1, !1, "", ql); return e._reactRootContainer = dt, e[uf] = dt.current, sf(e.nodeType === 8 ? e.parentNode : e), Sk(function () { gl(s, dt, o, c) }), dt } function sl(e, s, o, c, et) { var at = o._reactRootContainer; if (at) { var lt = at; if (typeof et == "function") { var ft = et; et = function () { var dt = hl(lt); ft.call(dt) } } gl(s, lt, e, et) } else lt = rl(o, s, e, et, c); return hl(lt) } Ec$2 = function (e) { switch (e.tag) { case 3: var s = e.stateNode; if (s.current.memoizedState.isDehydrated) { var o = tc$1(s.pendingLanes); o !== 0 && (Cc$1(s, o | 1), Ek(s, B$3()), (K$2 & 6) === 0 && (Hj = B$3() + 500, jg())) } break; case 13: Sk(function () { var c = Zg(e, 1); if (c !== null) { var et = L$3(); mh(c, e, 1, et) } }), jl(e, 1) } }; Fc$2 = function (e) { if (e.tag === 13) { var s = Zg(e, 134217728); if (s !== null) { var o = L$3(); mh(s, e, 134217728, o) } jl(e, 134217728) } }; Gc$2 = function (e) { if (e.tag === 13) { var s = lh$1(e), o = Zg(e, s); if (o !== null) { var c = L$3(); mh(o, e, s, c) } jl(e, s) } }; Hc$2 = function () { return C$3 }; Ic$1 = function (e, s) { var o = C$3; try { return C$3 = e, s() } finally { C$3 = o } }; yb$1 = function (e, s, o) { switch (s) { case "input": if (bb$1(e, o), s = o.name, o.type === "radio" && s != null) { for (o = e; o.parentNode;)o = o.parentNode; for (o = o.querySelectorAll("input[name=" + JSON.stringify("" + s) + '][type="radio"]'), s = 0; s < o.length; s++) { var c = o[s]; if (c !== e && c.form === e.form) { var et = Db$1(c); if (!et) throw Error(p$3(90)); Wa$1(c), bb$1(c, et) } } } break; case "textarea": ib$1(e, o); break; case "select": s = o.value, s != null && fb$1(e, !!o.multiple, s, !1) } }; Gb$1 = Rk; Hb$1 = Sk; var tl = { usingClientEntryPoint: !1, Events: [Cb$1, ue, Db$1, Eb$1, Fb$1, Rk] }, ul = { findFiberByHostInstance: Wc$1, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua$1.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return e = Zb$1(e), e === null ? null : e.stateNode }, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!wl.isDisabled && wl.supportsFiber) try { kc$1 = wl.inject(vl), lc$1 = wl } catch { } } reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl; reactDom_production_min.createPortal = function (e, s) { var o = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!ol(s)) throw Error(p$3(200)); return dl(e, s, null, o) }; reactDom_production_min.createRoot = function (e, s) { if (!ol(e)) throw Error(p$3(299)); var o = !1, c = "", et = ll; return s != null && (s.unstable_strictMode === !0 && (o = !0), s.identifierPrefix !== void 0 && (c = s.identifierPrefix), s.onRecoverableError !== void 0 && (et = s.onRecoverableError)), s = cl(e, 1, !1, null, null, o, !1, c, et), e[uf] = s.current, sf(e.nodeType === 8 ? e.parentNode : e), new ml(s) }; reactDom_production_min.findDOMNode = function (e) { if (e == null) return null; if (e.nodeType === 1) return e; var s = e._reactInternals; if (s === void 0) throw typeof e.render == "function" ? Error(p$3(188)) : (e = Object.keys(e).join(","), Error(p$3(268, e))); return e = Zb$1(s), e = e === null ? null : e.stateNode, e }; reactDom_production_min.flushSync = function (e) { return Sk(e) }; reactDom_production_min.hydrate = function (e, s, o) { if (!pl$1(s)) throw Error(p$3(200)); return sl(null, e, s, !0, o) }; reactDom_production_min.hydrateRoot = function (e, s, o) { if (!ol(e)) throw Error(p$3(405)); var c = o != null && o.hydratedSources || null, et = !1, at = "", lt = ll; if (o != null && (o.unstable_strictMode === !0 && (et = !0), o.identifierPrefix !== void 0 && (at = o.identifierPrefix), o.onRecoverableError !== void 0 && (lt = o.onRecoverableError)), s = fl(s, null, e, 1, o != null ? o : null, et, !1, at, lt), e[uf] = s.current, sf(e), c) for (e = 0; e < c.length; e++)o = c[e], et = o._getVersion, et = et(o._source), s.mutableSourceEagerHydrationData == null ? s.mutableSourceEagerHydrationData = [o, et] : s.mutableSourceEagerHydrationData.push(o, et); return new nl(s) }; reactDom_production_min.render = function (e, s, o) { if (!pl$1(s)) throw Error(p$3(200)); return sl(null, e, s, !1, o) }; reactDom_production_min.unmountComponentAtNode = function (e) { if (!pl$1(e)) throw Error(p$3(40)); return e._reactRootContainer ? (Sk(function () { sl(null, null, e, !1, function () { e._reactRootContainer = null, e[uf] = null }) }), !0) : !1 }; reactDom_production_min.unstable_batchedUpdates = Rk; reactDom_production_min.unstable_renderSubtreeIntoContainer = function (e, s, o, c) { if (!pl$1(o)) throw Error(p$3(200)); if (e == null || e._reactInternals === void 0) throw Error(p$3(38)); return sl(e, s, o, !1, c) }; reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608"; (function (e) { function s() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(s) } catch (o) { console.error(o) } } s(), e.exports = reactDom_production_min })(reactDom); var m$2 = reactDom.exports; client.createRoot = m$2.createRoot, client.hydrateRoot = m$2.hydrateRoot; const logo = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAABICAYAAACz6LpGAAAAAXNSR0IArs4c6QAACnlJREFUeF7tXY3RFEUQnYlAjUCIQIhAiECMQIhAjECIQIhAiUCIQIhAiECIQIigrfc5c7U723+zc3ff3l5vlaXlt7sz87pf/03PXk5xBQKBgIhADmwCgUBARiAIEtoRCCgIBEFCPQKBIEjoQCCwDoHwIOtwi6euBIEgyJUIOpa5DoEgyDrc4qkrQSAIciWCjmWuQyAIsg63eOpKELhYghDRg5TSTymleymlzyml9ymllznnj1ciu1jmGRC4SIIQ0dOU0m8MPiDKk5zzaw47InpcSMX9+UPOGe+NKxA4IHBxBCme4y9FhiDJfc6TENGzlNKvwrPvcs7wSnEFAn0EcShlL6QIg/APwqK3Oec33hcQEbzDD8b9CLUW3iAI4kU57qsIuDzICQjSSgBkeZZzfmWJhojIuielxHqDIIgDubhlhsBWCFInBe+AHAJhEnsFQUKDz4nA1giCtSPseiiRxBliPc85I9+YXeFBzqla+xhriwQBsshLHnIQO8K9LymlOxzBgiD7UNpzrmKrBAEGrBfAH0q59ncGKJDjQc4ZXmhxBUHOqVr7GGvLBEEeclcJte4gsYe3KKJ4m1J6YeQvUebdh96ebRXHIsiHspvdM/HvHTf/knN+4bjPdUt4EBdMcdMEgWMRBEk1LLj7IiJYflStvlMeOurm3RYIQkRojfmqWfOnU7XIENHXE4zx3zcVwpzzO7ewrvjGWyNIySUgMOyBtApzEEnOeTFHQcnqMzNlI6Kpp0KrCf7hLuQt3laTL1KeI+Q+6BnDLv2jlBLWzF1QXBiMV73Gpn1ZMT4/lzFBSOmCUatjaqV1GLNvT8gTtPncjN8QejGkl9jWe1JKhzG1dd0qQQogCKEgTOn6ps0riAiClUK0WXLv3Dfplb3LsxERiDHNk7zjgKwIL9d4ZbTSSEZAGh/KifztuUBwLXfzrkm6b4alVaXkDKYwZxgkrSXJFfVsgSAW+IuFbJ0gxXqhygaPMXL9kXN+4nmBUtnzPF7vATGxUTurAhqhac/7uXtn8g2CNBARkeVBUMmatbBvmSAl/AM5tNCmR6nUjdPihdHZ7A0PrbHhTaC0B5KckCAIJ2feLggyEU+xtP8ocTli/UXMvlWClPXArR+LHFPLznYXnEh5QZIfa4h3ojGwNs74qaHR1YRYJZH801CmhYUpFnOTOQgRYT2jYZVk4RcdykcKq7S85ObYwIkIIrUD7ZIgcMdiFUSQgOfsBZtIbdGDnFhZASFygz8qlg7va4VS1t8PyfMJCKK1A+2SIBbYa/7+JufMWuONEgShYt3Vl9b7qVS10Gt2k1cREdYIz6NdC2vbobQvU0pI9qc5xb9KWIt5YOMXLTu19GoVUnrlOyP79OG95iC9AFn3ixamN8RqwD9Jq4nTe3AhEvKrvw1icYksntNyt6rkj5gCh1UUUfvZLMEV+WjGAvsPYo4WBLERhvV6rG3E9XiQMxHEOuUonXC0cpaZJZ+EV5bXgae6x+wfWc9hCNf+gCRGh7FQ3x8EsQniOTTlTtLPRBDtlCN29hehl/LhiTplLU5HLoJNSOni9o4wB3graScf7xJDH1tsh11wzbOJYfOE/JGDOMB+n3O+r1ipzRDEsnic0pW9EiirdqGCJLXtd4cwRITxtPIzWzF0yOpwiyMvWpR12/dbeF5qmbcHR++9bFiytRzEEVLMWmVK9cnKO1RLbrTPLDqgHZuxrtYZTXClbA/iSpcoz8bLhwfxMoTbSNogQbTEf7HR6dgrMRXJIEjbumHlHWye0yGjm1uNdalFl2sgSFdiV6woBIeKitjJWzpbF413W0rSe1roHXnHcIw+TbKLVdfyjuGKVSGH1RjoPtez1xCriyCThAwxsRaLf8w532Xi1C3lIK7SsSPvcFnyYlywjyFdB1k48o5VcmPkoeU3bJFCyS93GWKtBtrxlZKhdvfGfUufLMVtamFAEai6iYak0pF3wJKjLOv6rrARYqGH6rUj73BbdSP3gIfnvg9QH+vSjfAgDdqOysdQu/sp4tuedyKPKt8R1nq0xIoVp5wGQbBzDg+r7c4PV6xKaGVtdHYn/0GQfoIMtbt3KnOXtStKgv0FrXqDUq1WXl1UrEqugvYQtr/N8Lr1GWm/Y7GTXZTyc88pybJ2qwWli/jOfMYsFZf3WB0DLllv4cCU2sMkHLldlYMU4LRNPfF7XEaYARJoZ+ulx7n2k5qXiedAHKVlaTxph72WnWfnQIw1WxuPq7yUI8cSPwc1yW09rTjbJwgRIXbVjodKu9AjBLHaQtyn+CYCsSwpp2uLilVJ5HGepFp/liSOPQduPLZi1chgcVhKyb203Xx3WVcIITWDY87RUUrHsGclCMByJZgTQEAMq/tV6mEaIYiVVGKKNx/TTilBic02/mL11I9PNIrQdsuCEDiXjyJCGxpJJLHaTVrdu0neJ6RGtQgnEdvwz6OAVlnXtPKGd7IMzuxAV+M5vEedz0oQbb0jf2PjzbX7IBMg14ZE9RWL5NNRbJjiAILXDzJA2aCkWo/UgiSdXgQKBULh3zBKGFMzTipJiAheznOexyv7dnPTyuvqe4FLJT2e0b4a087l4gkixrBHIIhlAS3BcgSBgkNgp/o8DpevWImotQ7t7+yXLZ3nV3rH5SqVvR5yeEzuBcdK0nsnZ93PJpMTD7A6xJq8Q9sTseYn/f4IPAHmpnUHWO925w+40TAWa8aqz0jhredgWO+4HEHMb6b1DtLcf7EexGx/GPUgE5KstVJifX+gwiTJ2/ogNxQJpFxTRZPGlL4FYOUGa3VWOlp9KoODeV4kQeA5cAqObfM+pgcZ9CTqBlipRh3Dk3jxAEkQbmlnRLzKK31MwVM69Y7hzgfKHg3yjKN6ZW/b/JZCLPz82lNn1Wg4xJpKqCg0FMzzQW08au4Ql8rWiNK68WjIDiu/RplARpzkZL/mSERrva2HNNYpQ3gSjH80L3kpBIFQYB3w2Ut3mfhYIVYruUIUlIFRDdGSbZMgE6WFcKG01g+P1kdADOChelFJ6woxkV9hHZ6CAUrOGO/wxRQGF29VyUMG7h5XuFPCV6xNIwpC0kpmdzeBNHGvB8FAx/wYWndbA2PxpcWjA9hNNk2ipZTKlUNXzb9UgGpJt+KJahHIUH/x19x38WphITwqdsBqWpbFWMDotQcrBQfvVKz70CjqXneZTy3p1nVhPfVj3Ph/Wi+aeeamTthFEGt18fdAYCsIMN0I3NTcPWJBkK1INuYxjEDx0NhJ1zZdu86nBEGGxRIvOCcCze+91KERriLk8uzuz1purLkHQSyE4u+bQmDw917cxZXIQTYl9piMF4EBgqzqMA4P4pVM3LcJBFYSxOzOGCrzbgKZmEQg8H/vmXbgjcNoNTnwsvAgoXYXhUAnQfBLvmhdcu+xtGAEQS5KPWKyToKobTM9KAZBetCKe28dAYUgaJnBTvrst1BGJxwEGUUwnr81BNBy4mmVGZlgEGQEvXh29wgEQXYv4ljgCAJBkBH04tndIxAE2b2IY4EjCARBRtCLZ3ePQBBk9yKOBY4gEAQZQS+e3T0CQZDdizgWOIJAEGQEvXh29wj8B674hqNu6TjTAAAAAElFTkSuQmCC", bitcoin = "/assets/bitcoin.2e756e69.png", c1 = "/assets/c1.08a9865c.jpg", c2 = "/assets/c2.f83ca7b4.png", c3 = "/assets/c3.8a1a89a1.jpg", app$1 = "/assets/explore.7612105e.png"; var DefaultContext = { color: void 0, size: void 0, className: void 0, style: void 0, attr: void 0 }, IconContext = React.createContext && React.createContext(DefaultContext), jsxRuntime$1 = { exports: {} }, reactJsxRuntime_production_min = {};/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var f$1 = react.exports, k$3 = Symbol.for("react.element"), l$1 = Symbol.for("react.fragment"), m$1 = Object.prototype.hasOwnProperty, n = f$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$2 = { key: !0, ref: !0, __self: !0, __source: !0 }; function q$3(e, s, o) { var c, et = {}, at = null, lt = null; o !== void 0 && (at = "" + o), s.key !== void 0 && (at = "" + s.key), s.ref !== void 0 && (lt = s.ref); for (c in s) m$1.call(s, c) && !p$2.hasOwnProperty(c) && (et[c] = s[c]); if (e && e.defaultProps) for (c in s = e.defaultProps, s) et[c] === void 0 && (et[c] = s[c]); return { $$typeof: k$3, type: e, key: at, ref: lt, props: et, _owner: n.current } } reactJsxRuntime_production_min.Fragment = l$1; reactJsxRuntime_production_min.jsx = q$3; reactJsxRuntime_production_min.jsxs = q$3; (function (e) { e.exports = reactJsxRuntime_production_min })(jsxRuntime$1); const Fragment = jsxRuntime$1.exports.Fragment, jsx = jsxRuntime$1.exports.jsx, jsxs = jsxRuntime$1.exports.jsxs, jsxRuntime = Object.freeze(Object.defineProperty({ __proto__: null, Fragment, jsx, jsxs }, Symbol.toStringTag, { value: "Module" })); var __assign = globalThis && globalThis.__assign || function () { return __assign = Object.assign || function (e) { for (var s, o = 1, c = arguments.length; o < c; o++) { s = arguments[o]; for (var et in s) Object.prototype.hasOwnProperty.call(s, et) && (e[et] = s[et]) } return e }, __assign.apply(this, arguments) }, __rest = globalThis && globalThis.__rest || function (e, s) { var o = {}; for (var c in e) Object.prototype.hasOwnProperty.call(e, c) && s.indexOf(c) < 0 && (o[c] = e[c]); if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var et = 0, c = Object.getOwnPropertySymbols(e); et < c.length; et++)s.indexOf(c[et]) < 0 && Object.prototype.propertyIsEnumerable.call(e, c[et]) && (o[c[et]] = e[c[et]]); return o }; function Tree2Element(e) { return e && e.map(function (s, o) { return React.createElement(s.tag, __assign({ key: o }, s.attr), Tree2Element(s.child)) }) } function GenIcon(e) { return function (s) { return jsx(IconBase, { ...__assign({ attr: __assign({}, e.attr) }, s), children: Tree2Element(e.child) }) } } function IconBase(e) { var s = function (o) { var c = e.attr, et = e.size, at = e.title, lt = __rest(e, ["attr", "size", "title"]), ft = et || o.size || "1em", dt; return o.className && (dt = o.className), e.className && (dt = (dt ? dt + " " : "") + e.className), jsxs("svg", { ...__assign({ stroke: "currentColor", fill: "currentColor", strokeWidth: "0" }, o.attr, c, lt, { className: dt, style: __assign(__assign({ color: e.color || o.color }, o.style), e.style), height: ft, width: ft, xmlns: "http://www.w3.org/2000/svg" }), children: [at && jsx("title", { children: at }), e.children] }) }; return IconContext !== void 0 ? jsx(IconContext.Consumer, { children: function (o) { return s(o) } }) : s(DefaultContext) } function AiFillApple(e) { return GenIcon({ tag: "svg", attr: { viewBox: "0 0 1024 1024" }, child: [{ tag: "path", attr: { d: "M747.4 535.7c-.4-68.2 30.5-119.6 92.9-157.5-34.9-50-87.7-77.5-157.3-82.8-65.9-5.2-138 38.4-164.4 38.4-27.9 0-91.7-36.6-141.9-36.6C273.1 298.8 163 379.8 163 544.6c0 48.7 8.9 99 26.7 150.8 23.8 68.2 109.6 235.3 199.1 232.6 46.8-1.1 79.9-33.2 140.8-33.2 59.1 0 89.7 33.2 141.9 33.2 90.3-1.3 167.9-153.2 190.5-221.6-121.1-57.1-114.6-167.2-114.6-170.7zm-105.1-305c50.7-60.2 46.1-115 44.6-134.7-44.8 2.6-96.6 30.5-126.1 64.8-32.5 36.8-51.6 82.3-47.5 133.6 48.4 3.7 92.6-21.2 129-63.7z" } }] })(e) } function AiFillFacebook(e) { return GenIcon({ tag: "svg", attr: { viewBox: "0 0 1024 1024" }, child: [{ tag: "path", attr: { d: "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-92.4 233.5h-63.9c-50.1 0-59.8 23.8-59.8 58.8v77.1h119.6l-15.6 120.7h-104V912H539.2V602.2H434.9V481.4h104.3v-89c0-103.3 63.1-159.6 155.3-159.6 44.2 0 82.1 3.3 93.2 4.8v107.9z" } }] })(e) } function AiFillInstagram(e) { return GenIcon({ tag: "svg", attr: { viewBox: "0 0 1024 1024" }, child: [{ tag: "path", attr: { d: "M512 378.7c-73.4 0-133.3 59.9-133.3 133.3S438.6 645.3 512 645.3 645.3 585.4 645.3 512 585.4 378.7 512 378.7zM911.8 512c0-55.2.5-109.9-2.6-165-3.1-64-17.7-120.8-64.5-167.6-46.9-46.9-103.6-61.4-167.6-64.5-55.2-3.1-109.9-2.6-165-2.6-55.2 0-109.9-.5-165 2.6-64 3.1-120.8 17.7-167.6 64.5C132.6 226.3 118.1 283 115 347c-3.1 55.2-2.6 109.9-2.6 165s-.5 109.9 2.6 165c3.1 64 17.7 120.8 64.5 167.6 46.9 46.9 103.6 61.4 167.6 64.5 55.2 3.1 109.9 2.6 165 2.6 55.2 0 109.9.5 165-2.6 64-3.1 120.8-17.7 167.6-64.5 46.9-46.9 61.4-103.6 64.5-167.6 3.2-55.1 2.6-109.8 2.6-165zM512 717.1c-113.5 0-205.1-91.6-205.1-205.1S398.5 306.9 512 306.9 717.1 398.5 717.1 512 625.5 717.1 512 717.1zm213.5-370.7c-26.5 0-47.9-21.4-47.9-47.9s21.4-47.9 47.9-47.9 47.9 21.4 47.9 47.9a47.84 47.84 0 0 1-47.9 47.9z" } }] })(e) } function AiFillLinkedin(e) { return GenIcon({ tag: "svg", attr: { viewBox: "0 0 1024 1024" }, child: [{ tag: "path", attr: { d: "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zM349.3 793.7H230.6V411.9h118.7v381.8zm-59.3-434a68.8 68.8 0 1 1 68.8-68.8c-.1 38-30.9 68.8-68.8 68.8zm503.7 434H675.1V608c0-44.3-.8-101.2-61.7-101.2-61.7 0-71.2 48.2-71.2 98v188.9H423.7V411.9h113.8v52.2h1.6c15.8-30 54.5-61.7 112.3-61.7 120.2 0 142.3 79.1 142.3 181.9v209.4z" } }] })(e) } function AiFillPhone(e) { return GenIcon({ tag: "svg", attr: { viewBox: "0 0 1024 1024" }, child: [{ tag: "path", attr: { d: "M885.6 230.2L779.1 123.8a80.83 80.83 0 0 0-57.3-23.8c-21.7 0-42.1 8.5-57.4 23.8L549.8 238.4a80.83 80.83 0 0 0-23.8 57.3c0 21.7 8.5 42.1 23.8 57.4l83.8 83.8A393.82 393.82 0 0 1 553.1 553 395.34 395.34 0 0 1 437 633.8L353.2 550a80.83 80.83 0 0 0-57.3-23.8c-21.7 0-42.1 8.5-57.4 23.8L123.8 664.5a80.89 80.89 0 0 0-23.8 57.4c0 21.7 8.5 42.1 23.8 57.4l106.3 106.3c24.4 24.5 58.1 38.4 92.7 38.4 7.3 0 14.3-.6 21.2-1.8 134.8-22.2 268.5-93.9 376.4-201.7C828.2 612.8 899.8 479.2 922.3 344c6.8-41.3-6.9-83.8-36.7-113.8z" } }] })(e) } function AiFillPlayCircle(e) { return GenIcon({ tag: "svg", attr: { viewBox: "0 0 1024 1024" }, child: [{ tag: "path", attr: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm144.1 454.9L437.7 677.8a8.02 8.02 0 0 1-12.7-6.5V353.7a8 8 0 0 1 12.7-6.5L656.1 506a7.9 7.9 0 0 1 0 12.9z" } }] })(e) } function AiFillStar(e) { return GenIcon({ tag: "svg", attr: { viewBox: "0 0 1024 1024" }, child: [{ tag: "path", attr: { d: "M908.1 353.1l-253.9-36.9L540.7 86.1c-3.1-6.3-8.2-11.4-14.5-14.5-15.8-7.8-35-1.3-42.9 14.5L369.8 316.2l-253.9 36.9c-7 1-13.4 4.3-18.3 9.3a32.05 32.05 0 0 0 .6 45.3l183.7 179.1-43.4 252.9a31.95 31.95 0 0 0 46.4 33.7L512 754l227.1 119.4c6.2 3.3 13.4 4.4 20.3 3.2 17.4-3 29.1-19.5 26.1-36.9l-43.4-252.9 183.7-179.1c5-4.9 8.3-11.3 9.3-18.3 2.7-17.5-9.5-33.7-27-36.3z" } }] })(e) } function AiOutlineArrowRight(e) { return GenIcon({ tag: "svg", attr: { viewBox: "0 0 1024 1024" }, child: [{ tag: "path", attr: { d: "M869 487.8L491.2 159.9c-2.9-2.5-6.6-3.9-10.5-3.9h-88.5c-7.4 0-10.8 9.2-5.2 14l350.2 304H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h585.1L386.9 854c-5.6 4.9-2.2 14 5.2 14h91.5c1.9 0 3.8-.7 5.2-2L869 536.2a32.07 32.07 0 0 0 0-48.4z" } }] })(e) } function AiOutlineClose(e) { return GenIcon({ tag: "svg", attr: { viewBox: "0 0 1024 1024" }, child: [{ tag: "path", attr: { d: "M563.8 512l262.5-312.9c4.4-5.2.7-13.1-6.1-13.1h-79.8c-4.7 0-9.2 2.1-12.3 5.7L511.6 449.8 295.1 191.7c-3-3.6-7.5-5.7-12.3-5.7H203c-6.8 0-10.5 7.9-6.1 13.1L459.4 512 196.9 824.9A7.95 7.95 0 0 0 203 838h79.8c4.7 0 9.2-2.1 12.3-5.7l216.5-258.1 216.5 258.1c3 3.6 7.5 5.7 12.3 5.7h79.8c6.8 0 10.5-7.9 6.1-13.1L563.8 512z" } }] })(e) } function AiOutlineSend(e) { return GenIcon({ tag: "svg", attr: { t: "1569683742680", viewBox: "0 0 1024 1024", version: "1.1" }, child: [{ tag: "defs", attr: {}, child: [] }, { tag: "path", attr: { d: "M931.4 498.9L94.9 79.5c-3.4-1.7-7.3-2.1-11-1.2-8.5 2.1-13.8 10.7-11.7 19.3l86.2 352.2c1.3 5.3 5.2 9.6 10.4 11.3l147.7 50.7-147.6 50.7c-5.2 1.8-9.1 6-10.3 11.3L72.2 926.5c-0.9 3.7-0.5 7.6 1.2 10.9 3.9 7.9 13.5 11.1 21.5 7.2l836.5-417c3.1-1.5 5.6-4.1 7.2-7.1 3.9-8 0.7-17.6-7.2-21.6zM170.8 826.3l50.3-205.6 295.2-101.3c2.3-0.8 4.2-2.6 5-5 1.4-4.2-0.8-8.7-5-10.2L221.1 403 171 198.2l628 314.9-628.2 313.2z" } }] })(e) } function AiOutlineTwitter(e) { return GenIcon({ tag: "svg", attr: { viewBox: "0 0 1024 1024" }, child: [{ tag: "path", attr: { d: "M928 254.3c-30.6 13.2-63.9 22.7-98.2 26.4a170.1 170.1 0 0 0 75-94 336.64 336.64 0 0 1-108.2 41.2A170.1 170.1 0 0 0 672 174c-94.5 0-170.5 76.6-170.5 170.6 0 13.2 1.6 26.4 4.2 39.1-141.5-7.4-267.7-75-351.6-178.5a169.32 169.32 0 0 0-23.2 86.1c0 59.2 30.1 111.4 76 142.1a172 172 0 0 1-77.1-21.7v2.1c0 82.9 58.6 151.6 136.7 167.4a180.6 180.6 0 0 1-44.9 5.8c-11.1 0-21.6-1.1-32.2-2.6C211 652 273.9 701.1 348.8 702.7c-58.6 45.9-132 72.9-211.7 72.9-14.3 0-27.5-.5-41.2-2.1C171.5 822 261.2 850 357.8 850 671.4 850 843 590.2 843 364.7c0-7.4 0-14.8-.5-22.2 33.2-24.3 62.3-54.4 85.5-88.2z" } }] })(e) } function SiFsecure(e) { return GenIcon({ tag: "svg", attr: { role: "img", viewBox: "0 0 24 24" }, child: [{ tag: "title", attr: {}, child: [] }, { tag: "path", attr: { d: "M23.928 2.946a35.921 35.921 0 0 0-22.228-.6A2.219 2.219 0 0 0 .08 5.094c.4 1.6.98 3.439 1.68 5.108.01.04.03.02.03-.02-.1-.78.5-1.77 1.679-2.13a27.546 27.546 0 0 1 17.381.23c.86.3 1.82-.17 2.099-1.059.7-2.248.98-3.778 1.05-4.157.01-.07-.05-.1-.07-.12zM6.658 7.893c-.86.18-2.05.46-2.94.76-1.778.61-1.698 2.778-.749 3.468.07-.4.5-.95.98-1.13 1.779-.7 3.688-1.119 5.617-1.289-.98-.4-1.94-.97-2.899-1.809m14.163 4.338a21.15 21.15 0 0 0-16.441-.65c-.85.32-1.38 1.35-.85 2.329a38.14 38.14 0 0 0 3.148 4.797c-.17-.58.13-1.659 1.27-2.009 3.148-.969 6.456-.56 8.655.33.62.25 1.5.1 1.99-.64a38.6 38.6 0 0 0 2.288-4.017c.03-.06 0-.11-.06-.14m-5.107 7.766a9.915 9.915 0 0 1-2.499-1.8c-.34-.34-.84-.829-1.37-1.409-1.199 0-2.368.12-3.617.52-1.16.36-1.27 1.7-.76 2.399.86 1.07 1.46 1.65 2.419 2.639a2.739 2.739 0 0 0 3.818.02 43.3 43.3 0 0 0 2.059-2.21c.05-.05.03-.14-.05-.16" } }] })(e) } function SiMastercomfig(e) { return GenIcon({ tag: "svg", attr: { role: "img", viewBox: "0 0 24 24" }, child: [{ tag: "title", attr: {}, child: [] }, { tag: "path", attr: { d: "M12 0C5.479 0 .174 5.304.174 11.826V24h1.337v-6.716C3.486 21.064 7.446 23.65 12 23.65c4.554 0 8.514-2.586 10.49-6.367V24h1.336V11.826h-1.337c0 5.798-4.69 10.489-10.489 10.489-5.798 0-10.49-4.691-10.49-10.49C1.51 6.028 6.203 1.338 12 1.338zm0 3.72a8.107 8.107 0 100 16.214 8.107 8.107 0 000-16.215zm0 1.336a6.77 6.77 0 110 13.538 6.77 6.77 0 010-13.538z" } }] })(e) } const header_menu = [{ id: "home", title: "Home" }, { id: "community", title: "Community" }, { id: "features", title: "Features" }, { id: "market", title: "Market" }, { id: "reviews", title: "Reviews" }, { id: "convertor", title: "Convertor" }, { id: "contact", title: "Contact" }], features = [{ id: "feature-1", icon: AiFillStar, title: "Best trading platform", content: "Lorem ipsum dolor sit amet consectetur adipisicing elit. dignissimos tenetur sapiente. Corrupti, inventore?      " }, { id: "feature-2", icon: SiFsecure, title: "100% Secured", content: "Lorem ipsum dolor sit amet consectetur adipisicing elit. Exercitationem unde dolorem dignissimos tenetur sapiente ipsa." }, { id: "feature-3", icon: SiMastercomfig, title: "Comfortable ecosystem", content: "Lorem ipsum dolor sit amet consectetur adipisicing elit. Exercitationem tenetur sapiente ipsa. Corrupti, inventore? " }], testimonials = [{ id: "1", content: "Lorem ipsum dolor sit amet consectetur, adipisicing elit. Dolores corporis provident dolore quisquam dolorem error blanditiis itaque iste totam tempore nesciunt hic, voluptatum ad at rem esse quaerat ullam voluptates. Nam neque aliquid corrupti blanditiis!", name: "John Doe", title: "Founder & Leader", img: c1 }, { id: "2", content: "Lorem ipsum dolor sit, amet consectetur adipisicing elit. Explicabo voluptatem optio illo excepturi? Aut ducimus, dignissimos voluptatem amet temporLorem ipsum dolor sit amet consectetur, adipisicing elit. Dolores corporis provident dolore quisquam dolorem error blanditiis ie aspernatur quo adipisci atque est asperiores.", name: "Henry Marck", title: "Founder & Leader", img: c2 }, { id: "3", content: "Lorem ipsum dolor sit, amet consectetur adipisicing elit. Explicabo voluptatem optio illo excepturi? Aut ducimus, dignissimos voluptatem amet tempore aspernatur quo adipisci atque est asperiores.", name: "Antim Reck", title: "Founder & Leader", img: c3 }, { id: "4", content: "Lorem ipsum dolor sit, amet consectetur adipisicing elit. Explicabo voluptatem optio illo excepturi? Aut ducimus, dignissimos voluptatem amet tempore aspernatur quo adipisci atque est asperiores.", name: "Kenn Gallagher", title: "Founder & Leader", img: c3 }], community_stats = [{ id: "stats-1", title: "People who have joined biteezy", value: "20M+" }, { id: "stats-2", title: "Famous People playing biteezy", value: "100+" }, { id: "stats-3", title: "Cooperation with big companies", value: "50" }], markets = [{ id: 1, title: "IDR", data: [{ name: "BTC/IDR", rate: "669,600,00", percent: "+4.59%" }, { name: "USDT/IDR", rate: "14,346", percent: "-0.11%", isNegative: !0 }, { name: "XRR/IDR", rate: "15,600", percent: "0.00%" }, { name: "ETH/IDR", rate: "48,550,000", percent: "+5.80%" }, { name: "DOT/IDR", rate: "536,100", percent: "+4.87%" }] }, { id: 2, title: "BTC", data: [{ name: "BFC/IDR", rate: "0.000000635", percent: "-4.08%", isNegative: !0 }, { name: "SNX/IDR", rate: "0.00029135", percent: "+2.18%" }, { name: "FIL/IDR", rate: "0.00172174", percent: "-0.99%", isNegative: !0 }, { name: "ALGO/IDR", rate: "0.00004466", percent: "-6.31%", isNegative: !0 }, { name: "TUSD/IDR", rate: "0.00002148", percent: "-2.81%", isNegative: !0 }] }, { id: 3, title: "USDT", data: [{ name: "BTC/USDT", rate: "46,721.351", percent: "+3.66%" }, { name: "ETH/USDT", rate: "3,384,958", percent: "+3.16%" }, { name: "XRR/USDT", rate: "1,079", percent: "+1.27%" }, { name: "LTE/USDT", rate: "12.700", percent: "-2.12%", isNegative: !0 }, { name: "DOT/USDT", rate: "271,790", percent: "+1.98%" }] }], footer_menu = [{ title: "Useful Links", links: [{ name: "Contact us", link: "#" }, { name: "Carrers", link: "#" }, { name: "Explore", link: "https://www.hoobank.com/explore/" }, { name: "Terms & Services", link: "https://www.hoobank.com/terms-and-services/" }] }, { title: "Community", links: [{ name: "Help Center", link: "https://www.hoobank.com/help-center/" }, { name: "Partners", link: "https://www.hoobank.com/partners/" }, { name: "Suggestions", link: "https://www.hoobank.com/suggestions/" }, { name: "Blog", link: "https://www.hoobank.com/blog/" }, { name: "Newsletters", link: "https://www.hoobank.com/newsletters/" }] }, { title: "Partner", links: [{ name: "Coin Base", link: "#" }, { name: "Coin Desk", link: "#" }, { name: "Binance", link: "#" }] }, { title: "Download", links: [{ name: AiFillPlayCircle, link: "#", isImg: !0, title: "Play store" }, { name: AiFillApple, link: "#", isImg: !0, title: "App store" }] }], socail_media_icons = [{ id: "social-media-1", icon: AiFillInstagram, link: "https://www.instagram.com/" }, { id: "social-media-2", icon: AiFillFacebook, link: "https://www.facebook.com/" }, { id: "social-media-3", icon: AiOutlineTwitter, link: "https://www.twitter.com/" }, { id: "social-media-4", icon: AiFillLinkedin, link: "https://www.linkedin.com/" }], convertor_dropdown_data1 = [{ value: "BTC", title: "Bitcoin" }, { value: "ETH", title: "Ethereum" }, { value: "USDT", title: "Tether" }, { value: "BNB", title: "Binance" }, { value: "XRP", title: "XRP" }, { value: "LUNA", title: "Terra" }, { value: "ADA", title: "Cardano" }, { value: "SOL", title: "Solana" }, { value: "DOT", title: "Polkadot" }, { value: "LTC", title: "Litecoin" }], convertor_dropdown_data2 = [{ value: "USD", title: "Us Dollar" }, { value: "EUR", title: "Euro" }, { value: "JPY", title: "Japanese Yen" }, { value: "GBP", title: "Pound Sterling" }, { value: "LUNA", title: "Terra" }, { value: "CHF", title: "Swiss franc " }, { value: "HKD", title: "Hong Kong dollar" }, { value: "NZD", title: "New Zealand Dollar" }, { value: "LTC", title: "Litecoin" }, { value: "CRO", title: "Cronos" }, { value: "CAD", title: "Canadian Dollar" }, { value: "AUD", title: "Australian Dollar" }, { value: "BTC", title: "Bitcoin" }]; function BiMenuAltRight(e) { return GenIcon({ tag: "svg", attr: { viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { d: "M4 6h16v2H4zm4 5h12v2H8zm5 5h7v2h-7z" } }] })(e) } const styles$1 = { boxWidth: "xl:max-w-[1280px] w-full", heading2: "font-poppins font-semibold md:text-[50px] sm-text-[40px] text-[35px] text-white sm:leading-[76.8px] leading-[66.8px] w-full", paragraph: "font-poppins font-normal text-greyish text-[16px] md:text-[18px] leading-[30.8px]", flexCenter: "flex justify-center items-center", flexStart: "flex justify-center items-start", flexEnd: "flex md:justify-end items-center justify-start", paddingX: "sm:px-16 px-6", paddingY: "md:py-24 ss:py-12 py-4", padding: "sm:px-16 px-6 sm:py-12 py-4", marginX: "sm:mx-16 mx-6", marginY: "sm:my-16 my-6" }, layout = { section: `flex md:flex-row flex-col ${styles$1.paddingY}`, sectionReverse: `flex md:flex-row flex-col-reverse ${styles$1.paddingY}`, sectionImgReverse: `flex-1 flex ${styles$1.flexCenter} md:mr-10 mr-0 md:mt-0 mt-10 relative`, sectionImg: `flex-1 flex ${styles$1.flexCenter} md:ml-10 ml-0 md:mt-0 mt-10 relative`, sectionInfo: `flex-1 ${styles$1.flexStart} flex-col` }, Navbar = () => { const [e, s] = react.exports.useState("Home"), [o, c] = react.exports.useState(!1); return jsxs("nav", { className: `w-full ${styles$1.boxWidth} flex py-6 justify-between items-center navbar`, children: [jsx("img", { src: logo, alt: "Biteezy", className: " w-[30%] ss:w-[20%] sm:w-[15%] md:w-[10%]" }), jsx("ul", { className: "list-none md:flex hidden justify-end items-center flex-1", children: header_menu.map((et, at) => jsx("li", { className: `font-poppins font-normal cursor-pointer text-[16px] hover:text-secondary ${e === et.title ? "text-white" : "text-dimWhite"} ${at === header_menu.length - 1 ? "mr-0" : "mr-10"}`, onClick: () => s(et.title), children: jsx("a", { href: `#${et.id}`, children: et.title }) }, et.id)) }), jsxs("div", { className: "md:hidden flex flex-1 justify-end items-center", children: [jsx("div", { className: "text-3xl", onClick: () => c(!o), children: o ? jsx(AiOutlineClose, {}) : jsx(BiMenuAltRight, {}) }), jsx("div", { className: `${o ? "flex" : "hidden"} p-6 bg-black-gradient absolute top-20 right-0 mx-4 my-2 min-w-[140px] rounded-xl sidebar z-50`, children: jsx("ul", { className: "list-none flex justify-end items-start flex-1 flex-col", children: header_menu.map((et, at) => jsx("li", { className: `font-poppins font-medium cursor-pointer text-[16px] ${e === et.title ? "text-white" : "text-dimWhite"} ${at === header_menu.length - 1 ? "mb-0" : "mb-4"}`, onClick: () => { s(et.title), c(!1) }, children: jsx("a", { href: `#${et.id}`, children: et.title }) }, et.id)) }) })] })] }) }, Hero = () => jsxs("section", { id: "home", className: `flex md:flex-row flex-col ${styles$1.paddingY}`, children: [jsxs("div", { className: `flex-1 ${styles$1.flexStart} flex-col`, children: [jsx("div", { className: "flex flex-row items-center py-[6px] px-4 transparent-gradient rounded-[10px] mb-2", children: jsxs("p", { className: `${styles$1.paragraph} ml-2`, children: [jsx("span", { className: "text-white", children: "Buy" }), " And Sell ", " ", jsx("span", { className: "text-white", children: " Crypto " }), " Assets"] }) }), jsxs("div", { className: "flex flex-row justify-between items-center w-full relative", children: [jsxs("h1", { className: "flex-1 font-poppins font-semibold lg:text-[65px] sm:text-[55px] text-[37px] text-white sm:leading-[100.8px] leading-[75px]", children: ["The best trusted ", jsx("br", {}), jsx("span", { className: "primary_text_shade break-all", children: "cryptocurrency " }), jsx("br", {}), "Provider"] }), jsx("div", { className: "ss:flex z-10 hidden md:mr-4 mr-0 absolute right-[0] md:right-[-120px]", children: jsx(GetStarted, {}) })] }), jsx("p", { className: `${styles$1.paragraph} max-w-[80%] md:max-w-[80%] lg:max-w-[85%] mt-5`, children: "Invest now, you'll never regret it. Biteezy, Secured and easy to use. THe Most secured currency ever to start.." }), jsx(Button, { title: "Learn More", icon: jsx(AiOutlineArrowRight, {}) })] }), jsxs("div", { className: `flex-1 flex ${styles$1.flexEnd} relative`, children: [jsx("img", { src: bitcoin, alt: "bitocin", className: "h-[280px] ss:h-[450px] object-contain" }), jsx("div", { className: "hidden sm:flex absolute z-[0] w-[40%] h-[35%] top-0 pink__gradient" }), jsx("div", { className: "hidden sm:flex absolute z-[1] w-[80%] h-[80%] rounded-full white__gradient bottom-40" }), jsx("div", { className: "hidden sm:flex absolute z-[0] w-[50%] h-[50%] right-20 bottom-20 blue__gradient" })] })] }), Button = ({ title: e, icon: s, onclick: o }) => jsxs("button", { type: "button", onClick: o, className: `flex ${styles$1.flexCenter} py-4 px-8 my-8 font-poppins font-medium text-[16px] text-primary primary_gradient rounded-full outline-none ${styles$1}`, children: [e, " ", jsxs("span", { className: "ml-3", children: [" ", s, " "] })] }); function FaRocket(e) { return GenIcon({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M505.12019,19.09375c-1.18945-5.53125-6.65819-11-12.207-12.1875C460.716,0,435.507,0,410.40747,0,307.17523,0,245.26909,55.20312,199.05238,128H94.83772c-16.34763.01562-35.55658,11.875-42.88664,26.48438L2.51562,253.29688A28.4,28.4,0,0,0,0,264a24.00867,24.00867,0,0,0,24.00582,24H127.81618l-22.47457,22.46875c-11.36521,11.36133-12.99607,32.25781,0,45.25L156.24582,406.625c11.15623,11.1875,32.15619,13.15625,45.27726,0l22.47457-22.46875V488a24.00867,24.00867,0,0,0,24.00581,24,28.55934,28.55934,0,0,0,10.707-2.51562l98.72834-49.39063c14.62888-7.29687,26.50776-26.5,26.50776-42.85937V312.79688c72.59753-46.3125,128.03493-108.40626,128.03493-211.09376C512.07526,76.5,512.07526,51.29688,505.12019,19.09375ZM384.04033,168A40,40,0,1,1,424.05,128,40.02322,40.02322,0,0,1,384.04033,168Z" } }] })(e) } const GetStarted = () => jsx("div", { className: `${styles$1.flexCenter} w-[140px] h-[140px] rounded-full primary_gradient p-[2px] cursor-pointer`, children: jsxs("div", { className: `${styles$1.flexCenter} flex-col bg-primary w-[100%] h-[100%] rounded-full`, children: [jsx("div", { className: `${styles$1.flexStart} flex-row`, children: jsx("p", { className: "font-poppins font-medium text-[18px] leading-[23.4px]", children: jsxs("span", { className: "primary_text_shade flex", children: ["Get ", jsx(FaRocket, { className: "ml-2 primary_text_shade text-lg animate-pulse text-blue-200" })] }) }) }), jsx("p", { className: "font-poppins font-medium text-[18px] leading-[23.4px]", children: jsx("span", { className: "primary_text_shade", children: "Started" }) })] }) }); function commonjsRequire(e) { throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.') } var dist$1 = { exports: {} }; const require$$0 = getAugmentedNamespace(jsxRuntime); (function (e) { var s = require$$0.jsx, o = require$$0.jsxs; function c(xt) { return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? c = function (bt) { return typeof bt } : c = function (bt) { return bt && typeof Symbol == "function" && bt.constructor === Symbol && bt !== Symbol.prototype ? "symbol" : typeof bt }, c(xt) } function et(xt, Ct) { if (!(xt instanceof Ct)) throw new TypeError("Cannot call a class as a function") } function at(xt, Ct) { if (typeof Ct != "function" && Ct !== null) throw new TypeError("Super expression must either be null or a function"); xt.prototype = Object.create(Ct && Ct.prototype, { constructor: { value: xt, writable: !0, configurable: !0 } }), Ct && lt(xt, Ct) } function lt(xt, Ct) { return lt = Object.setPrototypeOf || function (Pt, Rt) { return Pt.__proto__ = Rt, Pt }, lt(xt, Ct) } function ft(xt) { var Ct = vt(); return function () { var Pt = wt(xt), Rt; if (Ct) { var Jn = wt(this).constructor; Rt = Reflect.construct(Pt, arguments, Jn) } else Rt = Pt.apply(this, arguments); return dt(this, Rt) } } function dt(xt, Ct) { return Ct && (c(Ct) === "object" || typeof Ct == "function") ? Ct : ht(xt) } function ht(xt) { if (xt === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return xt } function vt() { if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1; if (typeof Proxy == "function") return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], function () { })), !0 } catch { return !1 } } function wt(xt) { return wt = Object.setPrototypeOf ? Object.getPrototypeOf : function (bt) { return bt.__proto__ || Object.getPrototypeOf(bt) }, wt(xt) } function St(xt, Ct, bt) { return Ct in xt ? Object.defineProperty(xt, Ct, { value: bt, enumerable: !0, configurable: !0, writable: !0 }) : xt[Ct] = bt, xt } if (typeof commonjsRequire < "u") var _t = react.exports; else _t || console.warn("React not found - use a CDN or run in terminal: npm ls --depth=0"); var Nt = function (xt) { at(bt, xt); var Ct = ft(bt); function bt() { var Pt; et(this, bt); for (var Rt = arguments.length, Jn = new Array(Rt), er = 0; er < Rt; er++)Jn[er] = arguments[er]; return Pt = Ct.call.apply(Ct, [this].concat(Jn)), St(ht(Pt), "onMapClick", function (Zt) { Pt.props.selected === Zt ? Pt.props.onSelect(null) : Pt.props.onSelect(Zt) }), St(ht(Pt), "getClassname", function (Zt) { return Pt.props.selected !== null && c(Pt.props.selected) === "object" ? Pt.props.selected.indexOf(Zt) === -1 ? "map-unselected" : "map-selected" : Zt === Pt.props.selected ? "map-selected" : "map-unselected" }), St(ht(Pt), "render", function () { return s("div", { className: "row", children: o("svg", { className: "map-img", xmlns: "http://www.w3.org/2000/svg", width: "672", height: "315", viewBox: "0 0 672 315", id: "svg5249", children: [o("defs", { id: "defs5257", children: [s("linearGradient", { id: "linearGradient4299", children: s("stop", { offset: "0", id: "stop4301", stopColor: "#cc5252" }) }), s("linearGradient", { id: "linearGradient4293", children: s("stop", { offset: "0", id: "stop4295", stopColor: "#84297f" }) })] }), o("g", { id: "AF", className: Pt.getClassname("af"), onClick: Pt.onMapClick.bind(ht(Pt), "af"), children: [s("path", { id: "path4307", d: "M345.902 112.802c-.17.07-.465-.25-.712-.27-4.522-.397-8.758-1.617-12.802-3.765-3.034-1.612-4.46-.522-4.662 2.886-.083 1.41-1.59 2.89-2.388 2.6-2.33-.84-5.66-.743-6.844-2.497-1.98-2.928-4.745-3.15-7.454-3.954-2.822-.838-3.82-2.355-3.362-5.1.232-1.41-.062-3.027-.87-4.077-1.022-1.326-2.538-.395-3.773.174-2.42 1.114-5.057.88-7.43.463-3.982-.7-7.45.41-10.57 2.353-3.217 2.005-6.126 2.44-9.33.388-.89-.568-1.57-.542-2.092.522-.986 2.016-2.6 3.41-4.584 4.4-2.34 1.162-3.488 3.376-3.594 5.652-.13 2.84-1.84 4.387-3.778 5.472-2.85 1.593-4.95 3.8-6.516 6.475-1.57 2.686-3.01 5.426-4.79 7.998-.936 1.353-1.45 3.018-.583 4.844 1.364 2.873 1.865 5.848.457 8.94-1.026 2.25-3.17 4.5-.41 7.02.17.157-.84.53-.112.962-2.044 1.885.48 2.86 1.136 3.413 2.413 2.036 4.23 4.46 5.466 7.25.53 1.202 1.027 2.303 1.875 3.315 1.513 1.808 3.355 3.207 5.19 4.632 2.15 1.66 4.487 2.358 7.178 1.57 1.965-.573 4.045-1.78 5.958-1.218 2.726.802 5.014.213 7.458-.707 2.313-.868 4.68-1.602 7.055-2.278 2.103-.6 5.36.928 5.86 2.954.424 1.7.94 1.963 2.638 1.51 3.457-.927 6.375 1.536 6.468 5.097.045 1.752-.163 3.427-.74 5.1-.643 1.857-1.513 3.932.178 5.61 3.446 3.41 5.434 7.51 7.28 11.96.896 2.16-.156 4.12.832 5.864 1.913 3.39.45 6.11-1.116 9.128-2.437 4.693-3.19 9.58.055 14.384 2.876 4.262 4.066 9.067 4.505 14.142.152 1.773-.015 3.83 1.088 5.245 2.082 2.677 3.54 5.682 5.264 8.55.564.938.853 1.618.55 2.82-.747 2.93 1.544 5 4.478 4.35 2.745-.605 5.488-1.696 8.314-.373.563.263.974.07 1.46-.147 3.6-1.622 6.623-3.885 9.203-6.964 1.934-2.312 3.53-4.934 5.783-6.935.9-.8 1.245-1.22.97-2.485-.54-2.477.076-4.417 2.812-5.604 4.124-1.79 4.638-3.683 2.556-7.79-.642-1.263-1.128-2.546-.002-3.562 2.824-2.547 4.426-6.274 8.454-7.728 3.474-1.255 4.783-4.753 4.377-8.378-.44-3.88-.828-7.66-2.61-11.294-.963-1.958-1.395-4.338-.81-6.787 1.685-7.023 7.57-10.894 11.763-16.02 1.952-2.39 5.308-3.368 6.88-6.143 2.305-4.066 4.287-8.315 6.575-12.39 1.193-2.124 1.39-4.085.162-6.344-3.516 2.275-7.657 2.108-11.426 3.32-1.82.583-4.3-1.108-4.76-3.08-.65-2.768-2.467-4.555-4.49-6.396-1.663-1.508-4.207-2.326-4.675-4.952-.25-1.41-.9-2.558-1.822-3.618-1.9-2.177-3.655-4.407-3.25-7.61.06-.477-.496-1.06-.826-1.55-3.618-5.377-5.79-11.577-9.615-16.83-.366-.5-.496-.97.034-1.334" }), s("path", { id: "path5906", d: "M390.758 215.407c-1.126 4.07-4.206 6.355-7.395 8.04-3.08 1.623-4.565 3.03-3.67 6.426.538 2.044.475 3.746-.954 5.293-2.31 2.5-1.826 5.44-1.14 8.27.46 1.886 2.024 2.625 4.012 2.35 2.547-.35 4.203-1.945 4.528-4.27.878-6.33 3.857-11.94 5.758-17.912.96-3.024.438-5.497-1.14-8.197z" })] }), o("g", { id: "SA", className: Pt.getClassname("sa"), onClick: Pt.onMapClick.bind(ht(Pt), "sa"), children: [s("path", { id: "path5918", d: "M115.618 166.174c-.415 1.425.243 2.418.6 3.565 1.137 3.644.977 7.03-1.524 10.18-2.03 2.56-4.198 5.048-5.47 8.15-.393.966-.787 2.178.092 2.588 3.028 1.41.873 2.67.053 3.96-1.37 2.154-1.048 4.542 1 6.016 1.174.848 1.857 1.98 2.586 3.18 1.58 2.6 1.826 5.79 3.77 8.22 1.605 2.013 3.28 3.943 4.124 6.505.725 2.197 2.425 3.567 4.602 4.603 5.66 2.694 10.344 6.27 10.638 13.36.15 3.602-.243 7.18-.033 10.82.198 3.464.227 6.988.716 10.46.625 4.445 2.04 8.945.958 13.358-.95 3.9 1.106 7.085 1.628 10.576.352 2.36 3.356 3.75 4.09 6.826.866 3.615 1.584 4.13-1.22 6.74 1.314.826 2.84 1.408 3.365 3.066 1.238 3.9 3.232 7.28 6.362 10.034 1.42 1.25 5.01 1.734 6.428.405.427-.402.932-.71.423-1.495-1.376-2.128-.534-4.14.584-6.04 1.206-2.053 1.067-3.652-1.116-4.982-1.025-.625-2.42-2.097-1.822-2.843 1.68-2.098 1.874-4.722 3.084-7.057-1.285-.557-2.43-1.407-2.888-2.943-.145-.49-.527-.903-.074-1.424.555-.638 1.052-.168 1.63-.03.885.21 1.667 1.71 2.665.49.745-.912 1.322-1.992.48-3.305-.818-1.272.053-1.71 1.183-1.798.778-.06 1.59.107 2.342-.05 2.254-.46 4.63-1.172 5.095-3.717.39-2.127-1.12-3.816-2.623-5.265-.516-.497-1.858-.546-1.458-1.48.383-.906 1.49-.477 2.3-.208.736.247 1.513.444 2.173.833 2.03 1.192 3.83.246 4.808-1.202 3.157-4.665 5.83-9.626 7.665-14.997.438-1.285.54-2.54-.095-3.736-.59-1.11-.343-1.89.518-2.752 2.245-2.25 5.44-2.937 7.85-4.903.213-.174.723-.165 1.008-.042 2.866 1.232 4.393-.71 5.25-2.72 2.402-5.634 4.383-11.423 3.233-17.752-.203-1.113-.26-2.46.613-3.22 2.544-2.218 3.312-5.68 5.685-7.918 1.616-1.523 1.937-3.455 2.37-5.33.55-2.396-.897-4.25-3.3-4.924-2.624-.736-5.027-1.852-6.545-4.304-.174-.282-.47-.673-.727-.69-3.424-.2-6.822-2.28-10.27-.255-.964.568-1.528.082-1.33-.65.87-3.205-1.976-3.083-3.512-4.054-1.675-1.06-2.744.294-3.78 1.298-1.18 1.15-2.397 1.63-3.943.62.774-.364 1.553-.687 2.087-1.387.44-.58 1.382-.977.698-1.928-.6-.828-1.408-1.364-2.433-.913-.698.304-1.33.798-1.918 1.295-.663.56-1.23 1.228-1.864 1.825-.418.397-.845 1.084-1.514.552-.8-.628-.15-1.316.236-1.784.71-.86 1.557-1.586 2.48-2.265 1.01-.745 2.167-2.147 1.472-3.222-.894-1.387-1.017-2.896-1.56-4.314-1.174-3.07-5.613-6.326-8.444-5.77-3.636.712-6.402-.76-8.173-3.595-1.276-2.04-2.967-3.473-4.895-4.405-2.033-.98-3.938-2.6-6.434-2.435-3.293.22-6.36-.177-9.023-2.47-.862-.74-2.192-2.053-3.404-.793-.89.923-3.702 1.082-1.93 3.597.534.755-.227 1.43-.725 2.004-.283.327-.672.67-1.07.187-.432-.532-.912-1.15-.717-1.864.48-1.767.28-3.723 1.71-5.283-2.368-.584-2.823 2.05-4.29 2.204-3.052.317-4.325 2.25-5.64 4.628-.806 1.455-2.192 3.004-4.224.975" }), s("path", { id: "path5872", d: "M169.258 314.69c-2.768-.79-4.725-2.848-7.143-4.092-.854-.44-1.802-1.486-2.774-.485-.535.556-.99 1.625-.83 2.312.22.956 1.198 1.495 2.18 1.995 2.835 1.442 5.705.296 8.57.27z" }), s("path", { id: "path5842", d: "M178.366 306.535c-1.333-.773-2.788-.467-4.18-.606-.96-.1-1.134.7-1.27 1.21-.196.735.636.665 1.093.9 1.92.987 3.192.083 4.355-1.506z" })] }), o("g", { id: "EU", className: Pt.getClassname("eu"), onClick: Pt.onMapClick.bind(ht(Pt), "eu"), children: [s("path", { id: "path5896", d: "M314.54 12.017c-.95.52-2.082-.24-2.718.828 1.143.663 2.173 1.27 3.214 1.86.726.413 1.568.678 1.98-.274.474-1.097 1.535-1.59 2.175-2.51 1.29-1.85 2.49-1.655 3.312.56.157.425.237.99.616.713 1.317-.97 2.53.273 4.03.078-1.355-2.037-4.132-1.85-5.448-3.937 2.526.016 4.722 1.5 7.046.302.48-.248 1.064-.418 1.012-.996-.066-.715-.765-.55-1.246-.562-1.736-.038-3.628.388-5.175-.163-2.225-.794-2.97.183-3.69 2.165-.646-1.42-1.195-2.776-2.865-1.106-.43.43-1.75.282-2.516.002-1.715-.624-3.44-.287-5.16-.37-.56-.027-1.32-.193-1.46.67-.134.818.615 1.025 1.13 1.215 1.353.498 2.62 1.547 4.237.492.774-.507 1.17.304 1.528 1.035z" }), s("path", { id: "path5216", d: "M368.885 86.945c.68.07 1.6.203 3.463.162 1.22-.026 2.524-.132 3.695-.39 1.17-.258 2.21-.67 2.896-1.305.61-.567 1.063-1.253 1.395-2.017.332-.765.54-1.607.666-2.48.25-1.75.16-3.63.015-5.292-.056-.644-.233-1.282-.49-1.916-.26-.634-.6-1.263-.987-1.887-.778-1.247-1.743-2.473-2.608-3.675-.866-1.203-1.633-2.382-2.012-3.534-.19-.574-.282-1.142-.242-1.705.04-.562.21-1.12.552-1.668.262-.42.764-.658 1.37-.78.605-.12 1.314-.123 1.99-.073 1.352.1 2.574.41 2.574.41s.916.513 2.113 1.088c1.198.576 2.678 1.214 3.8 1.46.725.158 1.195.067 1.493-.197.3-.265.425-.702.463-1.243.077-1.08-.205-2.57-.184-3.88.02-1.23-.34-2.653-.66-4.372-.157-.86-.304-1.792-.39-2.812-.084-1.02-.105-2.127-.01-3.334.12-.414.06-1.166-.102-2.133-.163-.966-.427-2.145-.723-3.412-.59-2.533-1.304-5.414-1.542-7.633-.123-1.144.227-2.392.402-3.592.088-.6.13-1.188.05-1.746-.057-.384-.283-.728-.485-1.078-.08.023-.1.092-.252.064-3.3-.615-6.512 2.358-9.766.04-.39-.28-1.2-.102-1.774.038-1.847.45-3.572 1.125-5.2 2.212-1.44.96-3.622 2.236-4.66-.04-.83-1.816-1.71-1.054-2.675-1.136-.537 1.22 2.034 2.685-.544 3.492-1.764.552-4.196.022-4.63 2.895-.056.37-1.14.838-2.075.484-.77-.295-1.58-.937-2.6-.577.55.844 1.74.714 2 1.706-2.47 1.53-5.52.7-7.078-2.03-.58-1.014-1.148-1.92-2.287-2.34-.49-.18-1.15-.42-1.018-1.004.16-.69.906-.722 1.527-.674.6.045 1.192.195 1.79.235 2.32.157 4.35 1.685 6.798 1.348 1.31-.178 2.946-.323 3.172-1.578.235-1.28-1.458-1.405-2.488-1.76-1.635-.563-3.25-1.215-4.918-1.642-1.395-.356-2.816-1.2-4.278-.63-1.06.413-1.728.14-2.594-.443-4.967-3.332-10.502-3.06-16.03-2.203-1.575.24-2.997 1.624-4.558 1.782-4.802.484-7.253 4.187-9.8 7.315-2.51 3.08-5.278 5.313-8.98 6.46-3.05.944-4.05 2.317-3.585 5.218.764 4.768 2.865 5.867 6.91 3.373 1.187-.733 1.852-.695 2.564.31.643.91 1.33 1.824 1.745 2.838.28.68 1.187 1.643.06 2.287-1.15.66-2.37 1.885-3.704 1.36-1.243-.493.33-1.63.044-2.513-.102-.316-.07-.675-.104-1.043-3.082 1.48-3.65 2.46-2.332 5.406.842 1.88-.168 2.99-1.39 2.934-2.882-.13-4.55 1.467-6.44 3.15-1.63 1.456-4.06 2.196-5.293 3.873-2.366 3.217-6.22 2.734-9.172 4.383-.596.333-2.31-.804-2.614.482-.306 1.308 1.41 1.085 2.233 1.545.3.17.63.294.933.46 2.07 1.153 2.593 3.53 1.707 7.43-.512 2.258-2.19 2.33-4.022 2.333-2.44.004-4.78-.58-7.154-.996-1.744-.305-3.93.095-3.72 2.096.31 2.972-.8 5.55-1.085 8.312-.157 1.5-.846 4.13 1.26 4.483 2.41.406 4.063 1.542 5.79 3.283.703-1.97 2.14-2.125 3.81-2.09 2.645.05 6.444-2.163 6.577-4.237.275-4.202 3.554-5.62 6.264-7.623.44-.326 1.03-.166.97-1.145-.12-1.952 1.33-3.18 3.246-2.488 2.535.916 4.42-.198 6.265-1.408 2.59-1.7 3.394-1.665 4.724 1.192 1.074 2.304 3.113 4.37 4.93 4.997 3.827 1.32 6.6 2.745 6.303 7.487 1.095-.98 2.356-1.516 1.564-3.11-1.124-2.262.304-2.087 1.77-1.77.464.102.893.54 1.33-.016-.114-.53-.54-.672-.947-.815-4.473-1.582-7.53-5.046-10.79-8.21-.74-.725-1.588-1.844-.33-2.92 1.097-.944 1.622.12 2.525.59 2.636 1.38 4.57 3.92 7.393 4.782 3.024.924 4.338 2.77 4.61 5.737.213 2.35 1.616 3.74 3.886 4.25.726.164 1.9-.206 2.002.74.125 1.19-1.426.535-1.93 1.166.068.876.663 1.422 1.123 2.046 1.02 1.38 1.495 1.472 2.376-.342.928-1.915.12-3.122-.793-4.43-.9-1.285-.912-2.196.71-2.744 2.2-.743 4.28-1.707 6.803-1.015 1.093.297 2.66.022 3.87-1.1-2.237-.976-2.114-2.503-1.424-4.342 1.22-3.26 2.417-6.512 5.806-8.193 1.33-.658 3.584.975 3.535 2.475-.04 1.313 1.472 2.358 2.83 1.845.936-.352 1.8-.907 2.96-1.508-1.333-.265-2.706-.325-2.735-1.552-.018-.83 1.25-1.013 2.065-1.287 1.702-.576 3.195-1.704 5.048-1.944.057.687-.02 1.245-.264 1.934-1.455 4.02-1.392 4.038 2.486 6.19 1.057.587 2.137 1.146 3.133 1.827 1.086.74 2.357 1.76 2.088 3.044z" }), s("path", { id: "path6886", d: "M385.316 25.78c-1.236-.632-2.444-1.58-3.953-.43 1.243 1.145 2.547.888 3.862.548" }), s("path", { id: "path5898", d: "M283.92 52.29c-.8-.667-2.085-.028-2.218-1.31-.075-.732-.402-.546-.834-.344-1.246.578-2.165 2.204-1.772 2.82.692 1.075-.67 3.574 2.005 3.3 1.126-.116 1.243.633 1.458 1.405.2.727.878 1.87.03 2.073-2.02.476-2.228 2.374-3.29 3.46.58 1.223 2.895.085 2.74 1.622-.11 1.093-2.045.89-3.096 1.42-.28.14-.53.35-1.21.81 3.788-.542 7.028-1.343 10.337-1.74.692-.082 1.272-2.41 2.52-3.254-.25-.22-.56-.68-.736-.632-2.476.65-2.51-1.476-3.118-2.794-.66-1.436-1.29-3.172-2.684-3.664-2.69-.956-1.55-1.9-.13-3.17z" }), s("path", { id: "path5890", d: "M391.468 14.513c-1.184-.953-2.1-.57-3.038-.524-1.653.08-3.117 1.17-4.8.852-5.142-.97-7.895 2.407-10.448 5.912-.216.297-1.68 1.82-.366 2.283 2.025.71 3.94 2.29 6.397 1.56-2.326-2.385-2.277-3.196.2-5.7 1.862-1.88 4.287-2.475 6.737-2.99 1.72-.36 3.544-.312 5.318-1.395z" }), s("path", { id: "path5884", d: "M266.588 34.804c-.973-1.158-2.09-1.99-3.777-1.498-1.063.312-2.175 1.223-3.207.735-2.296-1.082-3.937.786-5.92 1.03-1.027.127-1.097 1.13-1.008 2.026 2.086-.83 3.2 1.882 4.86 1.543 2.83-.58 5.826-.907 8.21-2.87.328-.27.75-.41.844-.965z" }), s("path", { id: "path5878", d: "M275.71 56.592c-2.365-.143-3.486 1.895-5.354 2.25-.102.02-.255.543-.17.634 1.18 1.263.038 2.246-.43 3.246-.325.698-.06 1.16.243 1.68.497.862 1.06.216 1.54.004 2.28-1.005 5.355-1.204 5.095-4.88-.01-.152.094-.342.2-.47 1.644-2.038.552-2.496-1.126-2.464z" }), s("path", { id: "path5834", d: "M305.46 91.166c-.052-.83.15-1.928-1.02-2.024-.794-.066-1.616.716-1.398 1.473.27.928.06 2.515 1.462 2.573 1.173.048.91-1.197.956-2.022z" }), s("path", { id: "path5832", d: "M311.93 96.563c1.167.615 2.14 1.154 3.14 1.65.617.304 1.155.653 1.47-.5.28-1.014.194-1.256-.874-1.53-1.24-.322-2.336-.422-3.735.38z" }), s("path", { id: "path5828", d: "M333.694 102.073c2.108 1.235 3.815 2.096 6.053.893-1.875-1.272-3.754-.968-6.053-.893z" })] }), o("g", { id: "AS", className: Pt.getClassname("as"), onClick: Pt.onMapClick.bind(ht(Pt), "as"), children: [s("path", { id: "path5928", d: "M563.326 80.01l-.22-.625c-.09.068-.266.186-.26.196.11.183.242.35.37.524-.166 1.17 1.466 1.9.63 3.34-1.11 1.913-.78 2.61 1.426 4.105.115-.878-.667-2.7 1.068-2.09 2.394.834 4.014.275 5.508-1.74-2.823-1.23-5.67-2.47-8.522-3.71z" }), s("path", { id: "path5910", d: "M542.156 183.11c-.19-.267-.387-.548-.59-.828-1.89-2.548-2.482-4.92.117-7.568 1.364-1.39-.698-2.145-1.426-3.027-.616-.745-1.607-2.077-2.503-.96-1.676 2.082-4.86 2.994-5.785 4.7-1.645 3.03-5.388 3.535-6.48 6.715-.215.636-.76.403-1.307.27-1.883-.458-2.908.484-2.506 2.35.378 1.76.94 3.484 1.395 5.232.572 2.192 1.99 2.974 4.212 3.455 2.027.434 4.12-.64 5.984.535 2.024 1.278 2.94.02 3.79-1.545 1.598-2.95 1.838-6.638 4.786-8.86.127-.098.19-.283.31-.47z" }), s("path", { id: "path5902", d: "M491.98 172.796c.398 2.03 1.385 3.21 2.56 4.267 3.85 3.465 6.463 7.942 8.86 12.337 1.682 3.08 3.66 5.798 5.82 8.45.727.89 1.793 1.683 3.138 1.295 1.308-.376 2.11-1.49 2.212-2.664.12-1.37-.138-2.742-1.28-3.946-1.713-1.8-3.424-3.735-4.54-5.917-.625-1.216-.985-2.357-2.204-3.182-2.054-1.395-4.514-2.516-5.798-4.643-1.996-3.313-4.97-4.798-8.768-5.994z" }), s("path", { id: "path5900", d: "M564.96 106.815c1.06-2.906 1.06-2.906 3.614-3.267 3.424-.483 4.355-2.182 3.166-5.536-.305-.864-.865-1.733-.613-2.738.59-2.353-.683-3.89-2.345-5.194-.687-.538-1.475-1.513-2.45-.69-.94.798.168 1.527.37 2.288.378 1.44 2.108 2.516 1.37 4.222-1.31 3.03-4.095 5.588-6.805 5.695-2.86.113-3.99 1.95-6.315 2.838 3.374 1.746 7.63-3.202 10.007 2.382z" }), s("path", { id: "path5892", d: "M551.677 188.043c-1.16.266-2.35.444-3.475.818-1.423.475-1.982-.65-2.392-1.433-.483-.926.178-1.916 1.096-2.294 1.334-.546 2.673-1 4.226-.25 2.86 1.383 3.984.772 5.068-2.998-2.152 2.17-4.34 1.827-6.54 1.518-2.95-.415-4.083.224-4.834 3.006-.616 2.28-.284 4.83-2.067 6.774-.433.468-.01 1.073.267 1.417.712.877 1.137 1.678.498 2.805-.262.466-.004 1.017.475 1.36.545.396.968-.002 1.42-.222.595-.287.606-.772.463-1.314-.196-.75-.31-1.528-.607-2.236-.54-1.29.493-1.87 1.203-2.24 1.08-.568 1.225.716 1.407 1.285.444 1.403 1.048 2.45 2.824 2.57-.062-1.098.23-2.063-.367-2.93-1.632-2.38-1.192-4.17 1.333-5.636z" }), s("path", { id: "path5886", d: "M534.297 205.555c-2.236-1.525-5.075-1.93-7.21-3.665-.525-.43-1.14.04-1.72.14-1.797.31-3.508.846-5.346-.438-1.17-.815-2.86-1.293-4.44-.81-.684.21-1.707.4-1.685 1.35.02.783.952.83 1.557 1.098 2.008.892 4.392.2 6.157.822 3.644 1.286 7.457 1.093 11.06 2.17.626.187 1.207.172 1.628-.667z" }), s("path", { id: "path5880", d: "M552.243 155.018c-.677-2.027-.897-2.283-1.863-2.354-3.69-.264-4.7-1.772-3.36-5.117.87-2.174-.4-3.637-1.77-4.868-1.085-.977-1.708-.1-1.814 1.06-.095 1.023-.018 2.026-.47 3.04-.947 2.13 3 7.81 5.323 7.787.08 0 .166-.04.24-.08 1.26-.773 2.307.144 3.712.53z" }), s("path", { id: "path5874", d: "M549.998 168.35c2.586-1.304 3.528.042 3.995 2.223.105.486.436.94.735 1.36.482.673 1.063.32 1.612.067.32-.148 1.036.01.728-.68-1.413-3.17.93-1.37 1.963-1.4-.05-2.603-1.276-4.78-2.306-7.018-1.343 3.1-1.678 3.326-5.037 3.343-1.227.007-1.535.806-1.688 2.106z" }), s("path", { id: "path5866", d: "M560.677 70.273c-2.185-2.732-4.12-4.07-6.555-4.448 2.496 2.9 3.98 6.103 5.615 9.23.574 1.095 1.47 2.347 3.246 1.634-.624-2.01-2.407-2.874-3.484-4.31-.894-1.185-1.173-2.19 1.176-2.108z" }), s("path", { id: "path5864", d: "M458.767 163.702c-1.307 2.007-.894 3.82-.45 5.68.243 1.013.048 2.223 1.74 1.696 1.295-.405 2.034-.916 1.61-2.573-.475-1.87-1.852-3.046-2.9-4.803z" }), s("path", { id: "path5856", d: "M542.205 126.675c-1.378.634-1.965 2.03-2.204 3.285-.206 1.078.454 2.31 1.65 2.92.39.2.633.062.72-.38.32-1.622 1.426-3.146.59-4.92-.176-.372-.14-.867-.754-.905z" }), s("path", { id: "path5848", d: "M560.382 206.897c-4.303-1.72-6.326-.855-8.423 3.335 2.827-1.02 4.65-3.57 8.42-3.335z" }), s("path", { id: "path5844", d: "M556.83 111.988c1.587-2.33 1.214-3.86-.99-5.163-.475-.28-.874-.967-1.446-.108-.408.62-.304 1.11.248 1.546 1.117.886 1.613 2.16 2.19 3.725z" }), s("path", { id: "path5840", d: "M521.392 139.15c-1.76-.195-3.2-.105-3.945 1.44-.403.836.396 1.74 1.045 1.798 2.148.19 1.972-1.87 2.9-3.24z" }), s("path", { id: "path5838", d: "M543.214 159.992c-1.89 1.585-3.346 3.248-4.48 5.468 2.805-.74 4.462-2.755 4.48-5.468z" }), s("path", { id: "path5836", d: "M564.156 180.526c-1.55-.513-1.775.56-2.22 1.34-.442.774.563 1.596-.16 2.418-.473.533-.537 1.248.212 1.76.35.238.738.607 1.086.127.383-.53.805-1.075.378-1.86-.74-1.353-.78-2.68.704-3.783z" }), s("path", { id: "path5826", d: "M549.81 206.694c-.846-1.096-2.04-.703-2.944-1.183-.642-.34-1.528-.247-1.545.644-.01.64.7 1.25 1.457 1.176.995-.1 1.973-.405 3.033-.636z" }), s("path", { id: "path5824", d: "M549.676 60.696c1.136 1.65 1.652 3.168 3.625 3.76-.486-1.984-1.24-3.277-3.623-3.76z" }), s("path", { id: "path5822", d: "M541.805 206.455c-1.587-.842-2.855-.805-4.13-.23-.072.036-.083.494.027.605 1.09 1.09 2.22.068 3.34.015.15-.007.29-.143.763-.39z" }), s("path", { id: "path5820", d: "M561.594 106.698c.065-.657-.212-1.044-.69-.966-.713.113-1.655.177-1.634 1.195.01.422.25 1.156.834 1.138.86-.027 1.273-.727 1.49-1.367z" }), s("path", { id: "path5816", d: "M553.543 156.906c1.16 2.464 1.35 2.62 3.134 2.682-.682-1.18-1.24-2.477-3.134-2.682z" }), s("path", { id: "path5814", d: "M562.766 193.17c1.39 1.234 2.67 1.57 4.2.232-1.4.002-2.605-1.12-4.2-.233z" }), s("path", { id: "path5920", d: "M385.225 25.898c-.124.64.724 1.848.162 2.01.202.35.428.694.484 1.078.084.558.04 1.147-.047 1.746-.175 1.2-.525 2.448-.402 3.592.24 2.22.95 5.1 1.544 7.633.296 1.267.56 2.446.723 3.412.162.965.22 1.717.1 2.13-.093 1.208-.072 2.315.013 3.335.084 1.02.23 1.953.39 2.812.317 1.72.677 3.142.658 4.372-.02 1.31.26 2.8.185 3.88-.038.54-.164.977-.463 1.242-.298.264-.768.355-1.492.197-1.123-.247-2.603-.885-3.8-1.46-1.198-.575-2.114-1.088-2.114-1.088s-1.222-.31-2.574-.41c-.676-.05-1.385-.047-1.99.074-.606.12-1.108.358-1.37.78-.34.548-.512 1.105-.552 1.667-.04.563.052 1.13.242 1.707.38 1.153 1.146 2.332 2.012 3.535.865 1.202 1.83 2.428 2.607 3.675.386.624.726 1.253.984 1.887.258.634.435 1.272.49 1.916.145 1.662.236 3.543-.013 5.29-.124.875-.333 1.717-.665 2.482-.332.764-.785 1.45-1.397 2.017-.687.636-1.726 1.047-2.897 1.305-1.17.258-2.475.364-3.694.39-1.863.04-2.782-.09-3.463-.162 0 .004.005.006.004.01-.288 1.317-1.29 2.3-3.03 2.727-2.568.63-4.545-.373-6.678-1.258-3.32-1.38-6.64-2.707-9.964.017-.258.213-.67.478-.93.41-3.65-.94-5.565 3.5-9.09 2.92-.02-.004-.09.293-.17.555 1.28.684 1.794 1.738 2.033 3.274.51 3.235 3.71 4.755 6.774 3.5.68-.28 1.555-.484 2.014-.113 2.433 1.974 4.683 1.347 7.17.047 1.24-.648 3.007-.136 2.816 1.565-.365 3.26-1.194 6.47-1.928 9.682-.24 1.042-.616 2.156-2.002 2.294-3.325.332-6.694-1.112-10.006.23l7.518 3.178c.61-.42.887.245 1.252.54 1.032.84 1.23 2.51 2.78 2.86.476-.813-.295-2.34 1.003-2.413.968-.054.966 1.383 1.114 2.123.396 1.947 1.254 3.528 2.608 4.967 2.068 2.198 4.323 4.65 5.328 7.22 1.624 4.137 3.544 7.898 6.455 11.173 2.38 2.68 3.17 5.825 3.743 9.29.637 3.87 2.84 4.637 6.55 2.96 2.368-1.067 4.684-2.25 7.085-3.228 2.35-.958 4.55-1.956 5.982-4.262.687-1.105 2.083-1.69 3.348-1.815 2.515-.25 3.98-1.867 5.443-3.587 1.9-2.23 2.743-5.21 5.148-7.106 1.145-.904.664-1.922-.332-2.566-1.665-1.078-2.975-2.646-4.9-3.367-1.36-.51-2.04-1.592-1.78-3.06.118-.675.02-1.13-.668-1.584-.658 1.38-1.776 2.342-2.816 3.37-2.054 2.032-4.58 2.46-6.317-1.41-.327-.74-.637-1.536-1.53-.276-.843 1.19-2.03.905-2.35-.367-.714-2.86-2.37-5.118-3.982-7.47-.773-1.128.028-2.398.746-3.32.73-.94 1.673-.285 2.58.054 1.614.602 1.98 2.098 2.643 3.37 1.616 3.1 6.6 5.365 9.837 4.2 1.39-.5 2.358-.387 3.158.77 2.424 3.503 5.88 3.574 9.596 3.047 1.357-.192 2.767-.285 4.13.187 1.194.42 2.374.388 3.517-.234 2.054-1.125 3.765-.036 4.635 1.484 1.082 1.888 3.202 2.316 4.37 3.93.59.813 1.86-.598 2.296.47.53 1.293-.896 1.145-1.47 1.636-.065.058 0 .313.056.46.533 1.467 1.69 2.206 3.14 2.376 1.278.15 2.497-.04 2.315-1.857-.06-.616.31-1.004.878-1.078.48-.065.822.305.95.732.25.817.757 1.747.567 2.48-.907 3.56.58 6.578 1.903 9.65 2.557 5.936 5.735 11.606 7.6 17.843.516 1.716 2.717 2.268 3.785 1.04 3.468-3.993 3.9-8.802 3.318-13.716-.153-1.313-.217-2.34.856-2.883 3.004-1.516 4.533-4.562 7.07-6.6 1.603-1.286 2.68-3.275 4.796-4.08.223-.082.48-.588.422-.83-.634-2.815 1.568-2.79 3.236-3.248 1.16-.317 2.475-.28 3.506-.81 1.963-1.01 2.948-.153 3.61 1.512.74 1.847 2.07 2.928 3.71 4.065 2.214 1.533 3.297 4.22 3.54 6.875.105 1.122.05 1.927 1.046 2.553 1.247.787 1.694-.382 2.336-.956 1.806-1.62 2.645-1.42 3.39.885.64 1.967.937 4.137 1.98 5.857 1.387 2.29 1.253 4.346.913 6.865-.256 1.89-1.86 4.557.906 6.127 2.282 1.3 3.402 3.164 3.895 5.753.747 3.93 2.604 7.268 6.34 9.246.71.376 1.942.87 1.677-.208-.828-3.358-1.01-7.068-3.862-9.637-2.06-1.856-4.11-3.482-5.607-6.127-1.623-2.862-1.647-5.167-.84-7.956.15-.517-.124-1.182-.278-1.757-.212-.79-.39-1.593.37-2.137.83-.595 1.555.083 2.07.545 2.16 1.94 4.98 3.16 6.46 5.86.253.462.42 1.234 1.316.823 2.608-1.19 2.172.444 1.774 1.963-.14.537-.246 1.045.205 1.44.72.636 1.214-.16 1.496-.493 1.616-1.906 3.54-3.34 5.708-4.587.826-.475 1.442-1.83 1.254-3.01-.698-4.336-1.99-8.423-5.71-11.214-1.2-.904-2.17-1.942-2.974-3.205-1.615-2.53-.98-5.002 1.79-6.662 2.934-1.756 4.307-1.374 6.048 1.838 1.805-2.503 4.038-3.71 7.242-3.987 2.495-.216 5.294-1.098 7.29-3.028 3.85-3.717 4.15-8.947 5.548-13.684.66-2.23-3.455-1.347-2.5-2.48 1.924-2.27-.048-2.675-1.076-3.42-1.013-.733-1.898-1.45-2.422-2.606-.674-1.484-1.24-3.023-3.03-3.67-.868-.314-.668-1.136-.522-1.998.408-2.442 2.923-2.74 4.26-4.358-1.388-.785-2.825-1.39-4.216-1.08-2.208.494-5.145-.246-6.49-1.947-.538-.68-.725-1.374.115-1.687 1.574-.584 2.377-1.91 3.424-3.034 1.532-1.645 2.61-1.396 3.153.8.516 2.092 1.163 2.884 3.246 1.264 1.833-1.428 4.823.084 4.79 2.346-.02 1.104.397 1.414 1.256 1.508 1.19.13 2.04.79 2.943 1.502 1.633 1.284 1.94 3.255 2.7 4.96.717 1.597 1.503 1.777 2.84.862 1.205-.82 3.35-.795 2.03-3.412-1.533-3.032-4.41-4.25-6.893-6.04-1.26-.908-2.098-1.743-.024-2.733 1.25-.596 2.036-1.262 1.086-3.01-.836-1.53 1.093-2.682 1.61-4.084.4-1.098 1.62-.152 2.28.116 1.12.45 2.067.126 2.57-.585 1.704-2.406 2.762-5.11 2.957-8.1.277-4.202-.272-8.112-3.89-10.93-.062-.05-.095-.148-.125-.228-.935-2.668-3.448-3.76-5.416-5.388-.548-.454-1.252-.676-1.938-.214-1.886 1.274-3.632.33-5.372-.35-1.827-.712-3.55-1.452-1.607-3.87.54-.674.522-1.798.757-2.716.96-3.755 3.834-5.518 7.662-4.576.96.238 1.942.492 2.81.156 2.57-1.005 4.93-.826 7.432.402 1.73.853 3.043-.33 2.94-2.28-.165-3.046 1.048-3.994 4.028-3.337 1.12.246 2.13.572 3.103 1.208 1.238.81 2.173.68 1.953-1.145-.182-1.523 1.016-1.992 1.86-1.568 1.393.7 2.768 2.37 2.132 3.742-.963 2.082-.702 4.46-1.965 6.38-.53.812-.387 1.552.065 2.403 2.632 4.97 7.956 7.337 11.228 11.688.496.66 1.235.257 1.897-.063 1.065-.514.424-1.145.174-1.71-.29-.644-.174-1.428-.373-1.936-.62-1.58.703-3.09.273-4.25-1.013-2.733-2.115-5.56-5.613-6.42-1.77-.434-2.815-3.69-1.735-3.968 2.733-.708 5.11-3.476 8.34-1.703 1.345.737 2.242-.18 2.756-1.068 1.33-2.305 3.108-3.375 5.768-2.828.56.117 1.153-.097 1.32-.572.242-.68-.527-.822-.938-.988-2.16-.875-4.37-1.618-6.503-2.547-.654-.285-2.145-.04-1.76-1.27.3-.958 1.436-.607 2.277-.252.298.127.65.12.946.168.502-.998-1.464-1.267-.523-2.232.722-.74 1.463-.054 2.172.14 2.664.735 5.344 1.43 7.967 2.287 1.306.426 2.44.584 3.586-.42-.318-.258-.6-.45-.84-.69-2.054-2.06-4.07-4.14-7.393-2.38-.66.35-1.34-.27-1.892-.63-2.166-1.403-4.616-2.003-7.094-2.215-1.944-.165-3.666-.803-5.483-1.368-5.93-1.843-12.09-2.338-18.248-2.963-.273 1.083 1.323 1.397.677 2.188-.8.977-1.534-.137-2.29-.35-2.832-.81-5.752-1.73-8.65-1.11-3.606.773-6.837.26-10.005-1.425-.833-.443-1.66-1.006-2.692-.712-4.31 1.232-8.586-.677-12.895-.163-.374.046-.832-.252-1.192-.48-3.136-1.975-6.808-1.798-10.246-2.536-1.665-.358-3.39-.91-5.123-.497-.677.16-1.653.095-1.94.92-.77 2.216-1.53 2.62-3.698 2.366-1.605-.19-3.448-1.335-4.766-.48-3.562 2.313-6.026.126-8.62-1.618-2.065-1.39-4.188-2.34-6.735-2.314-4.388.042-8.843 1.817-13.166-.416-.19-.098-.528-.01-.754.09-2.097.937-4.144.74-6.215-.14-1.392-.592-2.815-.35-4.273-.032-1.48.322-3.355 1.91-4.34.273-.42-.7 2.097-1.813 3.44-2.495 1.33-.674 1.542-1.21.074-2.054-2.772-1.593-5.71-1.795-8.73-1.18-1.434.293-2.56.08-3.917-.59-2.42-1.194-5.013-2.21-7.643-2.762-4.484-.942-9.08-1.285-13.393-3.068-.67-.276-1.423-.523-2.166-.52-.742.004-1.476.26-2.104.99-.237.276-.883.445-.568.977.146.246.576.488.853.46 3.933-.36 7.64 1.715 11.575 1.065 1.706-.28 2.228.512 2.01 2.41 1.655-1.707 3.35-1.34 4.965-1.314.86.014 1.21.634.52 1.127-1.584 1.132-2.717 3.048-5.36 2.268-3.537-1.046-6.932.757-10.4 1.242-.57.077-1.034.274-.698 1.006 1.035 2.25-1.146 2.175-1.9 1.973-2.662-.71-4.418.554-6.3 2.045-1.45 1.15-3.017 2.365-5.074 2.04-.69-.107-1.47-.52-1.916.124-.528.76.197 1.48.557 2.135.434.795 1.272 1.158 2.056 1.53 1.462.693 2.4 1.806 2.25 3.44-.16 1.73-1.405 2.646-2.97 3.214-.62.227-1.198.397-1.66-.16-.48-.584.124-.97.43-1.3 1.53-1.663.954-2.996-.43-4.42-.89-.918-1.393-2.207-2.286-3.12-1.02-1.05-1.46-2.574-2.89-3.28-1.652-.817-4.563-.208-5.224 1.474-.725 1.848.496 3.007 2.11 3.767.63.297 1.234.634 1.853.948.61.31 1.487.594 1.017 1.455-.398.736-1.076 1.212-2.14.706-3.86-1.827-8.073-2.306-12.192-3.136" }), s("path", { id: "path5810", d: "M355.887 101.243c-.717.492-.965.725-1.26.85-.454.193-.935.326-1.414.45-.946.25-.877.956-.203 1.133 1.005.262 1.867-.447 2.524-1.232.138-.164.14-.443.353-1.2z" })] }), o("g", { id: "NA", className: Pt.getClassname("na"), onClick: Pt.onMapClick.bind(ht(Pt), "na"), children: [s("path", { id: "path5926", d: "M181.233 66.485c-2.833 1.613-4.37 4.582-7.332 6.61 3.753.416 6.997 1.23 10.343.204 1.626-.5 1.465-1.2.786-2.4-.475-.847-1.305-.918-1.96-1.074-1.91-.454-2.29-1.542-1.744-3.23.208-.073.418-.148.626-.22-.067-.092-.186-.267-.194-.26-.182.11-.35.24-.523.368z" }), s("path", { id: "path5924", d: "M174.493 9.605c-.5-.607-1.072-.64-1.925-.117.747.093 1.288.163 1.83.23-.012.945-.56 1.23-1.42 1.52-2.127.72-4.235.51-6.382.065 2.207 1.568 2.75 1.805 4.56 1.238 1.634-.51 3.036-.272 4.474.533.703.393 1.305.72 2.343.205 6.22-3.09 12.53-5.937 19.554-6.832 3.82-.49 6.97-2.796 10.383-4.415-10.137 1.13-20.33.96-30.36 2.765 2.818-.336 5.516 1.285 8.354.403.72-.225 1.527-.453 1.755.39.245.905-.82.97-1.37 1.213-.527.234-1.186.228-1.785.21-2.066-.052-4.136.21-6.19-.435-.888-.28-2.72.206-2.224 1.002 1.73 2.777-.44 1.883-1.6 2.03z" }), s("path", { id: "path5916", d: "M115.952 165.48c-1.38-2.408-3.415-2.033-5.458-1.218-3.344 1.33-7.49-2.097-6.936-5.733.39-2.548.87-5.08 1.322-7.615.258-1.44-.303-2.025-1.724-2.59-2.418-.96-4.624.173-6.916.216-2.364.044-2.258-.8-1.527-2.41 1.353-2.977 2.606-6.003 4.04-8.942.876-1.794-.184-2.366-1.48-2.235-2.222.228-4.53.187-5.47 3.25-1.116 3.657-4.785 4.01-7.88 4.37-2.426.286-4.375-1.48-5.164-3.66-1.145-3.165-2.646-6.405-.89-9.944.76-1.525 1.32-3.213 1.62-4.89.574-3.148 1.98-5.455 5.185-6.426.57-.17 1.144-.467 1.604-.843 2.627-2.152 5.257-3.027 8.53-1.05.78.474 2.514 1.89 3.78-.193 1.47-2.414 3.327-2.718 6.13-1.808 1.46.474 2.737 1.69 4.65.916 1.2-.488 3.39 2.204 2.864 3.54-.97 2.456.317 4.407 1.125 6.426.51 1.274 1.343 1.64 2.317.016 1.545-2.567.247-5.048.018-7.52-.195-2.144-.364-4.07 1.132-5.873 2.25-2.718 5.12-4.602 8.223-6.067 3.72-1.76 5.165-3.715 5.088-7.787-.025-1.326.387-1.667 2.143-1.612.4.014.32-.205.445-.383 2.508-3.644 5.88-6.108 10.07-7.547 1.555-.534 3.525-.71 4.075-2.71.412-1.498 1.39-2.266 2.72-2.832 1.907-.814 3.757-1.772 5.687-2.528 1.758-.69 3.58-1.226 5.397-1.754.6-.174 1.372-.02 1.48.685.09.564-.594.69-1.1.875-.887.326-1.76.73-2.582 1.2-.403.232-1.078.6-.82 1.124.277.556.946.656 1.576.284 2.39-1.427 5.084-2.114 7.664-3.077.79-.295 1.453-.783 1.934-1.508-.882-.405-1.553.233-2.302.3-1.865.173-3.31-.5-4.4-2.12-1.16-1.724-.018-2.383 1.118-3.31.565-.463 1.144-1.27.812-2.24-2.286-.35-4.34.164-6.3 1.217-.917.492-1.872.91-2.796 1.385-.455.234-.838.212-1.11-.225-.288-.457-.083-.914.314-1.11 4.305-2.134 8.465-5.182 13.55-4.39 5.54.86 10.095-1.367 14.7-3.682 1.25-.63 2.75-1.738 1.914-3.388-.877-1.73-2.623-1.744-4.318-.982-.238.107-.493.182-.716.314-.52.312-1.013.337-1.328-.235-.283-.513.19-.865.512-1.032 1.247-.653.667-1.384.347-2.312-.395-1.144-1.73-1.866-1.244-3.453.562-1.84-.278-3.705-.44-5.56-.136-1.538-1.12-.718-1.59-.32-1.4 1.188-2.905 2.165-4.54 2.98-.875.434-1.63.958-2.487-.092-.708-.863-1.763-1.487-.794-2.842.907-1.268.347-2.305-.8-3.062-1.006-.667-2.012-1.425-3.134-1.806-4.798-1.63-6.515-.92-8.947 3.595-.52.962-1.198 1.64-2.137 2.175-.884.503-1.488 1.34-1.108 2.4 1.093 3.044-1.005 4.72-3.025 5.74-3.306 1.67-6.222 3.372-6.81 7.41-.034.244-.163.53-.343.69-1.037.927-2.205 1.94-3.62 1.61-1.162-.267-1.556-1.72-1.706-2.734-.135-.91.415-1.995.865-2.903.876-1.758 1.152-3.003-1.46-3.278-1.52-.163-2.916-.858-4.26-1.747-1.256-.828-2.61-1.7-4.287-1.703-2.78-.006-3.258-2.717-4.164-4.35-.683-1.234.994-2.984 2.44-3.854 2.88-1.737 5.672-3.652 8.906-4.725.61-.2 1.522-.067 1.404-1.12-.163-1.475.457-1.395 1.694-1.24 2.558.324 4.895-.687 7.424-1.6-.49-.544-.754-.78-.94-1.063-.287-.443-1.207-.684-.6-1.442.546-.68 1.154-.158 1.615.143 1.045.688 1.993.42 2.904-.17 1.23-.798 2.56-1.02 3.98-.9 3.216.272 5.988-.35 7.86-3.368.426-.684 1.553-1.185 1.15-2.048-.345-.742-1.406-.83-2.32-.868-1.203-.05-2.212.18-3 1.17-1.047 1.323-2.42 2.232-3.972 2.85-.654.262-1.325 1.077-2.08.183-.62-.736-.01-1.416.364-1.86.95-1.126.22-1.74-.665-1.633-2.984.357-2.755-1.16-1.99-3.075.206-.52.406-.956-.09-1.4-.542-.485-1.095-.396-1.684-.093-1.453.744-2.912 1.475-4.416 2.237 2.15 2.163 1.793 3.516-1.05 4.195-.863.207-1.707.403-2.367.957-1.448 1.217-2.845 1.815-4.373.15-.604-.66-1.497-.747-2.18-.455-2.127.91-4.057.1-6.056-.407-3.125-.795-5.895-.306-7.984 2.407-.658.86-1.34 1.23-1.823-.127-.666-1.866-1.77-2.265-3.648-1.557-.995.375-2.235.115-3.365.118-1.94.005-1.648-.852-.644-1.994-.84-.067-1.68.058-2.347-.222-3.303-1.386-6.587-2.676-10.26-1.477-.285.093-.725-.022-.993-.193-2.777-1.772-5.728-.727-8.49-.258-4.58.78-8.975 2.177-13.782 1.054-9.175-2.142-18.322-4.244-27.975-2.777-5.577.85-10.628 3.483-16.257 3.936-1.31.106-1.786 1.056-.495 2.08 1.49 1.177.69 1.732-.537 2.3-1.13.524-2.186.852-3.485.48-2.895-.838-5.31.376-7.998 1.988 2.402.966 4.34 1.967 6.504.536.553-.364 1.254-.337 1.58.323.337.673-.4.77-.77 1.08-1.34 1.118-2.673 2.058-4.58 2.15-1.87.093-3.745.518-5.57.99-1.314.34-3.41 1.174-3.087 2.256.936 3.144-1.37 3.857-3.2 5.107 1.416 1.05 2.682 1.927 4.306.795.46-.32 1.004-.504 1.37.044.514.774-.31 1.067-.716 1.39-.46.373-1.087.532-1.608.837C5.774 52.233 2.3 53.295-1.54 54.98c1.3 0 2.066.203 2.664-.03 6.262-2.432 12.82-4.353 18.633-7.605 4.615-2.58 10.05-.497 14.25-3.704.15-.112.62.25.956.308 5.086.884 9.933 2.386 14.386 5.11 1.465.897 2.083 2.02 1.936 3.62-.215 2.302.94 4.857-1.347 6.8-.49.416.04 1.13.274 1.688.194.45.578.927.063 1.418-1.653 1.57-.303 2.596.834 3.24 1.746.992 2.48 2.568 3.18 4.24.38.912-1.648 4.42-2.58 4.512-.404.043-.708-.21-.74-.546-.068-.66.166-1.32-.98-1.286-1.09.03-1.23.72-1.473 1.462-1.768 5.36-6.98 8.58-8.71 13.97-.072.224-.356.375-.533.566-1.54 1.646-2.095 5.028-1.128 7.077.177.38.223.7.266 1.12.327 3.294-.67 7.082 3.67 8.886 1.39.58 2.335 2.51 1.83 3.995-.89 2.603.277 4.523 1.295 6.61.394.81 1.146 1.532.464 2.615-.952 1.514-.23 2.52 1.114 3.407.9.596 2.156 1.24 1.815 2.59-.78 3.06 1.84 3.853 3.173 5.507-1.766-5.405-2.766-11.015-5.227-16.13-.747-1.55-.33-3.003 1.165-3.36 1.427-.343 2.338.644 2.644 2.408.92 5.272 3.722 9.697 6.81 13.967 2.114 2.92 4.563 5.813 2.85 9.846-.29.683-.2 1.15.3 1.615 1.454 1.347 2.647 2.962 4.552 3.824 3.627 1.643 7.214 3.38 10.78 5.146 1.02.504 1.89.48 2.95.114 3.85-1.33 4.905-.955 7.32 2.326 1.5 2.044 6.67 4.537 8.41 3.653 1.473-.748 1.513.014 1.87.917.93 2.357 2.08 4.884 3.508 6.66 2.21 2.748 5.567 4.708 9.172 5.803.91.274 1.543.723 1.632-.884.103-1.847 1.802-1.872 3.153-1.755.828.075 2.3.306 2.296.78" }), s("path", { id: "path5912", d: "M273.78 4.48c-.535-.026-.986-.153-1.378-.05-3.173.843-6.138.513-8.884-1.383-.258-.177-.68-.097-1.005-.2-6.163-2.004-12.413.126-18.644-.34-3.66-.275-7.42 1.393-11.174 1.642-3.31.215-6.53 1.16-10.006.396-5.284-1.16-10.554-.763-15.6 1.736-2.43 1.2-4.902 2.483-7.76 2.69-1.876.135-3.767.122-5.653.564-1.092.257-.913.75-1.163 1.444-.36.998.145 1.365.818 1.518 1.734.396 3.367.994 5.307.528 4.8-1.153 9.172 1.244 9.906 7.196.085.69.432.822.82 1.108 2.74 2.015 2.697 5.004-.12 6.902-.856.576-1.807 1.018-2.647 1.617-1.64 1.166-2.883 2.534-1.667 4.714.39.7.353 1.344-.1 1.945-.867 1.15-.4 2.287-.04 3.435.84 2.655 3.296 3.36 5.393 4.53 2.297 1.277 3.99.238 5.446-1.394.853-.956 1.456-2.135 2.162-3.22 2.315-3.555 5.194-6.08 9.76-6.365 1.627-.102 3.47-.29 4.938-1.315 3.373-2.347 6.476-4.62 11.23-4.024 3.098.388 6.457-1.3 9.717-2.06-1.25-1.398-1.27-1.476-2.246-1.246-.91.213-2.01.957-2.622-.003-.748-1.17.93-.812 1.215-1.345 1.07-2.02 1.086-2.1 3.023-.464 1.258 1.058 2.417 1.38 3.806.328-.993-1.81-2.97-2.094-4.42-3.135-.37-.263-.987-.586-.605-1.21.137-.22.594-.39.873-.354 5.527.71 8.2-3.324 11.247-6.735.143-.162.21-.446.213-.677.082-2.926 1.463-4.18 4.41-4.836 1.808-.398 4.075.193 5.447-1.936z" }), s("path", { id: "path5908", d: "M176.88 40.817c-.365-.3-.778-.5-.967-.828-.398-.696-2.09-.54-1.48-1.67.545-1.014 1.646-.364 2.563-.053.79.267 1.544 1.51 2.492.403.906-1.05.733-2.186.04-3.35-.35-.587-1.146-1.312-.167-2.01.715-.507 1.487-.85 2.383-.224.562.394 1.26.588 1.84.963 1.8 1.162 2.747-.015 3.5-1.34.9-1.59-.624-1.897-1.532-2.367-1.472-.766-2.97-1.835-2.555-3.49.527-2.088-.797-2.283-1.962-2.537-1.94-.415-3.66-.975-4.604-2.916-.288-.59-.817-.957-1.493-.494-2.075 1.423-3.616.113-5.087-1.07-1.31-1.047-2.494-1.468-4.262-.964-1.592.45-2.846 1.122-3.96 2.27-.345.357-.707 1.236-1.424.472-.616-.66.075-1.056.417-1.525.473-.653 1.45-.95 1.44-2.08-2.477.11-4.48 1.047-6.283 2.665-.895.802-2.47 1.516-1.842 2.688.585 1.095 2.296 1.862 3.676 1.3 2.15-.875 4.09.044 6.104.275.673.075 1.24.327 1.98.058 3.664-1.34 5.136-.724 7.183 2.776.734 1.255 1.377 2.616 2.903 3.162.478.17 1.097.366.975.993-.112.582-.772.573-1.262.743-.738.254-1.42.64-2.21.103-1.807-1.235-3.384-.14-4.26 1.087-1.143 1.6-2.382 1.52-3.83 1.108-1.697-.484-3.216-.45-4.536.854.815 1.298 1.883.722 2.783.403 2.623-.926 4.444-.546 5.945 2.174 1.394 2.527 5.03 3.447 7.495 2.416z" }), s("path", { id: "path5904", d: "M117.705 18.228c-6.614-3.958-11.746.023-17.03 3.194.808 1.675 1.84 1.718 3.538 1 2.026-.857 4.136-2.597 6.57-.75.338.256.85.374.726.87-.066.25-.48.445-.768.604-.455.252-1.18-.29-1.548.578 1.288 0 2.5-.01 3.714.003.684.007 1.668-.112 1.708.738.042.884-.933.813-1.613.818-1.604.012-3.21.005-5.468.005 4.47 2.767 8.422 4.118 12.84 1.727 1.015-.55 1.99-.876 3.2-.345 3.137 1.38 5.78.037 8.432-1.696-.796-1.178-3.904-1.127-1.824-3.64.44-.535 1.45-1.443.414-2.163-.794-.55-1.62.15-2.24.827-.413.446-.84.885-1.314 1.265-.633.512-1.31.303-1.342-.433-.09-2.037-1.02-1.67-2.05-.78-.687.59-1.235.19-1.903.107-1.974-.245-3.725-1.475-5.865-1.13.445-.917 1.405-.17 1.82-.797z" }), s("path", { id: "path5882", d: "M105.365 133.753c.857-.284 1.734-.514 2.562-.863.964-.405 1.816-.708 2.957-.38 3.08.88 3.103.796 7.09 5.32.095.104.336.16.48.123 2.528-.59 5.145 1.478 7.62-.277-2.385-2.636-10.515-6.354-13.885-6.477-2.614-.094-5.037.172-6.826 2.552z" }), s("path", { id: "path5876", d: "M174.648 15.067c-1.117-.953-2.286-.684-3.397-.74-3.34-.164-6.813 1.125-9.95-1.285-1.12-.86-2.253.423-3.24 1.025-.35.21-.628.915-.566 1.34.096.665.817.454 1.298.48 1.636.075 3.327.41 4.872.35 3.62-.146 7.544 1.93 10.986-1.17z" }), s("path", { id: "path5870", d: "M124.458 142.107c4.672.65 8.935 1.055 13.178-.793-2.463-2.608-5.536-2.38-8.644-2.182.91 4.545-2.784 1.804-4.534 2.975z" }), s("path", { id: "path5862", d: "M145.41 17.703c-3.242-.82-5.278 3.316-8.686 2.018 1.765.43 2.276 3.36 4.96 1.98 1.854-.955 3.424-1.794 3.727-3.996z" }), s("path", { id: "path5860", d: "M162.733 7.783c2.802.123 4.995 1.846 7.206-.304.51-.495 1.85-.42 1.53-1.376-.3-.888-1.447-1.295-2.403-1.112-2.068.404-4.117.95-6.335 2.79z" }), s("path", { id: "path5858", d: "M153.99 37.486c.07-.516-.256-.808-.547-1.12-1.803-1.95-4.668-1.945-6.513.044-.364.393-1.16.692-.74 1.422.36.623.99.532 1.6.284 1.637-.664 3.24-.833 4.824.216.985.653 1.06-.357 1.377-.846z" }), s("path", { id: "path5854", d: "M52.22 70.54c.113-1.048-2.633-4.082-3.64-3.866-.757.162-1.707.412-1.03 1.727.78 1.505 2.14 2.13 3.522 2.75.405.183 1.06.14 1.148-.61z" }), s("path", { id: "path5852", d: "M154.517 18.318c-2.084-1.03-5.58-.62-6.883.703-.28.285-.75.543-.428 1.048.122.19.524.446.6.393 1.93-1.38 4.644-.26 6.71-2.14z" }), s("path", { id: "path5830", d: "M139.343 26.585c-.525-.296-.804-.51-1.12-.62-1.415-.488-2.467.38-3.518 1.066-.306.2.105.585.33.805 1.194 1.16 1.985-.256 2.954-.495.394-.097.736-.4 1.352-.755z" }), s("path", { id: "path5818", d: "M116.688 142.047c1.697 1.355 1.697 1.355 3.773.653-1.215-.782-2.297-1.51-3.77-.653z" }), s("path", { id: "path5808", d: "M143.03 142.054c-.368-.47-.964-.39-1.527-.383-.548.01-1.19.215-1.162.75.038.704.744.816 1.38.783.65-.033 1.143-.27 1.312-1.148z" })] }), o("g", { id: "OC", className: Pt.getClassname("oc"), onClick: Pt.onMapClick.bind(ht(Pt), "oc"), children: [s("path", { id: "path5922", d: "M610.708 211.614c.172.126.34.26.523.37.01.007.13-.17.2-.258l-.623-.226c-.46-1.705-2.208-2.034-3.295-3.07-1.68-1.608-3.786-3.635-3.54-5.62.317-2.562-.706-3.446-2.328-4.708-3.884-3.022-8.545-4.387-12.83-6.534-3.37-1.687-5.854-1.676-8.62.578-.462.377-1.037.58-1.298 1.19-.503 1.158-1.074.737-1.73.096-.643-.632-1.07-1.378-1.33-2.202-1.307-4.2-2.23-4.577-6.12-2.304 1.053.553 2.037 1.08 3.027 1.59.912.464 1.798.676.42 1.897-1.092.97-.305 2.38.94 2.37 3.283-.023 5.667 1.99 8.368 3.24 3.533 1.637 3.98 3.92 1.485 6.636.308.17.658.536.902.475 2.053-.51 3.39.376 4.9 1.75 1.926 1.75 4.35 1.064 5.673-1.215.897-1.55 1.967-2.29 3.804-1.422 1.38.648 2.74 1.452 3.376 2.74 1.695 3.452 4.824 4.104 8.102 4.626z" }), s("path", { id: "path5914", d: "M592.347 212.718c-1.676 2.43-2.453 5.122-2.457 7.982-.006 3.14-1.982 5.24-4.06 6.847-1.767 1.366-2.935-1.346-4.49-2.004-1.08-.454-1.958-1.396-2.918-2.132-2.44-1.88-2.515-2.87-.924-5.604.38-.647 2.353-1.68.255-2.57-2.424-1.025-4.905-2.29-7.548-.388-.61.44-1.395.78-2.138.87-2.26.28-3.21 2.044-3.962 3.71-1.127 2.478-1.507 2.736-3.595 1.14-2.285-1.748-4.63-1.7-6.173.748-1.194 1.892-4.147 2.463-3.94 5.35.02.276-.532.43-.865.197-1.774-1.23-2.21.234-2.686 1.388-1.02 2.47-2.693 4.645-5.26 4.99-4.41.6-8.13 2.735-12.14 4.26-1.81.69-2.414 1.916-3.26 3.34-1.2 2.03.01 4.028-.254 6.067-.45 3.537-1.448 7.133-.29 10.78.97 3.06.118 5.71-2.35 7.803-.924.782-.376 1.512.292 1.857 1.262.657 2.492 1.344 4.14.71 2.96-1.14 5.92-2.315 9.157-2.606 1.604-.143 3.296.19 4.813-.79 2.807-1.8 5.988-2.915 9.225-3.215 3.582-.334 7.445-2.246 10.774 1.222 1.4 1.453 1.902 3.224 2.844 4.9 1.102-1.456 3.03-1.817 4.276-3.156.256-.275.86-.69 1.378-.13.493.537.197.984-.205 1.34-.818.725-.554 1.23-.27 2.266.414 1.504 1.616 2.935 1.132 4.65-.258.91-1.392 1.8.07 2.652 1.74 1.007 3.446 2.66 5.585 1.563 1.336-.685 2.163-.796 3.026.434.8 1.14 1.438.854 2.465.062 1.682-1.302 3.51-2.626 5.914-1.677.73.287 1.11-.235 1.412-.804 1.926-3.653 6.05-5.412 7.892-9.154.2-.403.81-.608 1.24-.89 5.444-3.58 8.532-8.59 9.14-15.088.186-1.985 1.023-4.063-.876-5.775-1.838-1.658-2.853-3.83-3.833-6.078-.955-2.2-1.692-4.64-3.733-6.162-1.716-1.277-1.858-2.765-1.342-4.688.656-2.435.15-4.96-1.388-6.782-1.402-1.66-2.373-3.34-2.843-5.39-.17-.75-.325-1.51-1.227-2.04z" }), s("path", { id: "path5894", d: "M613.547 295.613c.733.085 1.64-.095 2.505-.57 5.202-2.86 9.813-6.66 15.065-9.452.816-.43 1.155-1.26.443-2.395-.89-1.412-1.636-.475-2.192-.015-3.34 2.77-6.926 5.095-11.045 6.518-2.13.734-4.122 1.716-6.004 2.955-.804.526-1.974 1.013-1.68 2.03.33 1.155 1.663.89 2.906.93z" }), s("path", { id: "path5888", d: "M640.457 268.668c.056 1.076.002 1.865.153 2.614.73 3.616.495 4.213-2.614 6.003-.913.528-2.353 1.445-1.988 2.11 1.18 2.146-.315 3.026-1.733 4.145 2.273.347 11.038-5.828 11.682-7.96-2.444.634-4.858-1.664-4.232-4.24.296-1.22.275-1.972-1.268-2.672z" }), s("path", { id: "path5868", d: "M575.345 288.723c1.727-.734 3.34-1.59 4.624-2.88.564-.566 1.434-1.382 1.13-2.15-.45-1.13-1.456-.377-2.243-.153-.916.26-1.657-.41-2.505-.5-3.392-.355-.618 2.814-2.093 3.705-.66.4-.703 1.38.4 1.758.237.08.48.155.684.22z" }), s("path", { id: "path5850", d: "M633.99 230.644c-.344 3.255 2.323 6.848 5.894 8.17-2.182-2.37-4.14-4.91-5.894-8.17z" }), s("path", { id: "path5846", d: "M614.595 196.652c-1.6 2.38-4.126 2.97-6.725 3.58 2.963 1.975 5.975.485 6.725-3.58z" }), s("path", { id: "path5812", d: "M668.022 228.1c-1.566-.425-2.163-1.58-3.172-.844-.675.495-.14 1.192.218 1.532.983.94 1.52-.233 2.954-.688z" }), s("path", { id: "path5806", d: "M614.22 193.67c-.906-.638-1.63-1.175-2.652-.996.744.49 1.338 1.337 2.653.996z" }), s("path", { id: "path5804", d: "M616.436 196.223c-.057-.457-.22-.727-.62-.695-.092.01-.226.24-.24.38-.04.37.164.648.518.703.105.017.257-.284.342-.386z" }), s("path", { id: "path5253", d: "M568.205 268.9c.088-.32.183-.597.225-.88.008-.057-.18-.14-.28-.214-.145.276-.297.552-.426.837-.003.01.227.12.48.257z" })] })] }) }) }), Pt } return bt }(_t.Component), kt = function (xt) { at(bt, xt); var Ct = ft(bt); function bt() { var Pt; et(this, bt); for (var Rt = arguments.length, Jn = new Array(Rt), er = 0; er < Rt; er++)Jn[er] = arguments[er]; return Pt = Ct.call.apply(Ct, [this].concat(Jn)), St(ht(Pt), "state", { selected: [] }), St(ht(Pt), "onMapClick", function (Zt) { Pt.setState(function () { if (this.props.multiple) { var lr = this.state.selected.indexOf(Zt); return lr === -1 ? this.state.selected.push(Zt) : this.state.selected.splice(lr, 1) } else return this.state.selected[0] === Zt ? { selected: [] } : { selected: [Zt] } }) }), St(ht(Pt), "render", function () { return s(Nt, { selected: Pt.state.selected, onSelect: Pt.onMapClick }) }), Pt } return bt }(_t.Component), Dt = function (xt) { at(bt, xt); var Ct = ft(bt); function bt() { var Pt; et(this, bt); for (var Rt = arguments.length, Jn = new Array(Rt), er = 0; er < Rt; er++)Jn[er] = arguments[er]; return Pt = Ct.call.apply(Ct, [this].concat(Jn)), St(ht(Pt), "render", function () { return Pt.props.selected || Pt.props.onSelect ? s(Nt, { selected: Pt.props.selected, onSelect: Pt.props.onSelect }) : s(kt, { multiple: Pt.props.multiple }) }), Pt } return bt }(_t.Component); e.exports = Dt })(dist$1); const WorldMap = dist$1.exports, Community = () => { const [e, s] = react.exports.useState(null); return jsxs("section", { id: "community", className: `${layout.section} ${styles$1.boxWidth} ${styles$1.paddingY}`, children: [jsx("div", { className: "block ss:hidden min-h-[100px]" }), jsxs("div", { className: layout.sectionInfo, children: [jsxs("h2", { className: styles$1.heading2, children: ["Our users are spread all over world with ", jsx("br", { className: "hidden md:flex" }), " wide coverage"] }), jsx("p", { className: `${styles$1.paragraph} max-w-[470px] mt-5`, children: "Lorem ipsum dolor sit amet consectetur adipisicing elit. Sint sed obcaecati tempore." }), jsx("div", { className: "my-5 flex sm:items-center justify-between w-[100%] flex-wrap", children: community_stats.map(o => jsxs("div", { className: "my-5 w-[40%] lg:w-[33%]", children: [jsx("h1", { className: "text-3xl sm:text-5xl font-medium font-poppins mb-3", children: o.value }), jsx("p", { className: "md:w-[95%] font-poppins font-normal text-greyish leading-[30.8px] text-[16px]", children: o.title })] }, o.id)) })] }), jsx("div", { className: "flex items-center justify-center", children: jsx(WorldMap, { multiple: !0, selected: e, onSelect: s }) })] }) }, Converter = () => jsxs("section", { id: "convertor", className: `flex flex-col-reverse md:flex-row flex-wrap justify-between ${styles$1.paddingY}`, children: [jsx("div", { className: "block ss:hidden min-h-[100px]" }), jsxs("div", { className: "relative w-full md:w-[40%]", children: [jsx(CryptoConvertor, {}), jsx("div", { className: "hidden sm:block absolute z-[3] -left-1/2 top-0 w-[50%] h-[50%] rounded-full white__gradient" }), jsx("div", { className: "hidden sm:block absolute z-[0] w-[50%] h-[50%] -left-1/2 bottom-0 rounded-full pink__gradient" })] }), jsxs("div", { className: "w-full md:w-[50%]", children: [jsxs("h2", { className: styles$1.heading2, children: ["Easily convert any ", jsx("br", { className: "md:block hidden" }), " crypto currency in  ", jsx("br", { className: "md:block hidden" }), " other currency"] }), jsx("p", { className: `${styles$1.paragraph} md:max-w-[470px] mt-5 mb-5`, children: "Lorem ipsum, dolor sit amet consectetur adipisicing elit. Eos libero delectus sequi laborum fugit voluptate." })] })] }); var dist = { exports: {} }, helpers = {}; Object.defineProperty(helpers, "__esModule", { value: !0 }); helpers.isBrowser = helpers.isValidUrl = helpers.isEmpty = helpers.formatNumber = helpers.getAverage = helpers.symbolMap = void 0; function symbolMap(e, s, o = !1) { const c = Object.keys(s); for (var et = 0; et < c.length; et++)if (e.length >= c[et].length + 3 && (e.endsWith(c[et]) || e.startsWith(c[et]))) { const at = e.replace(c[et], s[c[et]]); return o ? symbolMap(at, s, !1) : at } return e } helpers.symbolMap = symbolMap; function getAverage(e) { return e.length ? e.flatMap(o => Object.keys(o)).filter((o, c, et) => et.indexOf(o) == c).reduce((o, c) => { let et = e.map(lt => lt[c]).filter(lt => lt), at = formatNumber(et.reduce((lt, ft) => lt + ft, 0) / et.length, 8); return o[c] = at, o }, {}) : {} } helpers.getAverage = getAverage; function formatNumber(e, s) { if (typeof e != "number" && (e = Number(e), isNaN(e))) return NaN; let o = typeof s == "number" ? e.toFixed(s) : e + "", c = o.match(/\./) ? o.replace(/0+$/g, "").replace(/\.+$/g, "") : o; return parseFloat(c) } helpers.formatNumber = formatNumber; function isEmpty(e) { if (!e) return !0; for (var s in e) return !1; return !0 } helpers.isEmpty = isEmpty; function isValidUrl(e) { try { return /^https?\:\/\//.test(new URL(e).protocol) } catch { return !1 } } helpers.isValidUrl = isValidUrl; helpers.isBrowser = typeof window < "u" && window.document; var worker = {}, api = {}, lib = { exports: {} }, browser$2 = { exports: {} }, hasRequiredBrowser$1; function requireBrowser$1() { return hasRequiredBrowser$1 || (hasRequiredBrowser$1 = 1, function (e, s) { var o = function () { if (typeof self < "u") return self; if (typeof window < "u") return window; if (typeof c < "u") return c; throw new Error("unable to locate global object") }, c = o(); e.exports = s = c.fetch, c.fetch && (s.default = c.fetch.bind(c)), s.Headers = c.Headers, s.Request = c.Request, s.Response = c.Response }(browser$2, browser$2.exports)), browser$2.exports } var browser$1, hasRequiredBrowser; function requireBrowser() { return hasRequiredBrowser || (hasRequiredBrowser = 1, browser$1 = typeof self == "object" ? self.FormData : window.FormData), browser$1 } (function (e, s) { var o = commonjsGlobal$1 && commonjsGlobal$1.__awaiter || function (et, at, lt, ft) { function dt(ht) { return ht instanceof lt ? ht : new lt(function (vt) { vt(ht) }) } return new (lt || (lt = Promise))(function (ht, vt) { function wt(Nt) { try { _t(ft.next(Nt)) } catch (kt) { vt(kt) } } function St(Nt) { try { _t(ft.throw(Nt)) } catch (kt) { vt(kt) } } function _t(Nt) { Nt.done ? ht(Nt.value) : dt(Nt.value).then(wt, St) } _t((ft = ft.apply(et, at || [])).next()) }) }; Object.defineProperty(s, "__esModule", { value: !0 }); function c(et, at) { const lt = typeof window < "u" ? window == null ? void 0 : window.fetch : requireBrowser$1(), ft = typeof window < "u" ? window == null ? void 0 : window.FormData : requireBrowser(); if (!lt) throw new Error("Fetch API is not installed. If you are using Node please run `npm install node-fetch`"); if (!ft) throw new Error("FormData is not installed. If you are using Node please run `npm install form-data`"); const dt = jt => Object.assign(Object.assign({}, jt), { headers: Object.assign({}, jt.headers), params: Object.assign({}, jt.params), values: Object.assign({}, jt.values) }), ht = jt => { var Gt, nr; if (((nr = (Gt = jt == null ? void 0 : jt.__proto__) === null || Gt === void 0 ? void 0 : Gt.constructor) === null || nr === void 0 ? void 0 : nr.name) != "Object") throw new Error("Invalid $options object."); let sr = dt(jt.$options || {}); return delete jt.$options, Object.assign(Object.assign({}, sr), { values: Object.assign(Object.assign({}, sr.values), jt) }) }, vt = (jt, Gt, nr = !1) => { let sr = nr ? jt || {} : dt(jt || {}), rr = dt(Gt || {}); return rr.headers = Object.assign(Object.assign({}, sr.headers), rr.headers), rr.params = Object.assign(Object.assign({}, sr.params), rr.params), rr.values = Object.assign(Object.assign({}, sr.values), rr.values), Object.assign(sr, rr), sr }; et = Object.assign({}, et); let wt = { base: "", headers: { "User-Agent": "Rests JS (v1.1.0)" }, params: {}, values: {}, on_error: void 0, on_success: void 0, on_request: void 0, fetch_agent: null }; vt(wt, (et == null ? void 0 : et.$options) || {}, !0), vt(wt, at, !0); const St = { json: "application/json", form: "multipart/form-data", urlencoded: "application/x-www-form-urlencoded", text: "text/plain" }, _t = Object.values(St), Nt = ["headers", "body", "query", "path"], kt = { POST: "body", GET: "query" }, Dt = { "multipart/form-data": function () { var jt = new ft; return jt.toString = function () { return this }, jt }, "application/x-www-form-urlencoded": function () { return new URLSearchParams }, "application/json": function () { return { append: function (jt, Gt) { this.data = this.data || {}, this.data[jt] = Gt }, toString: function () { return JSON.stringify(this.data) }, isEmpty: function () { return !this.data || Object.keys(this.data).length == 0 } } }, "text/plain": function () { return { append: function (jt, Gt) { return this.data = this.data || [], this.data.push(Gt) }, toString: function () { return this.data.join("") }, isEmpty: function () { return !this.data || this.data.length == 0 } } } }, xt = jt => jt == null, Ct = jt => { for (var Gt of jt) return !1; return !0 }, bt = jt => jt.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), Pt = jt => Object.fromEntries(Array.from(jt.keys(), Gt => Gt.endsWith("[]") ? [Gt.slice(0, -2), jt.getAll(Gt)] : [Gt, jt.get(Gt)])), Rt = (jt, Gt) => Gt.split(".").reduce((nr, sr) => nr == null ? void 0 : nr[sr], jt), Jn = (...jt) => { for (var Gt = 0; Gt < jt.length; Gt++)if (jt[Gt] !== null && jt[Gt] !== void 0) return jt[Gt]; return null }, er = (jt, Gt, nr, sr) => o(this, void 0, void 0, function* () { return lt(jt, Gt).then(function (rr) { var ar; return o(this, void 0, void 0, function* () { try { var _n = rr.headers.get("Content-Type") || ""; let ir; try { ir = rr.type } catch { } let or = { statusCode: rr.status, statusText: rr.statusText, headers: rr.headers, type: ir, ok: rr.ok }, ur = { "application/json": "json", "text/plain": "text", "(multipart/form-data|application/x-www-form-urlencoded)": "formData", blob: "blob", text: "text" }, hr = Object.keys(ur).find(cr => new RegExp(cr).test(_n)) || "text"; if (or[ur[hr]] = yield rr[ur[hr]](), or.message = ((ar = or == null ? void 0 : or.json) === null || ar === void 0 ? void 0 : ar.message) || (rr.ok ? "Success." : "Something went wrong."), !rr.ok) throw or; if (nr.on_success) { let cr = nr.on_success(or, sr); if (cr !== void 0) return cr } return or } catch (ir) { if (nr.on_error) { let or = nr.on_error(ir, sr); if (or !== void 0) return or } return Promise.reject(ir) } }) }) }); function Zt(jt, Gt, nr) { jt.method = (jt.method || "get").toUpperCase(), jt.params = jt.params || {}; const sr = function (rr) { var ar, _n, ir, or, ur, hr; return o(this, void 0, void 0, function* () { if (this instanceof sr) throw new Error("This is an endpoint, you can't initialize this."); var cr = vt(wt, Gt); cr.on_request = jt.on_request || cr.on_request, cr.on_success = jt.on_success || cr.on_success, cr.on_error = jt.on_error || cr.on_error; var mr = `${cr.base}${jt.path}`; ((rr == null ? void 0 : rr.$sandbox) || ((ar = cr == null ? void 0 : cr.values) === null || ar === void 0 ? void 0 : ar.$sandbox)) && (mr = `${cr.sandboxBase || cr.base}${jt.path}`); var gr = { method: jt.method, headers: Object.assign({}, cr.headers), agent: cr.fetch_agent }, $r = _t.includes(jt.enctype) ? jt.enctype : St[jt.enctype || "json"], Er = Object.assign({}, cr.params, jt.params), xr = Dt[$r](), br = new URLSearchParams; ((_n = rr == null ? void 0 : rr.constructor) === null || _n === void 0 ? void 0 : _n.name) == "FormData" ? rr = Pt(rr) : rr = rr || {}; for (var yr in Er) { var fr = Er[yr], Ar = rr[yr], Lr = (ir = cr == null ? void 0 : cr.values) === null || ir === void 0 ? void 0 : ir[yr], Dr = fr.default, Or = (rr == null ? void 0 : rr.$sandbox) || ((or = cr == null ? void 0 : cr.values) === null || or === void 0 ? void 0 : or.$sandbox) ? fr.example : void 0, vr = Jn(Ar, Lr, Or, Dr), Sr = fr.name || yr, Tr = fr.help || `The '${yr}' field is invalid.`; if (fr.required && xt(vr)) { var pr = new Error(Tr); throw pr.field = yr, pr } if (!xt(vr)) { if (typeof fr.format == "function") try { vr = fr.format(vr) } catch (Pr) { var pr = new Error(Pr.message || Tr); throw pr.field = yr, pr } if (fr.type && fr.type !== "any") { var pr = new Error(Tr); if (pr.field = yr, ["string", "boolean", "number"].includes(fr.type) && typeof vr != fr.type || fr.type == "array" && !Array.isArray(vr) || fr.type == "object" && (!vr || vr.__proto__.constructor.name !== "Object")) throw pr } if (fr.validate && (((hr = (ur = fr.validate) === null || ur === void 0 ? void 0 : ur.constructor) === null || hr === void 0 ? void 0 : hr.name) == "RegExp" && (fr.validate.toJSON = function () { return fr.validate.toString().replace(/^\//g, "").replace(/\/$/g, "") }), !new RegExp(fr.validate).test(vr))) { var pr = new Error(Tr); throw pr.field = yr, pr } if (fr.type == "number") { if (fr.hasOwnProperty("max") && !isNaN(fr.max) && Number(vr) > Number(fr.max)) { var pr = new Error(`The maximum allowed value allowed for the ${Sr} parameter is ${fr.max}`); throw pr.field = yr, pr } if (fr.hasOwnProperty("min") && !isNaN(fr.min) && Number(vr) < Number(fr.min)) { var pr = new Error(`The minimum allowed value allowed for the ${Sr} parameter is ${fr.min}`); throw pr.field = yr, pr } } if (fr.in && Array.isArray(fr.in) && !fr.in.includes(vr)) { var pr = new Error(`The ${Sr} parameter should be one of these values: ${fr.in}`); throw pr.field = yr, pr } var kr = typeof fr.location == "string" ? fr.location.toLowerCase() : kt[gr.method]; if (!kr || !Nt.includes(kr)) throw new Error(`Invalid location for '${yr}' field.`); if (kr == "headers") { gr.headers = gr.headers || {}, gr.headers[Sr] = vr; continue } if (kr == "body") { xr.append(Sr, vr); continue } if (kr == "query") { br.append(Sr, vr); continue } kr == "path" && (mr = mr.replace(new RegExp(`{${bt(Sr).trim()}}`), vr)) } } var Ir = br.toString(); Ir && (mr = `${mr}?${Ir}`); var Mr = xr.keys && Ct(xr.keys()) || xr.getLengthSync && xr.getLengthSync() == 0 || xr.isEmpty && xr.isEmpty(); Mr || (gr.body = xr.toString()), gr.body && $r !== "multipart/form-data" && (gr.headers = gr.headers || {}, gr.headers["Content-Type"] = $r); let Nr = { url: mr, options: gr, params: rr, key: nr, instance: wt.__$root_instance__, self: Zt(jt, Gt, nr) }; if (cr.on_request) { var wr = yield Promise.resolve(cr.on_request(Nr)); if (wr) if ((wr == null ? void 0 : wr.url) || (wr == null ? void 0 : wr.options)) mr = wr.url || mr, gr = wr.options || gr; else return wr; if (wr === !1) return !1 } return er(mr, gr, cr, Nr) }) }; return sr } function lr(jt, Gt, nr, sr) { jt = jt || "Rests"; var rr = { [jt]: function (ar) { if (!(this instanceof rr[jt])) throw new Error("This is a category, you can initalize this category to update values using 'new' command."); if (sr) throw new Error("This is already initialized, you can use 'set' instead."); let _n = vt(wt, Gt), ir = ht(ar), or = vt(_n, ir); return c(nr ? Rt(et, nr) : et, or) } }; return sr && (rr[jt].set = function (ar) { if (this instanceof rr[jt].set) throw new Error("The set object can't be initialized."); let _n = ht(ar); return vt(wt, _n, !0), rr[jt] }), rr[jt] } function tr(jt, Gt, nr, sr) { for (var rr in Gt) { var ar = Gt[rr]; if (!ar || typeof ar != "object") continue; if (typeof jt[rr] < "u") { console.warn(`Skipping ${rr} as it confilicts with another key in the object`); continue } let ir = `${sr ? sr + "." : ""}${rr}`; if (ar.hasOwnProperty("path")) { var _n = ar; jt[rr] = Zt(_n, nr, ir) } else { if (rr.substr(0, 1) === "$") continue; let or = nr; ar != null && ar.$options && (or = vt(nr, ar == null ? void 0 : ar.$options)), jt[rr] = tr(lr(rr, or, ir), ar, or, ir) } } return jt } const xn = Object.defineProperty(lr("Rests", wt, void 0, !0), "__schema__", { value: { schema: et, options: wt }, writable: !1, enumerable: !1 }); return wt.__$root_instance__ = xn, tr(xn, et, {}) } c.default = c, s.default = c, e.exports = c })(lib, lib.exports); var __awaiter$1 = commonjsGlobal$1 && commonjsGlobal$1.__awaiter || function (e, s, o, c) { function et(at) { return at instanceof o ? at : new o(function (lt) { lt(at) }) } return new (o || (o = Promise))(function (at, lt) { function ft(vt) { try { ht(c.next(vt)) } catch (wt) { lt(wt) } } function dt(vt) { try { ht(c.throw(vt)) } catch (wt) { lt(wt) } } function ht(vt) { vt.done ? at(vt.value) : et(vt.value).then(ft, dt) } ht((c = c.apply(e, s || [])).next()) }) }, __importDefault = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(api, "__esModule", { value: !0 }); const rests_1 = __importDefault(lib.exports), helpers_1 = helpers; let krakenPairsList, closedMarketsBinance; const API = (0, rests_1.default)({ binance: { $options: { base: "https://api.binance.com/api/v3" }, bookTicker: { path: "/ticker/bookTicker", on_success: e => e.json }, ticker: { path: "/ticker/price", on_request(e) { return __awaiter$1(this, void 0, void 0, function* () { closedMarketsBinance || (closedMarketsBinance = (yield e.instance.binance.bookTicker()).map(o => parseFloat(o.askPrice) <= 0 ? o.symbol : !1).filter(o => o)) }) }, on_success(e, s) { const o = { USDT: "USD", USDC: "USD", BUSD: "USD" }, c = e.json; if (!c || !Array.isArray(c)) throw new Error(`Invalid response from Binance: ${JSON.stringify(c)}`); return c.reduce((et, at) => { if (closedMarketsBinance && closedMarketsBinance.indexOf(at.symbol) !== -1) return et; const lt = (0, helpers_1.symbolMap)(at.symbol, o), ft = parseFloat(at.price); return et[lt] = ft, et }, {}) } } }, bitfinex: { $options: { base: "https://api-pub.bitfinex.com/v2" }, ticker: { path: "/tickers", params: { symbols: { help: "The symbols you want information about as a comma separated list, or ALL for every symbol. (Examples of possible symbols: tBTCUSD, tETHUSD, fUSD, fBTC)", default: "ALL", type: "string" } }, on_success: function (e) { const s = { BAB: "BCH", DSH: "DASH" }, o = e.json; if (!o || !Array.isArray(o)) throw new Error(`Invalid response from Bitfinex: ${JSON.stringify(o)}`); return o.reduce((c, et) => { if (!et[0].startsWith("t")) return c; const at = (0, helpers_1.symbolMap)(et[0].replace(/^t/, ""), s, !0).replace(":", ""), lt = parseFloat(et[7]); return c[at] = lt, c }, {}) } } }, coinbase: { $options: { base: "https://api.coinbase.com/v2" }, ticker: { path: "/exchange-rates", params: { currency: { help: "The exchange currency (default USD)" } }, on_success: e => { var s; const o = (s = e == null ? void 0 : e.json) === null || s === void 0 ? void 0 : s.data; if (!o) throw new Error(`Invalid response from Coinbase: ${o}`); return Object.keys(o.rates).reduce((c, et, at) => { const lt = et + o.currency, ft = (0, helpers_1.formatNumber)(1 / parseFloat(o.rates[et]), 8); return c[lt] = ft, c }, {}) } } }, kraken: { $options: { base: "https://api.kraken.com/0/public" }, pairs: { path: "/AssetPairs", on_success: e => Object.keys(e.json.result) }, ticker: { path: "/Ticker", on_request: e => __awaiter$1(void 0, void 0, void 0, function* () { return krakenPairsList || (krakenPairsList = yield e.instance.kraken.pairs()), { url: e.url + "?pair=" + krakenPairsList } }), on_success: e => { var s; const o = { XETC: "ETC", XETH: "ETH", XLTC: "LTC", XMLN: "MLN", XREP: "REP", XXBT: "BTC", XXDG: "XDG", XXLM: "XLM", XXMR: "XMR", XXRP: "XRP", XZEC: "ZEC", XBT: "BTC", ZAUD: "AUD", ZEUR: "EUR", ZGBP: "GBP", ZUSD: "USD", ZCAD: "CAD", ZJPY: "JPY" }, c = (s = e.json) === null || s === void 0 ? void 0 : s.result; if (!c) throw new Error(`Invalid response from Kraken: ${JSON.stringify(c)}`); return Object.keys(c).reduce((et, at) => { const lt = (0, helpers_1.symbolMap)(at, o, !0), ft = parseFloat(c[at].c[0]); return et[lt] = ft, et }, {}) } } }, coinmarketcap: { $options: { base: "https://api.coinmarketcap.com/data-api/v3" }, top: { path: "/map/all", params: { limit: { default: "150" }, listing_status: { default: "active" } }, on_success: function (e) { const s = e.json; if (!s || !s.data || !Array.isArray(s.data.cryptoCurrencyMap)) throw new Error(`Invalid response from CoinMarketCap: ${JSON.stringify(s)}`); return s.data.cryptoCurrencyMap.reduce((o, c) => (o[c.symbol] = { id: c.id, title: c.name, symbol: c.symbol, logo: `https://s2.coinmarketcap.com/static/img/coins/128x128/${c.id}.png`, rank: c.rank }, o), {}) } } }, fiat: { all: { path: "https://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml", on_success: function (e) { var s = e.text, o = [...s.matchAll(/currency=["']([A-Za-z]+)["']/gi)], c = [...s.matchAll(/rate=["']([.0-9]+)["']/gi)], et = o.reduce((at, lt, ft) => Object.assign(Object.assign({}, at), { [lt[1]]: c[ft][1] }), {}); return et.EUR = 1, et } } }, coinconvert: { $options: { base: "https://api.coinconvert.net" }, ticker: { path: "/v2/ticker", params: { v: { default: "2.1.4" }, filterExchanges: { type: "array" }, noAverage: { type: "boolean" } }, on_success: e => e.json }, list: { path: "/v2/list?v=2.1.4", on_success: e => e.json } } }); api.default = API; (function (e) {
	var s = commonjsGlobal$1 && commonjsGlobal$1.__awaiter || function (lt, ft, dt, ht) { function vt(wt) { return wt instanceof dt ? wt : new dt(function (St) { St(wt) }) } return new (dt || (dt = Promise))(function (wt, St) { function _t(Dt) { try { kt(ht.next(Dt)) } catch (xt) { St(xt) } } function Nt(Dt) { try { kt(ht.throw(Dt)) } catch (xt) { St(xt) } } function kt(Dt) { Dt.done ? wt(Dt.value) : vt(Dt.value).then(_t, Nt) } kt((ht = ht.apply(lt, ft || [])).next()) }) }, o = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function (lt) { return lt && lt.__esModule ? lt : { default: lt } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.initialCoinList = void 0; const c = o(api), et = helpers; e.initialCoinList = { crypto: ["BTC", "ETH", "USDT", "USDC", "BNB", "XRP", "BUSD", "ADA", "SOL", "DOGE", "DOT", "DAI", "MATIC", "SHIB", "TRX", "AVAX", "UNI", "WBTC", "LEO", "LTC", "ETC", "LINK", "ATOM", "FTT", "XLM", "NEAR", "CRO", "XMR", "ALGO", "BCH", "LUNC", "FLOW", "QNT", "VET", "TON", "FIL", "APE", "ICP", "CHZ", "HBAR", "MANA", "XTZ", "SAND", "EOS", "EGLD", "THETA", "AAVE", "AXS", "OKB", "USDP", "BSV", "KCS", "TUSD", "ZEC", "MIOTA", "XEC", "USDD", "MKR", "BTT", "HT", "GRT", "USDN", "HNT", "CAKE", "NEO", "KLAY", "FTM", "SNX", "PAXG", "RUNE", "NEXO", "LDO", "CRV", "GT", "DASH", "ENJ", "BAT", "COMP", "STX", "KAVA", "RVN", "ZIL", "WAVES", "FEI", "MINA", "RSR", "XDC", "LRC", "GMT", "DCR", "TWT", "CELO", "XEM", "BTG", "KSM", "HOT", "1INCH", "CEL", "CVX", "BNX", "AR", "GNO", "LUNA", "ROSE", "ENS", "USTC", "GUSD", "QTUM", "YFI", "ANKR", "TFUEL", "GALA", "GLM", "IOTX", "KDA", "BTRST", "ONE", "OMG", "BAL", "ZRX", "LPT", "POLY", "JST", "FLUX", "ICX", "BORA", "IOST", "HIVE", "AMP", "OP", "KNC", "XYM", "SRM", "ONT", "WAXP", "STORJ", "MXC", "CSPR", "IMX", "SC", "ZEN", "AUDIO", "GLMR", "SXP", "XCH", "ABBC", "CHSB", "VGX", "UMA", "WOO"], fiat: ["USD", "JPY", "BGN", "CZK", "DKK", "GBP", "HUF", "PLN", "RON", "SEK", "CHF", "ISK", "NOK", "HRK", "RUB", "TRY", "AUD", "BRL", "CAD", "CNY", "HKD", "IDR", "ILS", "INR", "KRW", "MXN", "MYR", "NZD", "PHP", "SGD", "THB", "ZAR", "EUR"] }; class at {
		constructor(ft) { this.exchanges = ["binance", "bitfinex", "coinbase", "kraken"], this.list = e.initialCoinList, this.cryptoInfo = [{ id: 1, title: "Bitcoin", symbol: "BTC", rank: 1 }, { id: 1027, title: "Ethereum", symbol: "ETH", rank: 2 }, { id: 825, title: "Tether", symbol: "USDT", rank: 3 }, { id: 3408, title: "USD Coin", symbol: "USDC", rank: 4 }, { id: 1839, title: "BNB", symbol: "BNB", rank: 5 }, { id: 52, title: "XRP", symbol: "XRP", rank: 6 }, { id: 4687, title: "Binance USD", symbol: "BUSD", rank: 7 }, { id: 2010, title: "Cardano", symbol: "ADA", rank: 8 }, { id: 5426, title: "Solana", symbol: "SOL", rank: 9 }, { id: 74, title: "Dogecoin", symbol: "DOGE", rank: 10 }, { id: 6636, title: "Polkadot", symbol: "DOT", rank: 11 }, { id: 4943, title: "Dai", symbol: "DAI", rank: 12 }, { id: 3890, title: "Polygon", symbol: "MATIC", rank: 13 }, { id: 5994, title: "Shiba Inu", symbol: "SHIB", rank: 14 }, { id: 1958, title: "TRON", symbol: "TRX", rank: 15 }, { id: 5805, title: "Avalanche", symbol: "AVAX", rank: 16 }, { id: 7083, title: "Uniswap", symbol: "UNI", rank: 17 }, { id: 3717, title: "Wrapped Bitcoin", symbol: "WBTC", rank: 18 }, { id: 3957, title: "UNUS SED LEO", symbol: "LEO", rank: 19 }, { id: 2, title: "Litecoin", symbol: "LTC", rank: 20 }, { id: 1321, title: "Ethereum Classic", symbol: "ETC", rank: 21 }, { id: 1975, title: "Chainlink", symbol: "LINK", rank: 22 }, { id: 3794, title: "Cosmos", symbol: "ATOM", rank: 23 }, { id: 4195, title: "FTX Token", symbol: "FTT", rank: 24 }, { id: 512, title: "Stellar", symbol: "XLM", rank: 25 }, { id: 6535, title: "NEAR Protocol", symbol: "NEAR", rank: 26 }, { id: 3635, title: "Cronos", symbol: "CRO", rank: 27 }, { id: 328, title: "Monero", symbol: "XMR", rank: 28 }, { id: 4030, title: "Algorand", symbol: "ALGO", rank: 29 }, { id: 1831, title: "Bitcoin Cash", symbol: "BCH", rank: 30 }, { id: 4172, title: "Terra Classic", symbol: "LUNC", rank: 31 }, { id: 4558, title: "Flow", symbol: "FLOW", rank: 32 }, { id: 3155, title: "Quant", symbol: "QNT", rank: 33 }, { id: 3077, title: "VeChain", symbol: "VET", rank: 34 }, { id: 11419, title: "Toncoin", symbol: "TON", rank: 35 }, { id: 2280, title: "Filecoin", symbol: "FIL", rank: 36 }, { id: 18876, title: "ApeCoin", symbol: "APE", rank: 37 }, { id: 8916, title: "Internet Computer", symbol: "ICP", rank: 38 }, { id: 4066, title: "Chiliz", symbol: "CHZ", rank: 39 }, { id: 4642, title: "Hedera", symbol: "HBAR", rank: 40 }, { id: 1966, title: "Decentraland", symbol: "MANA", rank: 41 }, { id: 2011, title: "Tezos", symbol: "XTZ", rank: 42 }, { id: 6210, title: "The Sandbox", symbol: "SAND", rank: 43 }, { id: 1765, title: "EOS", symbol: "EOS", rank: 44 }, { id: 6892, title: "Elrond", symbol: "EGLD", rank: 45 }, { id: 2416, title: "Theta Network", symbol: "THETA", rank: 46 }, { id: 7278, title: "Aave", symbol: "AAVE", rank: 47 }, { id: 6783, title: "Axie Infinity", symbol: "AXS", rank: 48 }, { id: 3897, title: "OKB", symbol: "OKB", rank: 49 }, { id: 3330, title: "Pax Dollar", symbol: "USDP", rank: 50 }, { id: 3602, title: "Bitcoin SV", symbol: "BSV", rank: 51 }, { id: 2087, title: "KuCoin Token", symbol: "KCS", rank: 52 }, { id: 2563, title: "TrueUSD", symbol: "TUSD", rank: 53 }, { id: 1437, title: "Zcash", symbol: "ZEC", rank: 54 }, { id: 1720, title: "IOTA", symbol: "MIOTA", rank: 55 }, { id: 10791, title: "eCash", symbol: "XEC", rank: 56 }, { id: 19891, title: "USDD", symbol: "USDD", rank: 57 }, { id: 1518, title: "Maker", symbol: "MKR", rank: 58 }, { id: 16086, title: "BitTorrent-New", symbol: "BTT", rank: 59 }, { id: 2502, title: "Huobi Token", symbol: "HT", rank: 60 }, { id: 6719, title: "The Graph", symbol: "GRT", rank: 61 }, { id: 5068, title: "Neutrino USD", symbol: "USDN", rank: 62 }, { id: 5665, title: "Helium", symbol: "HNT", rank: 63 }, { id: 7186, title: "PancakeSwap", symbol: "CAKE", rank: 64 }, { id: 1376, title: "Neo", symbol: "NEO", rank: 65 }, { id: 4256, title: "Klaytn", symbol: "KLAY", rank: 66 }, { id: 3513, title: "Fantom", symbol: "FTM", rank: 67 }, { id: 2586, title: "Synthetix", symbol: "SNX", rank: 68 }, { id: 4705, title: "PAX Gold", symbol: "PAXG", rank: 69 }, { id: 4157, title: "THORChain", symbol: "RUNE", rank: 70 }, { id: 2694, title: "Nexo", symbol: "NEXO", rank: 71 }, { id: 8e3, title: "Lido DAO", symbol: "LDO", rank: 72 }, { id: 6538, title: "Curve DAO Token", symbol: "CRV", rank: 73 }, { id: 4269, title: "GateToken", symbol: "GT", rank: 74 }, { id: 131, title: "Dash", symbol: "DASH", rank: 75 }, { id: 2130, title: "Enjin Coin", symbol: "ENJ", rank: 76 }, { id: 1697, title: "Basic Attention Token", symbol: "BAT", rank: 77 }, { id: 5692, title: "Compound", symbol: "COMP", rank: 78 }, { id: 4847, title: "Stacks", symbol: "STX", rank: 79 }, { id: 4846, title: "Kava", symbol: "KAVA", rank: 80 }, { id: 2577, title: "Ravencoin", symbol: "RVN", rank: 81 }, { id: 2469, title: "Zilliqa", symbol: "ZIL", rank: 82 }, { id: 1274, title: "Waves", symbol: "WAVES", rank: 83 }, { id: 8642, title: "Fei USD", symbol: "FEI", rank: 84 }, { id: 8646, title: "Mina", symbol: "MINA", rank: 85 }, { id: 3964, title: "Reserve Rights", symbol: "RSR", rank: 86 }, { id: 2634, title: "XDC Network", symbol: "XDC", rank: 87 }, { id: 1934, title: "Loopring", symbol: "LRC", rank: 88 }, { id: 18069, title: "STEPN", symbol: "GMT", rank: 89 }, { id: 1168, title: "Decred", symbol: "DCR", rank: 90 }, { id: 5964, title: "Trust Wallet Token", symbol: "TWT", rank: 91 }, { id: 5567, title: "Celo", symbol: "CELO", rank: 92 }, { id: 873, title: "NEM", symbol: "XEM", rank: 93 }, { id: 2083, title: "Bitcoin Gold", symbol: "BTG", rank: 94 }, { id: 5034, title: "Kusama", symbol: "KSM", rank: 95 }, { id: 2682, title: "Holo", symbol: "HOT", rank: 96 }, { id: 8104, title: "1inch Network", symbol: "1INCH", rank: 97 }, { id: 2700, title: "Celsius", symbol: "CEL", rank: 98 }, { id: 9903, title: "Convex Finance", symbol: "CVX", rank: 99 }, { id: 9891, title: "BinaryX", symbol: "BNX", rank: 100 }, { id: 5632, title: "Arweave", symbol: "AR", rank: 101 }, { id: 1659, title: "Gnosis", symbol: "GNO", rank: 102 }, { id: 20314, title: "Terra", symbol: "LUNA", rank: 103 }, { id: 7653, title: "Oasis Network", symbol: "ROSE", rank: 104 }, { id: 13855, title: "Ethereum Name Service", symbol: "ENS", rank: 105 }, { id: 7129, title: "TerraClassicUSD", symbol: "USTC", rank: 106 }, { id: 3306, title: "Gemini Dollar", symbol: "GUSD", rank: 107 }, { id: 1684, title: "Qtum", symbol: "QTUM", rank: 108 }, { id: 5864, title: "yearn.finance", symbol: "YFI", rank: 109 }, { id: 3783, title: "Ankr", symbol: "ANKR", rank: 110 }, { id: 3822, title: "Theta Fuel", symbol: "TFUEL", rank: 111 }, { id: 7080, title: "Gala", symbol: "GALA", rank: 112 }, { id: 1455, title: "Golem", symbol: "GLM", rank: 113 }, { id: 2777, title: "IoTeX", symbol: "IOTX", rank: 114 }, { id: 5647, title: "Kadena", symbol: "KDA", rank: 115 }, { id: 11584, title: "Braintrust", symbol: "BTRST", rank: 116 }, { id: 3945, title: "Harmony", symbol: "ONE", rank: 117 }, { id: 1808, title: "OMG Network", symbol: "OMG", rank: 118 }, { id: 5728, title: "Balancer", symbol: "BAL", rank: 119 }, { id: 1896, title: "0x", symbol: "ZRX", rank: 120 }, { id: 3640, title: "Livepeer", symbol: "LPT", rank: 121 }, { id: 2496, title: "Polymath", symbol: "POLY", rank: 122 }, { id: 5488, title: "JUST", symbol: "JST", rank: 123 }, { id: 3029, title: "Flux", symbol: "FLUX", rank: 124 }, { id: 2099, title: "ICON", symbol: "ICX", rank: 125 }, { id: 3801, title: "BORA", symbol: "BORA", rank: 126 }, { id: 2405, title: "IOST", symbol: "IOST", rank: 127 }, { id: 5370, title: "Hive", symbol: "HIVE", rank: 128 }, { id: 6945, title: "Amp", symbol: "AMP", rank: 129 }, { id: 11840, title: "Optimism", symbol: "OP", rank: 130 }, { id: 9444, title: "Kyber Network Crystal v2", symbol: "KNC", rank: 131 }, { id: 8677, title: "Symbol", symbol: "XYM", rank: 132 }, { id: 6187, title: "Serum", symbol: "SRM", rank: 133 }, { id: 2566, title: "Ontology", symbol: "ONT", rank: 134 }, { id: 2300, title: "WAX", symbol: "WAXP", rank: 135 }, { id: 1772, title: "Storj", symbol: "STORJ", rank: 136 }, { id: 3628, title: "MXC", symbol: "MXC", rank: 137 }, { id: 5899, title: "Casper", symbol: "CSPR", rank: 138 }, { id: 10603, title: "Immutable X", symbol: "IMX", rank: 139 }, { id: 1042, title: "Siacoin", symbol: "SC", rank: 140 }, { id: 1698, title: "Horizen", symbol: "ZEN", rank: 141 }, { id: 7455, title: "Audius", symbol: "AUDIO", rank: 142 }, { id: 6836, title: "Moonbeam", symbol: "GLMR", rank: 143 }, { id: 4279, title: "SXP", symbol: "SXP", rank: 144 }, { id: 9258, title: "Chia", symbol: "XCH", rank: 145 }, { id: 3437, title: "ABBC Coin", symbol: "ABBC", rank: 146 }, { id: 2499, title: "SwissBorg", symbol: "CHSB", rank: 147 }, { id: 1817, title: "Voyager Token", symbol: "VGX", rank: 148 }, { id: 5617, title: "UMA", symbol: "UMA", rank: 149 }, { id: 7501, title: "WOO Network", symbol: "WOO", rank: 150 }].reduce((dt, ht) => (dt[ht.symbol] = Object.assign(Object.assign({}, dt), { logo: `https://s2.coinmarketcap.com/static/img/coins/128x128/${ht.id}.png` }), dt), {}), this.data = { crypto: { last_updated: null, current: null }, fiat: { last_updated: null, current: null } }, this.options = Object.assign({ cryptoInterval: et.isBrowser ? 15 * 1e3 : 5 * 1e3, fiatInterval: 60 * 1e3 * 60, calculateAverage: !0, onUpdate: void 0, serverHost: "https://api.coinconvert.net", useHostedAPI: !1, refreshCryptoList: !0, listLimit: 150 }, this.exchanges.reduce((dt, ht) => Object.assign(Object.assign({}, dt), { [ht]: !0 }), {})), this.isReady = !1, this.isRunning = !1, ft && this.setOptions(ft), this.hostedAPI || (this.hostedAPI = new c.default.coinconvert({ $options: { base: this.options.serverHost } })) } log(...ft) { var dt, ht; !et.isBrowser && ((ht = (dt = process == null ? void 0 : process.env) === null || dt === void 0 ? void 0 : dt.NODE_ENV) === null || ht === void 0 ? void 0 : ht.startsWith("dev")) && Array.from(arguments).forEach(vt => { console.log(vt) }) } setOptions(ft) {
			let dt = typeof ft == "function" ? ft(Object.assign({}, this.options)) : ft || {}; et.isBrowser && !isNaN(dt.cryptoInterval) && dt.cryptoInterval < 1e4 && console.error(`The minimum allowed interval on frontend is 10s. You should host your own server API if you want to go lower.
			
			For the server API routes see the CoinConvert schema on https://github.com/coinconvert/crypto-convert/blob/main/src/api.ts;
			`); let ht = !1, vt = dt.hasOwnProperty("calculateAverage") && dt.calculateAverage !== this.options.calculateAverage; for (const wt of this.exchanges) if (dt.hasOwnProperty(wt) && dt[wt] !== this.options[wt]) { ht = !0; break } if (dt.hasOwnProperty("HTTPAgent") && c.default.set({ $options: { fetch_agent: dt.HTTPAgent } }), dt.serverHost && (0, et.isValidUrl)(dt.serverHost) && (this.options.serverHost = dt.serverHost, this.hostedAPI = new c.default.coinconvert({ $options: { base: dt.serverHost } })), this.options = Object.assign(Object.assign(Object.assign({}, this.options), dt), { cryptoInterval: isNaN(dt.cryptoInterval) ? this.options.cryptoInterval : Math.max(et.isBrowser && !this.isCustomServerHost ? 1e4 : 1e3, dt.cryptoInterval), fiatInterval: isNaN(dt.fiatInterval) ? this.options.fiatInterval : Math.max(60 * 30 * 1e3, dt.fiatInterval), listLimit: isNaN(dt.listLimit) ? this.options.listLimit : Math.max(1, Math.min(1e3, parseInt(dt.listLimit + ""))) }), (ht || vt) && this.isReady) { if (et.isBrowser || this.options.useHostedAPI) return this.browserTicker(); this.data.crypto.current = this.joinPrices(this.data) } return this
		} get isCustomServerHost() { return !/^https?:\/\/api\.coinconvert\.net/i.test(this.options.serverHost) } updateCrypto() { return s(this, void 0, void 0, function* () { this.data.crypto.last_updated || this.log("Updating crypto..."); const ft = this.exchanges.reduce((vt, wt) => Object.assign(Object.assign({}, vt), { [wt]: c.default[wt].ticker }), {}); let dt = [], ht = {}; for (const vt in ft) try { this.data.crypto[vt] = yield ft[vt](), this.options[vt] && (dt.push(this.data.crypto[vt]), ht = Object.assign(Object.assign({}, ht), this.data.crypto[vt]), this.data.crypto.last_updated = +new Date) } catch (wt) { this.data.crypto[vt] = null, console.error(`Failed fetching prices from ${vt}`, wt) } return dt.length && (this.data.crypto.current = this.options.calculateAverage ? Object.assign(Object.assign({}, ht), (0, et.getAverage)(dt)) : ht, typeof this.options.onUpdate == "function" && this.options.onUpdate(this.data.crypto)), this }) } updateFiat() { return s(this, void 0, void 0, function* () { this.log("Updating fiat..."); try { this.data.fiat.current = yield c.default.fiat.all(), this.data.fiat.last_updated = +new Date, typeof this.options.onUpdate == "function" && this.options.onUpdate(this.data.fiat, !0) } catch (ft) { console.error("Failed fetching fiat prices from ECB", ft) } return this }) } updateLists() { return s(this, void 0, void 0, function* () { this.data.crypto.last_updated || this.log("Updating top currency list..."); try { const ft = yield c.default.coinmarketcap.top({ limit: this.options.listLimit + "" }); this.list.crypto = Object.keys(ft), this.cryptoInfo = ft, typeof this.onCryptoListRefresh == "function" && this.isReady && this.onCryptoListRefresh(this.list.crypto) } catch (ft) { console.error("Failed fetching fiat prices from ECB", ft) } return this }) } joinPrices(ft) { const dt = this.exchanges.reduce((wt, St) => Object.assign(Object.assign({}, wt), { [St]: ft.crypto[St] }), {}); let ht = [], vt = {}; for (const wt in dt) !this.options[wt] || !dt[wt] || (ht.push(dt[wt]), vt = Object.assign(Object.assign({}, vt), dt[wt])); return this.options.calculateAverage ? Object.assign(Object.assign({}, vt), (0, et.getAverage)(ht)) : vt } browserTicker() { return s(this, void 0, void 0, function* () { try { const ft = this.options, dt = this.exchanges.filter(vt => !ft[vt]), ht = yield this.hostedAPI.ticker(dt.length ? { filterExchanges: dt, noAverage: this.options.calculateAverage ? void 0 : !0 } : {}); this.data = ht, typeof this.options.onUpdate == "function" && this.options.onUpdate(this.data) } catch (ft) { console.error("Failed fetching prices from API", ft) } return this }) } browserLists() { return s(this, void 0, void 0, function* () { try { const ft = yield this.hostedAPI.list(); this.list.crypto = Object.keys(ft.crypto), this.list.fiat = ft.fiat, this.cryptoInfo = ft.crypto, typeof this.onCryptoListRefresh == "function" && this.isReady && this.onCryptoListRefresh(this.list.crypto) } catch (ft) { console.error("Failed fetching currencies list from API", ft) } return this }) } runBrowser() {
			return s(this, void 0, void 0, function* () {
				if (typeof window < "u" && window.__ccRunning) throw new Error(`The crypto-convert worker seems to be already running. 
			- There might be an issue with the way your app imports javascript dependencies. 
			- Make sure to call 'convert.stop()' on component unmounts if you are using SPA frameworks (e.g React).`); if (!this.isReady) { if (yield this.browserTicker(), yield this.browserLists(), !this.isRunning) return !1; !et.isBrowser && this.options.useHostedAPI && this.options.refreshCryptoList && (this.lists_worker = setInterval(this.browserLists.bind(this), 86400)) } return this.crypto_worker = setInterval(this.browserTicker.bind(this), this.options.cryptoInterval), this.isReady = !0, typeof window < "u" && (window.__ccRunning = !0, window.__ccRunID && clearInterval(window.__ccRunID), window.__ccRunID = this.crypto_worker), this
			})
		} runServer() { return s(this, void 0, void 0, function* () { return yield this.updateLists(), yield this.updateFiat(), yield this.updateCrypto(), this.isRunning ? (this.isReady = !0, this.crypto_worker = setInterval(this.updateCrypto.bind(this), this.options.cryptoInterval), this.fiat_worker = setInterval(this.updateFiat.bind(this), this.options.fiatInterval), this.options.refreshCryptoList && (this.lists_worker = setInterval(this.updateLists.bind(this), 86400)), this) : !1 }) } run() { if (this.isRunning || this.crypto_worker) throw new Error("Crypto-convert is already running."); return this.isRunning = !0, et.isBrowser || this.options.useHostedAPI ? this.runBrowser() : this.runServer() } stop() { return this.isRunning = !1, clearInterval(this.crypto_worker), clearInterval(this.fiat_worker), this.crypto_worker = null, this.fiat_worker = null, this.lists_worker && (clearInterval(this.lists_worker), this.lists_worker = null), typeof window < "u" && (window.__ccRunning = !1), this } restart() { return this.stop().run() }
	} e.default = at
})(worker); var custom = {}, __awaiter = commonjsGlobal$1 && commonjsGlobal$1.__awaiter || function (e, s, o, c) { function et(at) { return at instanceof o ? at : new o(function (lt) { lt(at) }) } return new (o || (o = Promise))(function (at, lt) { function ft(vt) { try { ht(c.next(vt)) } catch (wt) { lt(wt) } } function dt(vt) { try { ht(c.throw(vt)) } catch (wt) { lt(wt) } } function ht(vt) { vt.done ? at(vt.value) : et(vt.value).then(ft, dt) } ht((c = c.apply(e, s || [])).next()) }) }; Object.defineProperty(custom, "__esModule", { value: !0 }); const worker_1 = worker; class CustomWorkers { constructor() { this.ticker = {}, this.list = [], this.workers = {}, this.workersPromises = [] } ready() { return __awaiter(this, void 0, void 0, function* () { return Promise.all(this.workersPromises) }) } addCurrency(s, o, c, et) { return __awaiter(this, void 0, void 0, function* () { if (typeof s != "string" || typeof o != "string" || !worker_1.initialCoinList.fiat.includes(o)) throw new Error("Invalid currency pair."); if (typeof c != "function") throw new Error("No function specified."); if (s = s.toUpperCase(), o = o.toUpperCase(), (this.ticker[s + o] || this.ticker[o + s] || this.list.indexOf(s) != -1) && (console.warn("This custom currency already exists, it will be overriden."), this.removeCurrency(s)), this.list.push(s), et) { if (typeof et != "number") throw new Error("Invalid interval specfied."); this.workers[s + o] = setInterval(() => Promise.resolve(c()).then(lt => { this.ticker[s + o] = Number(lt) }), et) } const at = Promise.resolve(c()).then(lt => { this.ticker[s + o] = Number(lt) }); return this.workersPromises.push(at), at }) } removeCurrency(s, o) { s = s.toUpperCase(), o = o ? o.toUpperCase() : ""; for (const c in this.workers) c.includes(s + o) && (clearInterval(this.workers[c]), delete this.ticker[c]); this.list = this.list.filter(c => c !== s) } } custom.default = CustomWorkers; (function (module, exports) {/*!
 * crypto-convert (c) 2022
 * Author: Elis
 * License: https://github.com/coinconvert/crypto-convert
 */var __awaiter = commonjsGlobal$1 && commonjsGlobal$1.__awaiter || function (e, s, o, c) { function et(at) { return at instanceof o ? at : new o(function (lt) { lt(at) }) } return new (o || (o = Promise))(function (at, lt) { function ft(vt) { try { ht(c.next(vt)) } catch (wt) { lt(wt) } } function dt(vt) { try { ht(c.throw(vt)) } catch (wt) { lt(wt) } } function ht(vt) { vt.done ? at(vt.value) : et(vt.value).then(ft, dt) } ht((c = c.apply(e, s || [])).next()) }) }, __importDefault = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(exports, "__esModule", { value: !0 }); const helpers_1 = helpers, worker_1 = __importDefault(worker), custom_1 = __importDefault(custom), customWorkers = new custom_1.default; class _CryptoConvert {
		constructor(e = {}) { if (helpers_1.isBrowser) { if (window.__ccInitialized) throw new Error("You have already initalized one instance of crypto-convert. You cannot initialize multiple instances."); window.__ccInitialized = !0 } this.worker = new worker_1.default(e), this.workerReady = this.worker.run(), this.internalMethods = Object.getOwnPropertyNames(_CryptoConvert.prototype), Promise.resolve(this.workerReady).then(() => { this.populate(), this.worker.onCryptoListRefresh = () => { this.populate() } }) } getPrice(e, s = "USD") { var o = customWorkers.ticker[e + s] || (customWorkers.ticker[s + e] ? 1 / customWorkers.ticker[s + e] : null), c = this.worker.data.crypto.current[e + s] || (this.worker.data.crypto.current[s + e] ? 1 / this.worker.data.crypto.current[s + e] : null); return o || c } wrapper(o, s) { var o = o, c = s; return function (at) { if ((0, helpers_1.isEmpty)(this.worker.data.crypto.current) || (0, helpers_1.isEmpty)(this.worker.data.fiat.current)) return console.warn("[~] Prices are loading.\nYou should use `await convert.ready()` to make sure prices are loaded before calling convert."), !1; if (!at || (at = (0, helpers_1.formatNumber)(at), isNaN(at))) return !1; const lt = this.worker.data.fiat.current, ft = this.worker.list.crypto.concat(customWorkers.list); if (c == o) return at; if (ft.includes(o) && ft.includes(c)) { let ht = this.getPrice(o, c) || this.wrapper("USD", c)(this.wrapper(o, "USD")(1)); return (0, helpers_1.formatNumber)(ht * at, 8) } if (lt[o] && lt[c]) return (0, helpers_1.formatNumber)(at / lt[o] * lt[c], 4); var dt = function (ht) { var vt = this.getPrice(ht) || this.wrapper("BTC", "USD")(this.getPrice(ht, "BTC")) || this.wrapper("ETH", "USD")(this.getPrice(ht, "ETH")); return vt }.bind(this); if (lt[c]) { let vt = dt(o) / lt.USD * lt[c]; return (0, helpers_1.formatNumber)(vt * at, 8) } if (lt[o]) { let vt = dt(c) / lt.USD * lt[o]; return (0, helpers_1.formatNumber)(at / vt, 8) } return null }.bind(this) } isSafeKey(e) { const s = function () { }; return !this.internalMethods.includes(e) && !e.startsWith("__") && !s[e] } populate() {
			let types = ""; types += "type amount = (amount: number | string) => number | false | null;", types += `
export interface Pairs {`; const all_currencies = this.worker.list.crypto.concat(this.worker.list.fiat, customWorkers.list); for (var i = 0; i < all_currencies.length; i++) {
				var coin = all_currencies[i]; if (!(!coin || typeof coin != "string" || !this.isSafeKey(coin))) {
					this[coin] || (this[coin] = {}), types += `
	'${coin.replace(/\'/g, "\\'")}': {`; for (var a = 0; a < all_currencies.length; a++) {
						var currency = all_currencies[a]; !currency || typeof currency != "string" || !this.isSafeKey(coin) || (this[coin][currency] = this.wrapper(coin, currency), types += `
		'${currency.replace(/\'/g, "\\'")}': amount,`)
					} types += `
},`}
			} types += `
}`, typeof window > "u" && !0 && typeof process < "u" && function () {
					return __awaiter(this, void 0, void 0, function* () {
						try {
							eval(`
						const fs = require('fs');
						const path = require('path');
						const isDist = path.basename(__dirname) == 'dist';
						const typesFile = path.join(__dirname, isDist ? 'paris.d.ts' : 'paris.ts');

						fs.writeFileSync(typesFile, types, 'utf-8');
					`)
						} catch (e) { console.warn(e) }
					})
				}()
		} get isReady() { return this.worker.isReady } get list() { return { crypto: this.worker.list.crypto.concat(customWorkers.list), fiat: this.worker.list.fiat } } get cryptoInfo() { return this.worker.cryptoInfo } get lastUpdated() { return this.worker.data.crypto.last_updated } get ticker() { return this.worker.data } setOptions(e) { if ((e.cryptoInterval || e.fiatInterval) && (e.cryptoInterval !== this.worker.options.cryptoInterval || e.fiatInterval !== this.worker.options.fiatInterval) || e.hasOwnProperty("refreshCryptoList") && e.refreshCryptoList !== this.worker.options.refreshCryptoList || e.hasOwnProperty("useHostedAPI") && e.useHostedAPI !== this.worker.options.useHostedAPI || e.listLimit && e.listLimit != this.worker.options.listLimit) { if (!this.worker.isReady) throw new Error("You cannot set these options here because CryptoConvert is not ready yet. Instead set the options on the constructor parameter."); return this.workerReady = Promise.resolve(this.worker.setOptions(e)).then(() => __awaiter(this, void 0, void 0, function* () { return yield this.worker.restart(), e.listLimit && this.populate(), this.worker })), this.worker } return this.worker.setOptions(e) } stop() { return this.worker.stop() } restart() { return this.workerReady = this.worker.restart(), this.workerReady } ready() { return __awaiter(this, void 0, void 0, function* () { return yield Promise.resolve(this.workerReady), yield Promise.resolve(customWorkers.ready()), this }) } addCurrency(e, ...s) { return __awaiter(this, void 0, void 0, function* () { if (this.hasOwnProperty(e)) throw new Error("This property already exists."); return Promise.resolve(customWorkers.addCurrency.apply(customWorkers, [e, ...s])).then(() => { this.worker.isReady && this.populate() }) }) } removeCurrency(e, s) { var o, c; if (customWorkers.list.includes(e) && this.isSafeKey(e)) { delete this[e]; const et = this.worker.list.crypto.concat(this.worker.list.fiat, customWorkers.list); for (const at of et) !((o = this[at]) === null || o === void 0) && o[e] && ((c = this[at]) === null || c === void 0 || delete c[e]) } return customWorkers.removeCurrency(e, s) }
	} _CryptoConvert.default = _CryptoConvert, module.exports && (module.exports = _CryptoConvert), exports.default = _CryptoConvert
})(dist, dist.exports); const CryptoConvert = getDefaultExportFromCjs(dist.exports); function VscArrowSwap(e) { return GenIcon({ tag: "svg", attr: { viewBox: "0 0 16 16", fill: "currentColor" }, child: [{ tag: "path", attr: { fillRule: "evenodd", clipRule: "evenodd", d: "M4.207 15.061L1 11.854v-.707L4.207 7.94l.707.707-2.353 2.354H15v1H2.56l2.354 2.353-.707.707zm7.586-7L15 4.854v-.707L11.793.94l-.707.707L13.439 4H1v1h12.44l-2.354 2.354.707.707z" } }] })(e) } function r(e) { var s, o, c = ""; if (typeof e == "string" || typeof e == "number") c += e; else if (typeof e == "object") if (Array.isArray(e)) for (s = 0; s < e.length; s++)e[s] && (o = r(e[s])) && (c && (c += " "), c += o); else for (s in e) e[s] && (c && (c += " "), c += s); return c } function clsx() { for (var e, s, o = 0, c = ""; o < arguments.length;)(e = arguments[o++]) && (s = r(e)) && (c && (c += " "), c += s); return c } const u = e => typeof e == "number" && !isNaN(e), d = e => typeof e == "string", p$1 = e => typeof e == "function", m = e => d(e) || p$1(e) ? e : null, f = e => react.exports.isValidElement(e) || d(e) || p$1(e) || u(e); function g(e, s, o) { o === void 0 && (o = 300); const { scrollHeight: c, style: et } = e; requestAnimationFrame(() => { et.minHeight = "initial", et.height = c + "px", et.transition = `all ${o}ms`, requestAnimationFrame(() => { et.height = "0", et.padding = "0", et.margin = "0", setTimeout(s, o) }) }) } function h(e) { let { enter: s, exit: o, appendPosition: c = !1, collapse: et = !0, collapseDuration: at = 300 } = e; return function (lt) { let { children: ft, position: dt, preventExitTransition: ht, done: vt, nodeRef: wt, isIn: St } = lt; const _t = c ? `${s}--${dt}` : s, Nt = c ? `${o}--${dt}` : o, kt = react.exports.useRef(0); return react.exports.useLayoutEffect(() => { const Dt = wt.current, xt = _t.split(" "), Ct = bt => { bt.target === wt.current && (Dt.dispatchEvent(new Event("d")), Dt.removeEventListener("animationend", Ct), Dt.removeEventListener("animationcancel", Ct), kt.current === 0 && bt.type !== "animationcancel" && Dt.classList.remove(...xt)) }; Dt.classList.add(...xt), Dt.addEventListener("animationend", Ct), Dt.addEventListener("animationcancel", Ct) }, []), react.exports.useEffect(() => { const Dt = wt.current, xt = () => { Dt.removeEventListener("animationend", xt), et ? g(Dt, vt, at) : vt() }; St || (ht ? xt() : (kt.current = 1, Dt.className += ` ${Nt}`, Dt.addEventListener("animationend", xt))) }, [St]), React.createElement(React.Fragment, null, ft) } } function y$1(e, s) { return { content: e.content, containerId: e.props.containerId, id: e.props.toastId, theme: e.props.theme, type: e.props.type, data: e.props.data || {}, isLoading: e.props.isLoading, icon: e.props.icon, status: s } } const v$2 = { list: new Map, emitQueue: new Map, on(e, s) { return this.list.has(e) || this.list.set(e, []), this.list.get(e).push(s), this }, off(e, s) { if (s) { const o = this.list.get(e).filter(c => c !== s); return this.list.set(e, o), this } return this.list.delete(e), this }, cancelEmit(e) { const s = this.emitQueue.get(e); return s && (s.forEach(clearTimeout), this.emitQueue.delete(e)), this }, emit(e) { this.list.has(e) && this.list.get(e).forEach(s => { const o = setTimeout(() => { s(...[].slice.call(arguments, 1)) }, 0); this.emitQueue.has(e) || this.emitQueue.set(e, []), this.emitQueue.get(e).push(o) }) } }, T$1 = e => { let { theme: s, type: o, ...c } = e; return jsx("svg", { viewBox: "0 0 24 24", width: "100%", height: "100%", fill: s === "colored" ? "currentColor" : `var(--toastify-icon-color-${o})`, ...c }) }, E$1 = { info: function (e) { return jsx(T$1, { ...e, children: jsx("path", { d: "M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z" }) }) }, warning: function (e) { return jsx(T$1, { ...e, children: jsx("path", { d: "M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z" }) }) }, success: function (e) { return jsx(T$1, { ...e, children: jsx("path", { d: "M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z" }) }) }, error: function (e) { return jsx(T$1, { ...e, children: jsx("path", { d: "M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z" }) }) }, spinner: function () { return jsx("div", { className: "Toastify__spinner" }) } }; function C$2(e) { const [, s] = react.exports.useReducer(_t => _t + 1, 0), [o, c] = react.exports.useState([]), et = react.exports.useRef(null), at = react.exports.useRef(new Map).current, lt = _t => o.indexOf(_t) !== -1, ft = react.exports.useRef({ toastKey: 1, displayedToast: 0, count: 0, queue: [], props: e, containerId: null, isToastActive: lt, getToast: _t => at.get(_t) }).current; function dt(_t) { let { containerId: Nt } = _t; const { limit: kt } = ft.props; !kt || Nt && ft.containerId !== Nt || (ft.count -= ft.queue.length, ft.queue = []) } function ht(_t) { c(Nt => _t == null ? [] : Nt.filter(kt => kt !== _t)) } function vt() { const { toastContent: _t, toastProps: Nt, staleId: kt } = ft.queue.shift(); St(_t, Nt, kt) } function wt(_t, Nt) { let { delay: kt, staleId: Dt, ...xt } = Nt; if (!f(_t) || function (jt) { return !et.current || ft.props.enableMultiContainer && jt.containerId !== ft.props.containerId || at.has(jt.toastId) && jt.updateId == null }(xt)) return; const { toastId: Ct, updateId: bt, data: Pt } = xt, { props: Rt } = ft, Jn = () => ht(Ct), er = bt == null; er && ft.count++; const Zt = { ...Rt, style: Rt.toastStyle, key: ft.toastKey++, ...xt, toastId: Ct, updateId: bt, data: Pt, closeToast: Jn, isIn: !1, className: m(xt.className || Rt.toastClassName), bodyClassName: m(xt.bodyClassName || Rt.bodyClassName), progressClassName: m(xt.progressClassName || Rt.progressClassName), autoClose: !xt.isLoading && (lr = xt.autoClose, tr = Rt.autoClose, lr === !1 || u(lr) && lr > 0 ? lr : tr), deleteToast() { const jt = y$1(at.get(Ct), "removed"); at.delete(Ct), v$2.emit(4, jt); const Gt = ft.queue.length; if (ft.count = Ct == null ? ft.count - ft.displayedToast : ft.count - 1, ft.count < 0 && (ft.count = 0), Gt > 0) { const nr = Ct == null ? ft.props.limit : 1; if (Gt === 1 || nr === 1) ft.displayedToast++, vt(); else { const sr = nr > Gt ? Gt : nr; ft.displayedToast = sr; for (let rr = 0; rr < sr; rr++)vt() } } else s() } }; var lr, tr; Zt.iconOut = function (jt) { let { theme: Gt, type: nr, isLoading: sr, icon: rr } = jt, ar = null; const _n = { theme: Gt, type: nr }; return rr === !1 || (p$1(rr) ? ar = rr(_n) : react.exports.isValidElement(rr) ? ar = react.exports.cloneElement(rr, _n) : d(rr) || u(rr) ? ar = rr : sr ? ar = E$1.spinner() : (ir => ir in E$1)(nr) && (ar = E$1[nr](_n))), ar }(Zt), p$1(xt.onOpen) && (Zt.onOpen = xt.onOpen), p$1(xt.onClose) && (Zt.onClose = xt.onClose), Zt.closeButton = Rt.closeButton, xt.closeButton === !1 || f(xt.closeButton) ? Zt.closeButton = xt.closeButton : xt.closeButton === !0 && (Zt.closeButton = !f(Rt.closeButton) || Rt.closeButton); let xn = _t; react.exports.isValidElement(_t) && !d(_t.type) ? xn = react.exports.cloneElement(_t, { closeToast: Jn, toastProps: Zt, data: Pt }) : p$1(_t) && (xn = _t({ closeToast: Jn, toastProps: Zt, data: Pt })), Rt.limit && Rt.limit > 0 && ft.count > Rt.limit && er ? ft.queue.push({ toastContent: xn, toastProps: Zt, staleId: Dt }) : u(kt) ? setTimeout(() => { St(xn, Zt, Dt) }, kt) : St(xn, Zt, Dt) } function St(_t, Nt, kt) { const { toastId: Dt } = Nt; kt && at.delete(kt); const xt = { content: _t, props: Nt }; at.set(Dt, xt), c(Ct => [...Ct, Dt].filter(bt => bt !== kt)), v$2.emit(4, y$1(xt, xt.props.updateId == null ? "added" : "updated")) } return react.exports.useEffect(() => (ft.containerId = e.containerId, v$2.cancelEmit(3).on(0, wt).on(1, _t => et.current && ht(_t)).on(5, dt).emit(2, ft), () => { at.clear(), v$2.emit(3, ft) }), []), react.exports.useEffect(() => { ft.props = e, ft.isToastActive = lt, ft.displayedToast = o.length }), { getToastToRender: function (_t) { const Nt = new Map, kt = Array.from(at.values()); return e.newestOnTop && kt.reverse(), kt.forEach(Dt => { const { position: xt } = Dt.props; Nt.has(xt) || Nt.set(xt, []), Nt.get(xt).push(Dt) }), Array.from(Nt, Dt => _t(Dt[0], Dt[1])) }, containerRef: et, isToastActive: lt } } function I$1(e) { return e.targetTouches && e.targetTouches.length >= 1 ? e.targetTouches[0].clientX : e.clientX } function b$1(e) { return e.targetTouches && e.targetTouches.length >= 1 ? e.targetTouches[0].clientY : e.clientY } function _(e) { const [s, o] = react.exports.useState(!1), [c, et] = react.exports.useState(!1), at = react.exports.useRef(null), lt = react.exports.useRef({ start: 0, x: 0, y: 0, delta: 0, removalDistance: 0, canCloseOnClick: !0, canDrag: !1, boundingRect: null, didMove: !1 }).current, ft = react.exports.useRef(e), { autoClose: dt, pauseOnHover: ht, closeToast: vt, onClick: wt, closeOnClick: St } = e; function _t(Pt) { if (e.draggable) { Pt.nativeEvent.type === "touchstart" && Pt.nativeEvent.preventDefault(), lt.didMove = !1, document.addEventListener("mousemove", xt), document.addEventListener("mouseup", Ct), document.addEventListener("touchmove", xt), document.addEventListener("touchend", Ct); const Rt = at.current; lt.canCloseOnClick = !0, lt.canDrag = !0, lt.boundingRect = Rt.getBoundingClientRect(), Rt.style.transition = "", lt.x = I$1(Pt.nativeEvent), lt.y = b$1(Pt.nativeEvent), e.draggableDirection === "x" ? (lt.start = lt.x, lt.removalDistance = Rt.offsetWidth * (e.draggablePercent / 100)) : (lt.start = lt.y, lt.removalDistance = Rt.offsetHeight * (e.draggablePercent === 80 ? 1.5 * e.draggablePercent : e.draggablePercent / 100)) } } function Nt(Pt) { if (lt.boundingRect) { const { top: Rt, bottom: Jn, left: er, right: Zt } = lt.boundingRect; Pt.nativeEvent.type !== "touchend" && e.pauseOnHover && lt.x >= er && lt.x <= Zt && lt.y >= Rt && lt.y <= Jn ? Dt() : kt() } } function kt() { o(!0) } function Dt() { o(!1) } function xt(Pt) { const Rt = at.current; lt.canDrag && Rt && (lt.didMove = !0, s && Dt(), lt.x = I$1(Pt), lt.y = b$1(Pt), lt.delta = e.draggableDirection === "x" ? lt.x - lt.start : lt.y - lt.start, lt.start !== lt.x && (lt.canCloseOnClick = !1), Rt.style.transform = `translate${e.draggableDirection}(${lt.delta}px)`, Rt.style.opacity = "" + (1 - Math.abs(lt.delta / lt.removalDistance))) } function Ct() { document.removeEventListener("mousemove", xt), document.removeEventListener("mouseup", Ct), document.removeEventListener("touchmove", xt), document.removeEventListener("touchend", Ct); const Pt = at.current; if (lt.canDrag && lt.didMove && Pt) { if (lt.canDrag = !1, Math.abs(lt.delta) > lt.removalDistance) return et(!0), void e.closeToast(); Pt.style.transition = "transform 0.2s, opacity 0.2s", Pt.style.transform = `translate${e.draggableDirection}(0)`, Pt.style.opacity = "1" } } react.exports.useEffect(() => { ft.current = e }), react.exports.useEffect(() => (at.current && at.current.addEventListener("d", kt, { once: !0 }), p$1(e.onOpen) && e.onOpen(react.exports.isValidElement(e.children) && e.children.props), () => { const Pt = ft.current; p$1(Pt.onClose) && Pt.onClose(react.exports.isValidElement(Pt.children) && Pt.children.props) }), []), react.exports.useEffect(() => (e.pauseOnFocusLoss && (document.hasFocus() || Dt(), window.addEventListener("focus", kt), window.addEventListener("blur", Dt)), () => { e.pauseOnFocusLoss && (window.removeEventListener("focus", kt), window.removeEventListener("blur", Dt)) }), [e.pauseOnFocusLoss]); const bt = { onMouseDown: _t, onTouchStart: _t, onMouseUp: Nt, onTouchEnd: Nt }; return dt && ht && (bt.onMouseEnter = Dt, bt.onMouseLeave = kt), St && (bt.onClick = Pt => { wt && wt(Pt), lt.canCloseOnClick && vt() }), { playToast: kt, pauseToast: Dt, isRunning: s, preventExitTransition: c, toastRef: at, eventHandlers: bt } } function L$2(e) { let { closeToast: s, theme: o, ariaLabel: c = "close" } = e; return jsx("button", { className: `Toastify__close-button Toastify__close-button--${o}`, type: "button", onClick: et => { et.stopPropagation(), s(et) }, "aria-label": c, children: jsx("svg", { "aria-hidden": "true", viewBox: "0 0 14 16", children: jsx("path", { fillRule: "evenodd", d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z" }) }) }) } function O$2(e) { let { delay: s, isRunning: o, closeToast: c, type: et = "default", hide: at, className: lt, style: ft, controlledProgress: dt, progress: ht, rtl: vt, isIn: wt, theme: St } = e; const _t = at || dt && ht === 0, Nt = { ...ft, animationDuration: `${s}ms`, animationPlayState: o ? "running" : "paused", opacity: _t ? 0 : 1 }; dt && (Nt.transform = `scaleX(${ht})`); const kt = clsx("Toastify__progress-bar", dt ? "Toastify__progress-bar--controlled" : "Toastify__progress-bar--animated", `Toastify__progress-bar-theme--${St}`, `Toastify__progress-bar--${et}`, { "Toastify__progress-bar--rtl": vt }), Dt = p$1(lt) ? lt({ rtl: vt, type: et, defaultClassName: kt }) : clsx(kt, lt); return React.createElement("div", { role: "progressbar", "aria-hidden": _t ? "true" : "false", "aria-label": "notification timer", className: Dt, style: Nt, [dt && ht >= 1 ? "onTransitionEnd" : "onAnimationEnd"]: dt && ht < 1 ? null : () => { wt && c() } }) } const N$2 = e => { const { isRunning: s, preventExitTransition: o, toastRef: c, eventHandlers: et } = _(e), { closeButton: at, children: lt, autoClose: ft, onClick: dt, type: ht, hideProgressBar: vt, closeToast: wt, transition: St, position: _t, className: Nt, style: kt, bodyClassName: Dt, bodyStyle: xt, progressClassName: Ct, progressStyle: bt, updateId: Pt, role: Rt, progress: Jn, rtl: er, toastId: Zt, deleteToast: lr, isIn: tr, isLoading: xn, iconOut: jt, closeOnClick: Gt, theme: nr } = e, sr = clsx("Toastify__toast", `Toastify__toast-theme--${nr}`, `Toastify__toast--${ht}`, { "Toastify__toast--rtl": er }, { "Toastify__toast--close-on-click": Gt }), rr = p$1(Nt) ? Nt({ rtl: er, position: _t, type: ht, defaultClassName: sr }) : clsx(sr, Nt), ar = !!Jn || !ft, _n = { closeToast: wt, type: ht, theme: nr }; let ir = null; return at === !1 || (ir = p$1(at) ? at(_n) : react.exports.isValidElement(at) ? react.exports.cloneElement(at, _n) : L$2(_n)), React.createElement(St, { isIn: tr, done: lr, position: _t, preventExitTransition: o, nodeRef: c }, jsxs("div", { id: Zt, onClick: dt, className: rr, ...et, style: kt, ref: c, children: [jsxs("div", { ...tr && { role: Rt }, className: p$1(Dt) ? Dt({ type: ht }) : clsx("Toastify__toast-body", Dt), style: xt, children: [jt != null && jsx("div", { className: clsx("Toastify__toast-icon", { "Toastify--animate-icon Toastify__zoom-enter": !xn }), children: jt }), jsx("div", { children: lt })] }), ir, jsx(O$2, { ...Pt && !ar ? { key: `pb-${Pt}` } : {}, rtl: er, theme: nr, delay: ft, isRunning: s, isIn: tr, closeToast: wt, hide: vt, type: ht, style: bt, className: Ct, controlledProgress: ar, progress: Jn || 0 })] })) }, M$2 = function (e, s) { return s === void 0 && (s = !1), { enter: `Toastify--animate Toastify__${e}-enter`, exit: `Toastify--animate Toastify__${e}-exit`, appendPosition: s } }, R$1 = h(M$2("bounce", !0)); h(M$2("slide", !0)); h(M$2("zoom")); h(M$2("flip")); const k$2 = react.exports.forwardRef((e, s) => { const { getToastToRender: o, containerRef: c, isToastActive: et } = C$2(e), { className: at, style: lt, rtl: ft, containerId: dt } = e; function ht(vt) { const wt = clsx("Toastify__toast-container", `Toastify__toast-container--${vt}`, { "Toastify__toast-container--rtl": ft }); return p$1(at) ? at({ position: vt, rtl: ft, defaultClassName: wt }) : clsx(wt, m(at)) } return react.exports.useEffect(() => { s && (s.current = c.current) }, []), jsx("div", { ref: c, className: "Toastify", id: dt, children: o((vt, wt) => { const St = wt.length ? { ...lt } : { ...lt, pointerEvents: "none" }; return jsx("div", { className: ht(vt), style: St, children: wt.map((_t, Nt) => { let { content: kt, props: Dt } = _t; return react.exports.createElement(N$2, { ...Dt, isIn: et(Dt.toastId), style: { ...Dt.style, "--nth": Nt + 1, "--len": wt.length }, key: `toast-${Dt.key}` }, kt) }) }, `container-${vt}`) }) }) }); k$2.displayName = "ToastContainer", k$2.defaultProps = { position: "top-right", transition: R$1, autoClose: 5e3, closeButton: L$2, pauseOnHover: !0, pauseOnFocusLoss: !0, closeOnClick: !0, draggable: !0, draggablePercent: 80, draggableDirection: "x", role: "alert", theme: "light" }; let P$2, B$2 = new Map, D$1 = [], A$1 = 1; function z$2() { return "" + A$1++ } function F(e) { return e && (d(e.toastId) || u(e.toastId)) ? e.toastId : z$2() } function H$2(e, s) { return B$2.size > 0 ? v$2.emit(0, e, s) : D$1.push({ content: e, options: s }), s.toastId } function S$2(e, s) { return { ...s, type: s && s.type || e, toastId: F(s) } } function q$2(e) { return (s, o) => H$2(s, S$2(e, o)) } function Q$2(e, s) { return H$2(e, S$2("default", s)) } Q$2.loading = (e, s) => H$2(e, S$2("default", { isLoading: !0, autoClose: !1, closeOnClick: !1, closeButton: !1, draggable: !1, ...s })), Q$2.promise = function (e, s, o) { let c, { pending: et, error: at, success: lt } = s; et && (c = d(et) ? Q$2.loading(et, o) : Q$2.loading(et.render, { ...o, ...et })); const ft = { isLoading: null, autoClose: null, closeOnClick: null, closeButton: null, draggable: null, delay: 100 }, dt = (vt, wt, St) => { if (wt == null) return void Q$2.dismiss(c); const _t = { type: vt, ...ft, ...o, data: St }, Nt = d(wt) ? { render: wt } : wt; return c ? Q$2.update(c, { ..._t, ...Nt }) : Q$2(Nt.render, { ..._t, ...Nt }), St }, ht = p$1(e) ? e() : e; return ht.then(vt => dt("success", lt, vt)).catch(vt => dt("error", at, vt)), ht }, Q$2.success = q$2("success"), Q$2.info = q$2("info"), Q$2.error = q$2("error"), Q$2.warning = q$2("warning"), Q$2.warn = Q$2.warning, Q$2.dark = (e, s) => H$2(e, S$2("default", { theme: "dark", ...s })), Q$2.dismiss = e => { B$2.size > 0 ? v$2.emit(1, e) : D$1 = D$1.filter(s => e != null && s.options.toastId !== e) }, Q$2.clearWaitingQueue = function (e) { return e === void 0 && (e = {}), v$2.emit(5, e) }, Q$2.isActive = e => { let s = !1; return B$2.forEach(o => { o.isToastActive && o.isToastActive(e) && (s = !0) }), s }, Q$2.update = function (e, s) { s === void 0 && (s = {}), setTimeout(() => { const o = function (c, et) { let { containerId: at } = et; const lt = B$2.get(at || P$2); return lt && lt.getToast(c) }(e, s); if (o) { const { props: c, content: et } = o, at = { ...c, ...s, toastId: s.toastId || e, updateId: z$2() }; at.toastId !== e && (at.staleId = e); const lt = at.render || et; delete at.render, H$2(lt, at) } }, 0) }, Q$2.done = e => { Q$2.update(e, { progress: 1 }) }, Q$2.onChange = e => (v$2.on(4, e), () => { v$2.off(4, e) }), Q$2.POSITION = { TOP_LEFT: "top-left", TOP_RIGHT: "top-right", TOP_CENTER: "top-center", BOTTOM_LEFT: "bottom-left", BOTTOM_RIGHT: "bottom-right", BOTTOM_CENTER: "bottom-center" }, Q$2.TYPE = { INFO: "info", SUCCESS: "success", WARNING: "warning", ERROR: "error", DEFAULT: "default" }, v$2.on(2, e => { P$2 = e.containerId || e, B$2.set(P$2, e), D$1.forEach(s => { v$2.emit(0, s.content, s.options) }), D$1 = [] }).on(3, e => { B$2.delete(e.containerId || e), B$2.size === 0 && v$2.off(0).off(1).off(5) }); const ReactToastify = "", convert = new CryptoConvert, CryptoConvertor = () => { const [e, s] = react.exports.useState({ value: 1, crypto_1: "BTC", crypto_2: "USD", answer: 0, showAnswer: !1, target: 1, showBTC: "", showUSD: "" }), o = async () => { if (await convert.ready(), e.value) { let c = convert[e.crypto_1][e.crypto_2](e.value); s({ ...e, showAnswer: !0, answer: c, target: e.value, showBTC: e.crypto_1, showUSD: e.crypto_2 }) } else Q$2("Please Enter Value") }; return jsxs(Fragment, { children: [jsx(k$2, { position: "top-right", autoClose: 5e3, hideProgressBar: !1, newestOnTop: !1, closeOnClick: !0, rtl: !1, pauseOnFocusLoss: !0, draggable: !0, pauseOnHover: !0, theme: "light" }), jsx(k$2, {}), jsxs("div", { className: "mt-5 sm:mt-0 p-3 sm:p-10 rounded-xl converter_card", children: [jsx("p", { className: `${styles$1.paragraph} mb-3`, children: " Convert Now " }), jsx("div", { children: jsx("input", { value: e.value, onChange: c => s({ ...e, value: c.target.value }), name: "value", type: "number", placeholder: "Enter Value", className: "border border-solid border-Slate-50 outline-none px-5 py-3 rounded-2xl w-full bg-transparent" }) }), jsxs("div", { className: "flex justify-between flex-col xs:flex-row items-center my-5", children: [jsx("select", { value: e.crypto_1, onChange: c => s({ ...e, crypto_1: c.target.value }), name: "cryptValue", className: "border border-solid border-Slate-50 outline-none px-5 py-3 rounded-2xl w-[100%] xs:w-[40%] bg-transparent", children: convertor_dropdown_data1.map((c, et) => jsxs("option", { className: "bg-primary text-white", value: c.value, children: [" ", c.title, " "] }, et)) }), jsx("div", { className: "my-3 xs:my-0 w-[50px] h-[50px] primary_gradient rounded-full flex items-center justify-center text-primary ", children: jsx(VscArrowSwap, {}) }), jsx("select", { value: e.crypto_2, onChange: c => s({ ...e, crypto_2: c.target.value }), name: "currencyValue", className: "border border-solid border-Slate-50 outline-none px-5 py-3 rounded-2xl w-[100%] xs:w-[40%] bg-transparent", children: convertor_dropdown_data2.map((c, et) => jsxs("option", { className: "bg-primary text-white", value: c.value, children: [" ", c.title, " "] }, et)) })] }), jsx(Button, { title: "Convert", onclick: o }), jsx("p", { className: `${styles$1.paragraph}`, children: e.showAnswer && ` Result: ${e.target} ${e.showBTC} = ${e.answer} ${e.showUSD} ` })] })] }) }, Features = () => jsxs("section", { id: "features", className: `${styles$1.paddingY}`, children: [jsx("div", { className: "block ss:hidden min-h-[100px]" }), jsx("h2", { className: `text-center ${styles$1.heading2}`, children: "We provide you the best" }), jsx("p", { className: `${styles$1.paragraph} mt-5 text-center`, children: "Best services provided by our community" }), jsx("div", { className: ` ${styles$1.paddingY} flex items-center justify-between text-center flex-wrap`, children: features.map(e => jsxs("div", { className: " rounded-[10px] mr-5 p-5 w-[100%] ss:w-[90%] sm:w-[46%] md:w-[30%] feature-card", children: [jsx("div", { className: "text-4xl p-4 my-5 text-center inline-block w-auto primary_gradient rounded-full", children: jsx(e.icon, {}) }), jsxs("h1", { className: "text-white text-xl font-medium", children: [" ", e.title] }), jsx("p", { className: "font-normal text-greyish text-[14px] leading-[30.8px] mt-5 text-center", children: e.content })] }, e.id)) })] }), Market = () => jsxs("section", { id: "market", className: `${styles$1.paddingY}`, children: [jsx("div", { className: "block ss:hidden min-h-[100px]" }), jsxs("div", { className: "flex justify-around flex-col md:flex-row items-center", children: [jsxs("h2", { className: styles$1.heading2, children: ["Some markets that ", jsx("br", { className: "hidden md:block" }), " interests you today?"] }), jsxs("p", { className: `${styles$1.paragraph} w-[100%]`, children: ["Lorem ipsum dolor sit amet consectetur adipisicing elit. Deleniti rem ", jsx("br", {}), "optio obcaecati facilis beatae amet quos, unde itaque sequi, ", jsx("br", {}), "  accusantium repellat dolorum iure, est mollitia."] })] }), jsx("div", { className: "container mx-auto rounded-3xl sm:py-8 sm:selection:px-4 shadow sm:mt-10", children: jsx("div", { className: "grid grid-cols-1 sm:grid-cols-2  lg:grid-cols-3", children: markets.map(e => jsxs("div", { className: "sm:px-6", children: [jsx("div", { className: "my-10 text-2xl font-bold", children: e.title }), e.data.map((s, o) => jsxs("div", { className: "grid grid-cols-3 my-3", children: [jsx("p", { className: "w-[95%] font-poppins font-normal text-greyish leading-[30.8px] text-[17px]", children: s.name }), jsxs("p", { className: `${s.isNegative ? "text-red-400" : "text-green-400"} font-poppins text-right font-normal leading-[30.8px] text-[17px]`, children: [" ", s.rate] }), jsxs("p", { className: `${s.isNegative ? "text-red-400" : "text-green-400"} text-right font-poppins font-normal leading-[30.8px] text-[17px]`, children: [" ", s.percent] })] }, o))] }, e.id)) }) })] }); function isObject$3(e) { return e !== null && typeof e == "object" && "constructor" in e && e.constructor === Object } function extend$2(e = {}, s = {}) { Object.keys(s).forEach(o => { typeof e[o] > "u" ? e[o] = s[o] : isObject$3(s[o]) && isObject$3(e[o]) && Object.keys(s[o]).length > 0 && extend$2(e[o], s[o]) }) } const ssrDocument = { body: {}, addEventListener() { }, removeEventListener() { }, activeElement: { blur() { }, nodeName: "" }, querySelector() { return null }, querySelectorAll() { return [] }, getElementById() { return null }, createEvent() { return { initEvent() { } } }, createElement() { return { children: [], childNodes: [], style: {}, setAttribute() { }, getElementsByTagName() { return [] } } }, createElementNS() { return {} }, importNode() { return null }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" } }; function getDocument() { const e = typeof document < "u" ? document : {}; return extend$2(e, ssrDocument), e } const ssrWindow = { document: ssrDocument, navigator: { userAgent: "" }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" }, history: { replaceState() { }, pushState() { }, go() { }, back() { } }, CustomEvent: function e() { return this }, addEventListener() { }, removeEventListener() { }, getComputedStyle() { return { getPropertyValue() { return "" } } }, Image() { }, Date() { }, screen: {}, setTimeout() { }, clearTimeout() { }, matchMedia() { return {} }, requestAnimationFrame(e) { return typeof setTimeout > "u" ? (e(), null) : setTimeout(e, 0) }, cancelAnimationFrame(e) { typeof setTimeout > "u" || clearTimeout(e) } }; function getWindow() { const e = typeof window < "u" ? window : {}; return extend$2(e, ssrWindow), e } function makeReactive(e) { const s = e.__proto__; Object.defineProperty(e, "__proto__", { get() { return s }, set(o) { s.__proto__ = o } }) } class Dom7 extends Array { constructor(s) { typeof s == "number" ? super(s) : (super(...s || []), makeReactive(this)) } } function arrayFlat(e = []) { const s = []; return e.forEach(o => { Array.isArray(o) ? s.push(...arrayFlat(o)) : s.push(o) }), s } function arrayFilter(e, s) { return Array.prototype.filter.call(e, s) } function arrayUnique(e) { const s = []; for (let o = 0; o < e.length; o += 1)s.indexOf(e[o]) === -1 && s.push(e[o]); return s } function qsa(e, s) { if (typeof e != "string") return [e]; const o = [], c = s.querySelectorAll(e); for (let et = 0; et < c.length; et += 1)o.push(c[et]); return o } function $$1(e, s) { const o = getWindow(), c = getDocument(); let et = []; if (!s && e instanceof Dom7) return e; if (!e) return new Dom7(et); if (typeof e == "string") { const at = e.trim(); if (at.indexOf("<") >= 0 && at.indexOf(">") >= 0) { let lt = "div"; at.indexOf("<li") === 0 && (lt = "ul"), at.indexOf("<tr") === 0 && (lt = "tbody"), (at.indexOf("<td") === 0 || at.indexOf("<th") === 0) && (lt = "tr"), at.indexOf("<tbody") === 0 && (lt = "table"), at.indexOf("<option") === 0 && (lt = "select"); const ft = c.createElement(lt); ft.innerHTML = at; for (let dt = 0; dt < ft.childNodes.length; dt += 1)et.push(ft.childNodes[dt]) } else et = qsa(e.trim(), s || c) } else if (e.nodeType || e === o || e === c) et.push(e); else if (Array.isArray(e)) { if (e instanceof Dom7) return e; et = e } return new Dom7(arrayUnique(et)) } $$1.fn = Dom7.prototype; function addClass(...e) { const s = arrayFlat(e.map(o => o.split(" "))); return this.forEach(o => { o.classList.add(...s) }), this } function removeClass(...e) { const s = arrayFlat(e.map(o => o.split(" "))); return this.forEach(o => { o.classList.remove(...s) }), this } function toggleClass(...e) { const s = arrayFlat(e.map(o => o.split(" "))); this.forEach(o => { s.forEach(c => { o.classList.toggle(c) }) }) } function hasClass(...e) { const s = arrayFlat(e.map(o => o.split(" "))); return arrayFilter(this, o => s.filter(c => o.classList.contains(c)).length > 0).length > 0 } function attr(e, s) { if (arguments.length === 1 && typeof e == "string") return this[0] ? this[0].getAttribute(e) : void 0; for (let o = 0; o < this.length; o += 1)if (arguments.length === 2) this[o].setAttribute(e, s); else for (const c in e) this[o][c] = e[c], this[o].setAttribute(c, e[c]); return this } function removeAttr(e) { for (let s = 0; s < this.length; s += 1)this[s].removeAttribute(e); return this } function transform(e) { for (let s = 0; s < this.length; s += 1)this[s].style.transform = e; return this } function transition$1(e) { for (let s = 0; s < this.length; s += 1)this[s].style.transitionDuration = typeof e != "string" ? `${e}ms` : e; return this } function on$1(...e) { let [s, o, c, et] = e; typeof e[1] == "function" && ([s, c, et] = e, o = void 0), et || (et = !1); function at(ht) { const vt = ht.target; if (!vt) return; const wt = ht.target.dom7EventData || []; if (wt.indexOf(ht) < 0 && wt.unshift(ht), $$1(vt).is(o)) c.apply(vt, wt); else { const St = $$1(vt).parents(); for (let _t = 0; _t < St.length; _t += 1)$$1(St[_t]).is(o) && c.apply(St[_t], wt) } } function lt(ht) { const vt = ht && ht.target ? ht.target.dom7EventData || [] : []; vt.indexOf(ht) < 0 && vt.unshift(ht), c.apply(this, vt) } const ft = s.split(" "); let dt; for (let ht = 0; ht < this.length; ht += 1) { const vt = this[ht]; if (o) for (dt = 0; dt < ft.length; dt += 1) { const wt = ft[dt]; vt.dom7LiveListeners || (vt.dom7LiveListeners = {}), vt.dom7LiveListeners[wt] || (vt.dom7LiveListeners[wt] = []), vt.dom7LiveListeners[wt].push({ listener: c, proxyListener: at }), vt.addEventListener(wt, at, et) } else for (dt = 0; dt < ft.length; dt += 1) { const wt = ft[dt]; vt.dom7Listeners || (vt.dom7Listeners = {}), vt.dom7Listeners[wt] || (vt.dom7Listeners[wt] = []), vt.dom7Listeners[wt].push({ listener: c, proxyListener: lt }), vt.addEventListener(wt, lt, et) } } return this } function off(...e) { let [s, o, c, et] = e; typeof e[1] == "function" && ([s, c, et] = e, o = void 0), et || (et = !1); const at = s.split(" "); for (let lt = 0; lt < at.length; lt += 1) { const ft = at[lt]; for (let dt = 0; dt < this.length; dt += 1) { const ht = this[dt]; let vt; if (!o && ht.dom7Listeners ? vt = ht.dom7Listeners[ft] : o && ht.dom7LiveListeners && (vt = ht.dom7LiveListeners[ft]), vt && vt.length) for (let wt = vt.length - 1; wt >= 0; wt -= 1) { const St = vt[wt]; c && St.listener === c || c && St.listener && St.listener.dom7proxy && St.listener.dom7proxy === c ? (ht.removeEventListener(ft, St.proxyListener, et), vt.splice(wt, 1)) : c || (ht.removeEventListener(ft, St.proxyListener, et), vt.splice(wt, 1)) } } } return this } function trigger(...e) { const s = getWindow(), o = e[0].split(" "), c = e[1]; for (let et = 0; et < o.length; et += 1) { const at = o[et]; for (let lt = 0; lt < this.length; lt += 1) { const ft = this[lt]; if (s.CustomEvent) { const dt = new s.CustomEvent(at, { detail: c, bubbles: !0, cancelable: !0 }); ft.dom7EventData = e.filter((ht, vt) => vt > 0), ft.dispatchEvent(dt), ft.dom7EventData = [], delete ft.dom7EventData } } } return this } function transitionEnd$1(e) { const s = this; function o(c) { c.target === this && (e.call(this, c), s.off("transitionend", o)) } return e && s.on("transitionend", o), this } function outerWidth(e) { if (this.length > 0) { if (e) { const s = this.styles(); return this[0].offsetWidth + parseFloat(s.getPropertyValue("margin-right")) + parseFloat(s.getPropertyValue("margin-left")) } return this[0].offsetWidth } return null } function outerHeight(e) { if (this.length > 0) { if (e) { const s = this.styles(); return this[0].offsetHeight + parseFloat(s.getPropertyValue("margin-top")) + parseFloat(s.getPropertyValue("margin-bottom")) } return this[0].offsetHeight } return null } function offset() { if (this.length > 0) { const e = getWindow(), s = getDocument(), o = this[0], c = o.getBoundingClientRect(), et = s.body, at = o.clientTop || et.clientTop || 0, lt = o.clientLeft || et.clientLeft || 0, ft = o === e ? e.scrollY : o.scrollTop, dt = o === e ? e.scrollX : o.scrollLeft; return { top: c.top + ft - at, left: c.left + dt - lt } } return null } function styles() { const e = getWindow(); return this[0] ? e.getComputedStyle(this[0], null) : {} } function css(e, s) { const o = getWindow(); let c; if (arguments.length === 1) if (typeof e == "string") { if (this[0]) return o.getComputedStyle(this[0], null).getPropertyValue(e) } else { for (c = 0; c < this.length; c += 1)for (const et in e) this[c].style[et] = e[et]; return this } if (arguments.length === 2 && typeof e == "string") { for (c = 0; c < this.length; c += 1)this[c].style[e] = s; return this } return this } function each(e) { return e ? (this.forEach((s, o) => { e.apply(s, [s, o]) }), this) : this } function filter(e) { const s = arrayFilter(this, e); return $$1(s) } function html(e) { if (typeof e > "u") return this[0] ? this[0].innerHTML : null; for (let s = 0; s < this.length; s += 1)this[s].innerHTML = e; return this } function text(e) { if (typeof e > "u") return this[0] ? this[0].textContent.trim() : null; for (let s = 0; s < this.length; s += 1)this[s].textContent = e; return this } function is$1(e) { const s = getWindow(), o = getDocument(), c = this[0]; let et, at; if (!c || typeof e > "u") return !1; if (typeof e == "string") { if (c.matches) return c.matches(e); if (c.webkitMatchesSelector) return c.webkitMatchesSelector(e); if (c.msMatchesSelector) return c.msMatchesSelector(e); for (et = $$1(e), at = 0; at < et.length; at += 1)if (et[at] === c) return !0; return !1 } if (e === o) return c === o; if (e === s) return c === s; if (e.nodeType || e instanceof Dom7) { for (et = e.nodeType ? [e] : e, at = 0; at < et.length; at += 1)if (et[at] === c) return !0; return !1 } return !1 } function index$1() { let e = this[0], s; if (e) { for (s = 0; (e = e.previousSibling) !== null;)e.nodeType === 1 && (s += 1); return s } } function eq(e) { if (typeof e > "u") return this; const s = this.length; if (e > s - 1) return $$1([]); if (e < 0) { const o = s + e; return o < 0 ? $$1([]) : $$1([this[o]]) } return $$1([this[e]]) } function append(...e) { let s; const o = getDocument(); for (let c = 0; c < e.length; c += 1) { s = e[c]; for (let et = 0; et < this.length; et += 1)if (typeof s == "string") { const at = o.createElement("div"); for (at.innerHTML = s; at.firstChild;)this[et].appendChild(at.firstChild) } else if (s instanceof Dom7) for (let at = 0; at < s.length; at += 1)this[et].appendChild(s[at]); else this[et].appendChild(s) } return this } function prepend(e) { const s = getDocument(); let o, c; for (o = 0; o < this.length; o += 1)if (typeof e == "string") { const et = s.createElement("div"); for (et.innerHTML = e, c = et.childNodes.length - 1; c >= 0; c -= 1)this[o].insertBefore(et.childNodes[c], this[o].childNodes[0]) } else if (e instanceof Dom7) for (c = 0; c < e.length; c += 1)this[o].insertBefore(e[c], this[o].childNodes[0]); else this[o].insertBefore(e, this[o].childNodes[0]); return this } function next(e) { return this.length > 0 ? e ? this[0].nextElementSibling && $$1(this[0].nextElementSibling).is(e) ? $$1([this[0].nextElementSibling]) : $$1([]) : this[0].nextElementSibling ? $$1([this[0].nextElementSibling]) : $$1([]) : $$1([]) } function nextAll(e) { const s = []; let o = this[0]; if (!o) return $$1([]); for (; o.nextElementSibling;) { const c = o.nextElementSibling; e ? $$1(c).is(e) && s.push(c) : s.push(c), o = c } return $$1(s) } function prev(e) { if (this.length > 0) { const s = this[0]; return e ? s.previousElementSibling && $$1(s.previousElementSibling).is(e) ? $$1([s.previousElementSibling]) : $$1([]) : s.previousElementSibling ? $$1([s.previousElementSibling]) : $$1([]) } return $$1([]) } function prevAll(e) { const s = []; let o = this[0]; if (!o) return $$1([]); for (; o.previousElementSibling;) { const c = o.previousElementSibling; e ? $$1(c).is(e) && s.push(c) : s.push(c), o = c } return $$1(s) } function parent(e) { const s = []; for (let o = 0; o < this.length; o += 1)this[o].parentNode !== null && (e ? $$1(this[o].parentNode).is(e) && s.push(this[o].parentNode) : s.push(this[o].parentNode)); return $$1(s) } function parents(e) { const s = []; for (let o = 0; o < this.length; o += 1) { let c = this[o].parentNode; for (; c;)e ? $$1(c).is(e) && s.push(c) : s.push(c), c = c.parentNode } return $$1(s) } function closest(e) { let s = this; return typeof e > "u" ? $$1([]) : (s.is(e) || (s = s.parents(e).eq(0)), s) } function find(e) { const s = []; for (let o = 0; o < this.length; o += 1) { const c = this[o].querySelectorAll(e); for (let et = 0; et < c.length; et += 1)s.push(c[et]) } return $$1(s) } function children(e) { const s = []; for (let o = 0; o < this.length; o += 1) { const c = this[o].children; for (let et = 0; et < c.length; et += 1)(!e || $$1(c[et]).is(e)) && s.push(c[et]) } return $$1(s) } function remove() { for (let e = 0; e < this.length; e += 1)this[e].parentNode && this[e].parentNode.removeChild(this[e]); return this } const Methods = { addClass, removeClass, hasClass, toggleClass, attr, removeAttr, transform, transition: transition$1, on: on$1, off, trigger, transitionEnd: transitionEnd$1, outerWidth, outerHeight, styles, offset, css, each, html, text, is: is$1, index: index$1, eq, append, prepend, next, nextAll, prev, prevAll, parent, parents, closest, find, children, filter, remove }; Object.keys(Methods).forEach(e => { Object.defineProperty($$1.fn, e, { value: Methods[e], writable: !0 }) }); function deleteProps(e) { const s = e; Object.keys(s).forEach(o => { try { s[o] = null } catch { } try { delete s[o] } catch { } }) } function nextTick(e, s = 0) { return setTimeout(e, s) } function now() { return Date.now() } function getComputedStyle$1(e) { const s = getWindow(); let o; return s.getComputedStyle && (o = s.getComputedStyle(e, null)), !o && e.currentStyle && (o = e.currentStyle), o || (o = e.style), o } function getTranslate(e, s = "x") { const o = getWindow(); let c, et, at; const lt = getComputedStyle$1(e); return o.WebKitCSSMatrix ? (et = lt.transform || lt.webkitTransform, et.split(",").length > 6 && (et = et.split(", ").map(ft => ft.replace(",", ".")).join(", ")), at = new o.WebKitCSSMatrix(et === "none" ? "" : et)) : (at = lt.MozTransform || lt.OTransform || lt.MsTransform || lt.msTransform || lt.transform || lt.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), c = at.toString().split(",")), s === "x" && (o.WebKitCSSMatrix ? et = at.m41 : c.length === 16 ? et = parseFloat(c[12]) : et = parseFloat(c[4])), s === "y" && (o.WebKitCSSMatrix ? et = at.m42 : c.length === 16 ? et = parseFloat(c[13]) : et = parseFloat(c[5])), et || 0 } function isObject$2(e) { return typeof e == "object" && e !== null && e.constructor && Object.prototype.toString.call(e).slice(8, -1) === "Object" } function isNode(e) { return typeof window < "u" && typeof window.HTMLElement < "u" ? e instanceof HTMLElement : e && (e.nodeType === 1 || e.nodeType === 11) } function extend$1(...e) { const s = Object(e[0]), o = ["__proto__", "constructor", "prototype"]; for (let c = 1; c < e.length; c += 1) { const et = e[c]; if (et != null && !isNode(et)) { const at = Object.keys(Object(et)).filter(lt => o.indexOf(lt) < 0); for (let lt = 0, ft = at.length; lt < ft; lt += 1) { const dt = at[lt], ht = Object.getOwnPropertyDescriptor(et, dt); ht !== void 0 && ht.enumerable && (isObject$2(s[dt]) && isObject$2(et[dt]) ? et[dt].__swiper__ ? s[dt] = et[dt] : extend$1(s[dt], et[dt]) : !isObject$2(s[dt]) && isObject$2(et[dt]) ? (s[dt] = {}, et[dt].__swiper__ ? s[dt] = et[dt] : extend$1(s[dt], et[dt])) : s[dt] = et[dt]) } } } return s } function setCSSProperty(e, s, o) { e.style.setProperty(s, o) } function animateCSSModeScroll({ swiper: e, targetPosition: s, side: o }) { const c = getWindow(), et = -e.translate; let at = null, lt; const ft = e.params.speed; e.wrapperEl.style.scrollSnapType = "none", c.cancelAnimationFrame(e.cssModeFrameID); const dt = s > et ? "next" : "prev", ht = (wt, St) => dt === "next" && wt >= St || dt === "prev" && wt <= St, vt = () => { lt = new Date().getTime(), at === null && (at = lt); const wt = Math.max(Math.min((lt - at) / ft, 1), 0), St = .5 - Math.cos(wt * Math.PI) / 2; let _t = et + St * (s - et); if (ht(_t, s) && (_t = s), e.wrapperEl.scrollTo({ [o]: _t }), ht(_t, s)) { e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.scrollSnapType = "", setTimeout(() => { e.wrapperEl.style.overflow = "", e.wrapperEl.scrollTo({ [o]: _t }) }), c.cancelAnimationFrame(e.cssModeFrameID); return } e.cssModeFrameID = c.requestAnimationFrame(vt) }; vt() } let support; function calcSupport() { const e = getWindow(), s = getDocument(); return { smoothScroll: s.documentElement && "scrollBehavior" in s.documentElement.style, touch: !!("ontouchstart" in e || e.DocumentTouch && s instanceof e.DocumentTouch), passiveListener: function () { let c = !1; try { const et = Object.defineProperty({}, "passive", { get() { c = !0 } }); e.addEventListener("testPassiveListener", null, et) } catch { } return c }(), gestures: function () { return "ongesturestart" in e }() } } function getSupport() { return support || (support = calcSupport()), support } let deviceCached; function calcDevice({ userAgent: e } = {}) { const s = getSupport(), o = getWindow(), c = o.navigator.platform, et = e || o.navigator.userAgent, at = { ios: !1, android: !1 }, lt = o.screen.width, ft = o.screen.height, dt = et.match(/(Android);?[\s\/]+([\d.]+)?/); let ht = et.match(/(iPad).*OS\s([\d_]+)/); const vt = et.match(/(iPod)(.*OS\s([\d_]+))?/), wt = !ht && et.match(/(iPhone\sOS|iOS)\s([\d_]+)/), St = c === "Win32"; let _t = c === "MacIntel"; const Nt = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"]; return !ht && _t && s.touch && Nt.indexOf(`${lt}x${ft}`) >= 0 && (ht = et.match(/(Version)\/([\d.]+)/), ht || (ht = [0, 1, "13_0_0"]), _t = !1), dt && !St && (at.os = "android", at.android = !0), (ht || wt || vt) && (at.os = "ios", at.ios = !0), at } function getDevice(e = {}) { return deviceCached || (deviceCached = calcDevice(e)), deviceCached } let browser; function calcBrowser() { const e = getWindow(); function s() { const o = e.navigator.userAgent.toLowerCase(); return o.indexOf("safari") >= 0 && o.indexOf("chrome") < 0 && o.indexOf("android") < 0 } return { isSafari: s(), isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent) } } function getBrowser() { return browser || (browser = calcBrowser()), browser } function Resize({ swiper: e, on: s, emit: o }) { const c = getWindow(); let et = null, at = null; const lt = () => { !e || e.destroyed || !e.initialized || (o("beforeResize"), o("resize")) }, ft = () => { !e || e.destroyed || !e.initialized || (et = new ResizeObserver(vt => { at = c.requestAnimationFrame(() => { const { width: wt, height: St } = e; let _t = wt, Nt = St; vt.forEach(({ contentBoxSize: kt, contentRect: Dt, target: xt }) => { xt && xt !== e.el || (_t = Dt ? Dt.width : (kt[0] || kt).inlineSize, Nt = Dt ? Dt.height : (kt[0] || kt).blockSize) }), (_t !== wt || Nt !== St) && lt() }) }), et.observe(e.el)) }, dt = () => { at && c.cancelAnimationFrame(at), et && et.unobserve && e.el && (et.unobserve(e.el), et = null) }, ht = () => { !e || e.destroyed || !e.initialized || o("orientationchange") }; s("init", () => { if (e.params.resizeObserver && typeof c.ResizeObserver < "u") { ft(); return } c.addEventListener("resize", lt), c.addEventListener("orientationchange", ht) }), s("destroy", () => { dt(), c.removeEventListener("resize", lt), c.removeEventListener("orientationchange", ht) }) } function Observer({ swiper: e, extendParams: s, on: o, emit: c }) { const et = [], at = getWindow(), lt = (ht, vt = {}) => { const wt = at.MutationObserver || at.WebkitMutationObserver, St = new wt(_t => { if (_t.length === 1) { c("observerUpdate", _t[0]); return } const Nt = function () { c("observerUpdate", _t[0]) }; at.requestAnimationFrame ? at.requestAnimationFrame(Nt) : at.setTimeout(Nt, 0) }); St.observe(ht, { attributes: typeof vt.attributes > "u" ? !0 : vt.attributes, childList: typeof vt.childList > "u" ? !0 : vt.childList, characterData: typeof vt.characterData > "u" ? !0 : vt.characterData }), et.push(St) }, ft = () => { if (!!e.params.observer) { if (e.params.observeParents) { const ht = e.$el.parents(); for (let vt = 0; vt < ht.length; vt += 1)lt(ht[vt]) } lt(e.$el[0], { childList: e.params.observeSlideChildren }), lt(e.$wrapperEl[0], { attributes: !1 }) } }, dt = () => { et.forEach(ht => { ht.disconnect() }), et.splice(0, et.length) }; s({ observer: !1, observeParents: !1, observeSlideChildren: !1 }), o("init", ft), o("destroy", dt) } const eventsEmitter = { on(e, s, o) { const c = this; if (!c.eventsListeners || c.destroyed || typeof s != "function") return c; const et = o ? "unshift" : "push"; return e.split(" ").forEach(at => { c.eventsListeners[at] || (c.eventsListeners[at] = []), c.eventsListeners[at][et](s) }), c }, once(e, s, o) { const c = this; if (!c.eventsListeners || c.destroyed || typeof s != "function") return c; function et(...at) { c.off(e, et), et.__emitterProxy && delete et.__emitterProxy, s.apply(c, at) } return et.__emitterProxy = s, c.on(e, et, o) }, onAny(e, s) { const o = this; if (!o.eventsListeners || o.destroyed || typeof e != "function") return o; const c = s ? "unshift" : "push"; return o.eventsAnyListeners.indexOf(e) < 0 && o.eventsAnyListeners[c](e), o }, offAny(e) { const s = this; if (!s.eventsListeners || s.destroyed || !s.eventsAnyListeners) return s; const o = s.eventsAnyListeners.indexOf(e); return o >= 0 && s.eventsAnyListeners.splice(o, 1), s }, off(e, s) { const o = this; return !o.eventsListeners || o.destroyed || !o.eventsListeners || e.split(" ").forEach(c => { typeof s > "u" ? o.eventsListeners[c] = [] : o.eventsListeners[c] && o.eventsListeners[c].forEach((et, at) => { (et === s || et.__emitterProxy && et.__emitterProxy === s) && o.eventsListeners[c].splice(at, 1) }) }), o }, emit(...e) { const s = this; if (!s.eventsListeners || s.destroyed || !s.eventsListeners) return s; let o, c, et; return typeof e[0] == "string" || Array.isArray(e[0]) ? (o = e[0], c = e.slice(1, e.length), et = s) : (o = e[0].events, c = e[0].data, et = e[0].context || s), c.unshift(et), (Array.isArray(o) ? o : o.split(" ")).forEach(lt => { s.eventsAnyListeners && s.eventsAnyListeners.length && s.eventsAnyListeners.forEach(ft => { ft.apply(et, [lt, ...c]) }), s.eventsListeners && s.eventsListeners[lt] && s.eventsListeners[lt].forEach(ft => { ft.apply(et, c) }) }), s } }; function updateSize() { const e = this; let s, o; const c = e.$el; typeof e.params.width < "u" && e.params.width !== null ? s = e.params.width : s = c[0].clientWidth, typeof e.params.height < "u" && e.params.height !== null ? o = e.params.height : o = c[0].clientHeight, !(s === 0 && e.isHorizontal() || o === 0 && e.isVertical()) && (s = s - parseInt(c.css("padding-left") || 0, 10) - parseInt(c.css("padding-right") || 0, 10), o = o - parseInt(c.css("padding-top") || 0, 10) - parseInt(c.css("padding-bottom") || 0, 10), Number.isNaN(s) && (s = 0), Number.isNaN(o) && (o = 0), Object.assign(e, { width: s, height: o, size: e.isHorizontal() ? s : o })) } function updateSlides() { const e = this; function s(tr) { return e.isHorizontal() ? tr : { width: "height", "margin-top": "margin-left", "margin-bottom ": "margin-right", "margin-left": "margin-top", "margin-right": "margin-bottom", "padding-left": "padding-top", "padding-right": "padding-bottom", marginRight: "marginBottom" }[tr] } function o(tr, xn) { return parseFloat(tr.getPropertyValue(s(xn)) || 0) } const c = e.params, { $wrapperEl: et, size: at, rtlTranslate: lt, wrongRTL: ft } = e, dt = e.virtual && c.virtual.enabled, ht = dt ? e.virtual.slides.length : e.slides.length, vt = et.children(`.${e.params.slideClass}`), wt = dt ? e.virtual.slides.length : vt.length; let St = []; const _t = [], Nt = []; let kt = c.slidesOffsetBefore; typeof kt == "function" && (kt = c.slidesOffsetBefore.call(e)); let Dt = c.slidesOffsetAfter; typeof Dt == "function" && (Dt = c.slidesOffsetAfter.call(e)); const xt = e.snapGrid.length, Ct = e.slidesGrid.length; let bt = c.spaceBetween, Pt = -kt, Rt = 0, Jn = 0; if (typeof at > "u") return; typeof bt == "string" && bt.indexOf("%") >= 0 && (bt = parseFloat(bt.replace("%", "")) / 100 * at), e.virtualSize = -bt, lt ? vt.css({ marginLeft: "", marginBottom: "", marginTop: "" }) : vt.css({ marginRight: "", marginBottom: "", marginTop: "" }), c.centeredSlides && c.cssMode && (setCSSProperty(e.wrapperEl, "--swiper-centered-offset-before", ""), setCSSProperty(e.wrapperEl, "--swiper-centered-offset-after", "")); const er = c.grid && c.grid.rows > 1 && e.grid; er && e.grid.initSlides(wt); let Zt; const lr = c.slidesPerView === "auto" && c.breakpoints && Object.keys(c.breakpoints).filter(tr => typeof c.breakpoints[tr].slidesPerView < "u").length > 0; for (let tr = 0; tr < wt; tr += 1) { Zt = 0; const xn = vt.eq(tr); if (er && e.grid.updateSlide(tr, xn, wt, s), xn.css("display") !== "none") { if (c.slidesPerView === "auto") { lr && (vt[tr].style[s("width")] = ""); const jt = getComputedStyle(xn[0]), Gt = xn[0].style.transform, nr = xn[0].style.webkitTransform; if (Gt && (xn[0].style.transform = "none"), nr && (xn[0].style.webkitTransform = "none"), c.roundLengths) Zt = e.isHorizontal() ? xn.outerWidth(!0) : xn.outerHeight(!0); else { const sr = o(jt, "width"), rr = o(jt, "padding-left"), ar = o(jt, "padding-right"), _n = o(jt, "margin-left"), ir = o(jt, "margin-right"), or = jt.getPropertyValue("box-sizing"); if (or && or === "border-box") Zt = sr + _n + ir; else { const { clientWidth: ur, offsetWidth: hr } = xn[0]; Zt = sr + rr + ar + _n + ir + (hr - ur) } } Gt && (xn[0].style.transform = Gt), nr && (xn[0].style.webkitTransform = nr), c.roundLengths && (Zt = Math.floor(Zt)) } else Zt = (at - (c.slidesPerView - 1) * bt) / c.slidesPerView, c.roundLengths && (Zt = Math.floor(Zt)), vt[tr] && (vt[tr].style[s("width")] = `${Zt}px`); vt[tr] && (vt[tr].swiperSlideSize = Zt), Nt.push(Zt), c.centeredSlides ? (Pt = Pt + Zt / 2 + Rt / 2 + bt, Rt === 0 && tr !== 0 && (Pt = Pt - at / 2 - bt), tr === 0 && (Pt = Pt - at / 2 - bt), Math.abs(Pt) < 1 / 1e3 && (Pt = 0), c.roundLengths && (Pt = Math.floor(Pt)), Jn % c.slidesPerGroup === 0 && St.push(Pt), _t.push(Pt)) : (c.roundLengths && (Pt = Math.floor(Pt)), (Jn - Math.min(e.params.slidesPerGroupSkip, Jn)) % e.params.slidesPerGroup === 0 && St.push(Pt), _t.push(Pt), Pt = Pt + Zt + bt), e.virtualSize += Zt + bt, Rt = Zt, Jn += 1 } } if (e.virtualSize = Math.max(e.virtualSize, at) + Dt, lt && ft && (c.effect === "slide" || c.effect === "coverflow") && et.css({ width: `${e.virtualSize + c.spaceBetween}px` }), c.setWrapperSize && et.css({ [s("width")]: `${e.virtualSize + c.spaceBetween}px` }), er && e.grid.updateWrapperSize(Zt, St, s), !c.centeredSlides) { const tr = []; for (let xn = 0; xn < St.length; xn += 1) { let jt = St[xn]; c.roundLengths && (jt = Math.floor(jt)), St[xn] <= e.virtualSize - at && tr.push(jt) } St = tr, Math.floor(e.virtualSize - at) - Math.floor(St[St.length - 1]) > 1 && St.push(e.virtualSize - at) } if (St.length === 0 && (St = [0]), c.spaceBetween !== 0) { const tr = e.isHorizontal() && lt ? "marginLeft" : s("marginRight"); vt.filter((xn, jt) => c.cssMode ? jt !== vt.length - 1 : !0).css({ [tr]: `${bt}px` }) } if (c.centeredSlides && c.centeredSlidesBounds) { let tr = 0; Nt.forEach(jt => { tr += jt + (c.spaceBetween ? c.spaceBetween : 0) }), tr -= c.spaceBetween; const xn = tr - at; St = St.map(jt => jt < 0 ? -kt : jt > xn ? xn + Dt : jt) } if (c.centerInsufficientSlides) { let tr = 0; if (Nt.forEach(xn => { tr += xn + (c.spaceBetween ? c.spaceBetween : 0) }), tr -= c.spaceBetween, tr < at) { const xn = (at - tr) / 2; St.forEach((jt, Gt) => { St[Gt] = jt - xn }), _t.forEach((jt, Gt) => { _t[Gt] = jt + xn }) } } if (Object.assign(e, { slides: vt, snapGrid: St, slidesGrid: _t, slidesSizesGrid: Nt }), c.centeredSlides && c.cssMode && !c.centeredSlidesBounds) { setCSSProperty(e.wrapperEl, "--swiper-centered-offset-before", `${-St[0]}px`), setCSSProperty(e.wrapperEl, "--swiper-centered-offset-after", `${e.size / 2 - Nt[Nt.length - 1] / 2}px`); const tr = -e.snapGrid[0], xn = -e.slidesGrid[0]; e.snapGrid = e.snapGrid.map(jt => jt + tr), e.slidesGrid = e.slidesGrid.map(jt => jt + xn) } if (wt !== ht && e.emit("slidesLengthChange"), St.length !== xt && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), _t.length !== Ct && e.emit("slidesGridLengthChange"), c.watchSlidesProgress && e.updateSlidesOffset(), !dt && !c.cssMode && (c.effect === "slide" || c.effect === "fade")) { const tr = `${c.containerModifierClass}backface-hidden`, xn = e.$el.hasClass(tr); wt <= c.maxBackfaceHiddenSlides ? xn || e.$el.addClass(tr) : xn && e.$el.removeClass(tr) } } function updateAutoHeight(e) { const s = this, o = [], c = s.virtual && s.params.virtual.enabled; let et = 0, at; typeof e == "number" ? s.setTransition(e) : e === !0 && s.setTransition(s.params.speed); const lt = ft => c ? s.slides.filter(dt => parseInt(dt.getAttribute("data-swiper-slide-index"), 10) === ft)[0] : s.slides.eq(ft)[0]; if (s.params.slidesPerView !== "auto" && s.params.slidesPerView > 1) if (s.params.centeredSlides) (s.visibleSlides || $$1([])).each(ft => { o.push(ft) }); else for (at = 0; at < Math.ceil(s.params.slidesPerView); at += 1) { const ft = s.activeIndex + at; if (ft > s.slides.length && !c) break; o.push(lt(ft)) } else o.push(lt(s.activeIndex)); for (at = 0; at < o.length; at += 1)if (typeof o[at] < "u") { const ft = o[at].offsetHeight; et = ft > et ? ft : et } (et || et === 0) && s.$wrapperEl.css("height", `${et}px`) } function updateSlidesOffset() { const e = this, s = e.slides; for (let o = 0; o < s.length; o += 1)s[o].swiperSlideOffset = e.isHorizontal() ? s[o].offsetLeft : s[o].offsetTop } function updateSlidesProgress(e = this && this.translate || 0) { const s = this, o = s.params, { slides: c, rtlTranslate: et, snapGrid: at } = s; if (c.length === 0) return; typeof c[0].swiperSlideOffset > "u" && s.updateSlidesOffset(); let lt = -e; et && (lt = e), c.removeClass(o.slideVisibleClass), s.visibleSlidesIndexes = [], s.visibleSlides = []; for (let ft = 0; ft < c.length; ft += 1) { const dt = c[ft]; let ht = dt.swiperSlideOffset; o.cssMode && o.centeredSlides && (ht -= c[0].swiperSlideOffset); const vt = (lt + (o.centeredSlides ? s.minTranslate() : 0) - ht) / (dt.swiperSlideSize + o.spaceBetween), wt = (lt - at[0] + (o.centeredSlides ? s.minTranslate() : 0) - ht) / (dt.swiperSlideSize + o.spaceBetween), St = -(lt - ht), _t = St + s.slidesSizesGrid[ft]; (St >= 0 && St < s.size - 1 || _t > 1 && _t <= s.size || St <= 0 && _t >= s.size) && (s.visibleSlides.push(dt), s.visibleSlidesIndexes.push(ft), c.eq(ft).addClass(o.slideVisibleClass)), dt.progress = et ? -vt : vt, dt.originalProgress = et ? -wt : wt } s.visibleSlides = $$1(s.visibleSlides) } function updateProgress(e) { const s = this; if (typeof e > "u") { const ht = s.rtlTranslate ? -1 : 1; e = s && s.translate && s.translate * ht || 0 } const o = s.params, c = s.maxTranslate() - s.minTranslate(); let { progress: et, isBeginning: at, isEnd: lt } = s; const ft = at, dt = lt; c === 0 ? (et = 0, at = !0, lt = !0) : (et = (e - s.minTranslate()) / c, at = et <= 0, lt = et >= 1), Object.assign(s, { progress: et, isBeginning: at, isEnd: lt }), (o.watchSlidesProgress || o.centeredSlides && o.autoHeight) && s.updateSlidesProgress(e), at && !ft && s.emit("reachBeginning toEdge"), lt && !dt && s.emit("reachEnd toEdge"), (ft && !at || dt && !lt) && s.emit("fromEdge"), s.emit("progress", et) } function updateSlidesClasses() { const e = this, { slides: s, params: o, $wrapperEl: c, activeIndex: et, realIndex: at } = e, lt = e.virtual && o.virtual.enabled; s.removeClass(`${o.slideActiveClass} ${o.slideNextClass} ${o.slidePrevClass} ${o.slideDuplicateActiveClass} ${o.slideDuplicateNextClass} ${o.slideDuplicatePrevClass}`); let ft; lt ? ft = e.$wrapperEl.find(`.${o.slideClass}[data-swiper-slide-index="${et}"]`) : ft = s.eq(et), ft.addClass(o.slideActiveClass), o.loop && (ft.hasClass(o.slideDuplicateClass) ? c.children(`.${o.slideClass}:not(.${o.slideDuplicateClass})[data-swiper-slide-index="${at}"]`).addClass(o.slideDuplicateActiveClass) : c.children(`.${o.slideClass}.${o.slideDuplicateClass}[data-swiper-slide-index="${at}"]`).addClass(o.slideDuplicateActiveClass)); let dt = ft.nextAll(`.${o.slideClass}`).eq(0).addClass(o.slideNextClass); o.loop && dt.length === 0 && (dt = s.eq(0), dt.addClass(o.slideNextClass)); let ht = ft.prevAll(`.${o.slideClass}`).eq(0).addClass(o.slidePrevClass); o.loop && ht.length === 0 && (ht = s.eq(-1), ht.addClass(o.slidePrevClass)), o.loop && (dt.hasClass(o.slideDuplicateClass) ? c.children(`.${o.slideClass}:not(.${o.slideDuplicateClass})[data-swiper-slide-index="${dt.attr("data-swiper-slide-index")}"]`).addClass(o.slideDuplicateNextClass) : c.children(`.${o.slideClass}.${o.slideDuplicateClass}[data-swiper-slide-index="${dt.attr("data-swiper-slide-index")}"]`).addClass(o.slideDuplicateNextClass), ht.hasClass(o.slideDuplicateClass) ? c.children(`.${o.slideClass}:not(.${o.slideDuplicateClass})[data-swiper-slide-index="${ht.attr("data-swiper-slide-index")}"]`).addClass(o.slideDuplicatePrevClass) : c.children(`.${o.slideClass}.${o.slideDuplicateClass}[data-swiper-slide-index="${ht.attr("data-swiper-slide-index")}"]`).addClass(o.slideDuplicatePrevClass)), e.emitSlidesClasses() } function updateActiveIndex(e) { const s = this, o = s.rtlTranslate ? s.translate : -s.translate, { slidesGrid: c, snapGrid: et, params: at, activeIndex: lt, realIndex: ft, snapIndex: dt } = s; let ht = e, vt; if (typeof ht > "u") { for (let St = 0; St < c.length; St += 1)typeof c[St + 1] < "u" ? o >= c[St] && o < c[St + 1] - (c[St + 1] - c[St]) / 2 ? ht = St : o >= c[St] && o < c[St + 1] && (ht = St + 1) : o >= c[St] && (ht = St); at.normalizeSlideIndex && (ht < 0 || typeof ht > "u") && (ht = 0) } if (et.indexOf(o) >= 0) vt = et.indexOf(o); else { const St = Math.min(at.slidesPerGroupSkip, ht); vt = St + Math.floor((ht - St) / at.slidesPerGroup) } if (vt >= et.length && (vt = et.length - 1), ht === lt) { vt !== dt && (s.snapIndex = vt, s.emit("snapIndexChange")); return } const wt = parseInt(s.slides.eq(ht).attr("data-swiper-slide-index") || ht, 10); Object.assign(s, { snapIndex: vt, realIndex: wt, previousIndex: lt, activeIndex: ht }), s.emit("activeIndexChange"), s.emit("snapIndexChange"), ft !== wt && s.emit("realIndexChange"), (s.initialized || s.params.runCallbacksOnInit) && s.emit("slideChange") } function updateClickedSlide(e) { const s = this, o = s.params, c = $$1(e).closest(`.${o.slideClass}`)[0]; let et = !1, at; if (c) { for (let lt = 0; lt < s.slides.length; lt += 1)if (s.slides[lt] === c) { et = !0, at = lt; break } } if (c && et) s.clickedSlide = c, s.virtual && s.params.virtual.enabled ? s.clickedIndex = parseInt($$1(c).attr("data-swiper-slide-index"), 10) : s.clickedIndex = at; else { s.clickedSlide = void 0, s.clickedIndex = void 0; return } o.slideToClickedSlide && s.clickedIndex !== void 0 && s.clickedIndex !== s.activeIndex && s.slideToClickedSlide() } const update = { updateSize, updateSlides, updateAutoHeight, updateSlidesOffset, updateSlidesProgress, updateProgress, updateSlidesClasses, updateActiveIndex, updateClickedSlide }; function getSwiperTranslate(e = this.isHorizontal() ? "x" : "y") { const s = this, { params: o, rtlTranslate: c, translate: et, $wrapperEl: at } = s; if (o.virtualTranslate) return c ? -et : et; if (o.cssMode) return et; let lt = getTranslate(at[0], e); return c && (lt = -lt), lt || 0 } function setTranslate(e, s) { const o = this, { rtlTranslate: c, params: et, $wrapperEl: at, wrapperEl: lt, progress: ft } = o; let dt = 0, ht = 0; const vt = 0; o.isHorizontal() ? dt = c ? -e : e : ht = e, et.roundLengths && (dt = Math.floor(dt), ht = Math.floor(ht)), et.cssMode ? lt[o.isHorizontal() ? "scrollLeft" : "scrollTop"] = o.isHorizontal() ? -dt : -ht : et.virtualTranslate || at.transform(`translate3d(${dt}px, ${ht}px, ${vt}px)`), o.previousTranslate = o.translate, o.translate = o.isHorizontal() ? dt : ht; let wt; const St = o.maxTranslate() - o.minTranslate(); St === 0 ? wt = 0 : wt = (e - o.minTranslate()) / St, wt !== ft && o.updateProgress(e), o.emit("setTranslate", o.translate, s) } function minTranslate() { return -this.snapGrid[0] } function maxTranslate() { return -this.snapGrid[this.snapGrid.length - 1] } function translateTo(e = 0, s = this.params.speed, o = !0, c = !0, et) { const at = this, { params: lt, wrapperEl: ft } = at; if (at.animating && lt.preventInteractionOnTransition) return !1; const dt = at.minTranslate(), ht = at.maxTranslate(); let vt; if (c && e > dt ? vt = dt : c && e < ht ? vt = ht : vt = e, at.updateProgress(vt), lt.cssMode) { const wt = at.isHorizontal(); if (s === 0) ft[wt ? "scrollLeft" : "scrollTop"] = -vt; else { if (!at.support.smoothScroll) return animateCSSModeScroll({ swiper: at, targetPosition: -vt, side: wt ? "left" : "top" }), !0; ft.scrollTo({ [wt ? "left" : "top"]: -vt, behavior: "smooth" }) } return !0 } return s === 0 ? (at.setTransition(0), at.setTranslate(vt), o && (at.emit("beforeTransitionStart", s, et), at.emit("transitionEnd"))) : (at.setTransition(s), at.setTranslate(vt), o && (at.emit("beforeTransitionStart", s, et), at.emit("transitionStart")), at.animating || (at.animating = !0, at.onTranslateToWrapperTransitionEnd || (at.onTranslateToWrapperTransitionEnd = function (St) { !at || at.destroyed || St.target === this && (at.$wrapperEl[0].removeEventListener("transitionend", at.onTranslateToWrapperTransitionEnd), at.$wrapperEl[0].removeEventListener("webkitTransitionEnd", at.onTranslateToWrapperTransitionEnd), at.onTranslateToWrapperTransitionEnd = null, delete at.onTranslateToWrapperTransitionEnd, o && at.emit("transitionEnd")) }), at.$wrapperEl[0].addEventListener("transitionend", at.onTranslateToWrapperTransitionEnd), at.$wrapperEl[0].addEventListener("webkitTransitionEnd", at.onTranslateToWrapperTransitionEnd))), !0 } const translate = { getTranslate: getSwiperTranslate, setTranslate, minTranslate, maxTranslate, translateTo }; function setTransition(e, s) { const o = this; o.params.cssMode || o.$wrapperEl.transition(e), o.emit("setTransition", e, s) } function transitionEmit({ swiper: e, runCallbacks: s, direction: o, step: c }) { const { activeIndex: et, previousIndex: at } = e; let lt = o; if (lt || (et > at ? lt = "next" : et < at ? lt = "prev" : lt = "reset"), e.emit(`transition${c}`), s && et !== at) { if (lt === "reset") { e.emit(`slideResetTransition${c}`); return } e.emit(`slideChangeTransition${c}`), lt === "next" ? e.emit(`slideNextTransition${c}`) : e.emit(`slidePrevTransition${c}`) } } function transitionStart(e = !0, s) { const o = this, { params: c } = o; c.cssMode || (c.autoHeight && o.updateAutoHeight(), transitionEmit({ swiper: o, runCallbacks: e, direction: s, step: "Start" })) } function transitionEnd(e = !0, s) { const o = this, { params: c } = o; o.animating = !1, !c.cssMode && (o.setTransition(0), transitionEmit({ swiper: o, runCallbacks: e, direction: s, step: "End" })) } const transition = { setTransition, transitionStart, transitionEnd }; function slideTo(e = 0, s = this.params.speed, o = !0, c, et) { if (typeof e != "number" && typeof e != "string") throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof e}] given.`); if (typeof e == "string") { const bt = parseInt(e, 10); if (!isFinite(bt)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`); e = bt } const at = this; let lt = e; lt < 0 && (lt = 0); const { params: ft, snapGrid: dt, slidesGrid: ht, previousIndex: vt, activeIndex: wt, rtlTranslate: St, wrapperEl: _t, enabled: Nt } = at; if (at.animating && ft.preventInteractionOnTransition || !Nt && !c && !et) return !1; const kt = Math.min(at.params.slidesPerGroupSkip, lt); let Dt = kt + Math.floor((lt - kt) / at.params.slidesPerGroup); Dt >= dt.length && (Dt = dt.length - 1); const xt = -dt[Dt]; if (ft.normalizeSlideIndex) for (let bt = 0; bt < ht.length; bt += 1) { const Pt = -Math.floor(xt * 100), Rt = Math.floor(ht[bt] * 100), Jn = Math.floor(ht[bt + 1] * 100); typeof ht[bt + 1] < "u" ? Pt >= Rt && Pt < Jn - (Jn - Rt) / 2 ? lt = bt : Pt >= Rt && Pt < Jn && (lt = bt + 1) : Pt >= Rt && (lt = bt) } if (at.initialized && lt !== wt && (!at.allowSlideNext && xt < at.translate && xt < at.minTranslate() || !at.allowSlidePrev && xt > at.translate && xt > at.maxTranslate() && (wt || 0) !== lt)) return !1; lt !== (vt || 0) && o && at.emit("beforeSlideChangeStart"), at.updateProgress(xt); let Ct; if (lt > wt ? Ct = "next" : lt < wt ? Ct = "prev" : Ct = "reset", St && -xt === at.translate || !St && xt === at.translate) return at.updateActiveIndex(lt), ft.autoHeight && at.updateAutoHeight(), at.updateSlidesClasses(), ft.effect !== "slide" && at.setTranslate(xt), Ct !== "reset" && (at.transitionStart(o, Ct), at.transitionEnd(o, Ct)), !1; if (ft.cssMode) { const bt = at.isHorizontal(), Pt = St ? xt : -xt; if (s === 0) { const Rt = at.virtual && at.params.virtual.enabled; Rt && (at.wrapperEl.style.scrollSnapType = "none", at._immediateVirtual = !0), _t[bt ? "scrollLeft" : "scrollTop"] = Pt, Rt && requestAnimationFrame(() => { at.wrapperEl.style.scrollSnapType = "", at._swiperImmediateVirtual = !1 }) } else { if (!at.support.smoothScroll) return animateCSSModeScroll({ swiper: at, targetPosition: Pt, side: bt ? "left" : "top" }), !0; _t.scrollTo({ [bt ? "left" : "top"]: Pt, behavior: "smooth" }) } return !0 } return at.setTransition(s), at.setTranslate(xt), at.updateActiveIndex(lt), at.updateSlidesClasses(), at.emit("beforeTransitionStart", s, c), at.transitionStart(o, Ct), s === 0 ? at.transitionEnd(o, Ct) : at.animating || (at.animating = !0, at.onSlideToWrapperTransitionEnd || (at.onSlideToWrapperTransitionEnd = function (Pt) { !at || at.destroyed || Pt.target === this && (at.$wrapperEl[0].removeEventListener("transitionend", at.onSlideToWrapperTransitionEnd), at.$wrapperEl[0].removeEventListener("webkitTransitionEnd", at.onSlideToWrapperTransitionEnd), at.onSlideToWrapperTransitionEnd = null, delete at.onSlideToWrapperTransitionEnd, at.transitionEnd(o, Ct)) }), at.$wrapperEl[0].addEventListener("transitionend", at.onSlideToWrapperTransitionEnd), at.$wrapperEl[0].addEventListener("webkitTransitionEnd", at.onSlideToWrapperTransitionEnd)), !0 } function slideToLoop(e = 0, s = this.params.speed, o = !0, c) { if (typeof e == "string") { const lt = parseInt(e, 10); if (!isFinite(lt)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`); e = lt } const et = this; let at = e; return et.params.loop && (at += et.loopedSlides), et.slideTo(at, s, o, c) } function slideNext(e = this.params.speed, s = !0, o) { const c = this, { animating: et, enabled: at, params: lt } = c; if (!at) return c; let ft = lt.slidesPerGroup; lt.slidesPerView === "auto" && lt.slidesPerGroup === 1 && lt.slidesPerGroupAuto && (ft = Math.max(c.slidesPerViewDynamic("current", !0), 1)); const dt = c.activeIndex < lt.slidesPerGroupSkip ? 1 : ft; if (lt.loop) { if (et && lt.loopPreventsSlide) return !1; c.loopFix(), c._clientLeft = c.$wrapperEl[0].clientLeft } return lt.rewind && c.isEnd ? c.slideTo(0, e, s, o) : c.slideTo(c.activeIndex + dt, e, s, o) } function slidePrev(e = this.params.speed, s = !0, o) { const c = this, { params: et, animating: at, snapGrid: lt, slidesGrid: ft, rtlTranslate: dt, enabled: ht } = c; if (!ht) return c; if (et.loop) { if (at && et.loopPreventsSlide) return !1; c.loopFix(), c._clientLeft = c.$wrapperEl[0].clientLeft } const vt = dt ? c.translate : -c.translate; function wt(Dt) { return Dt < 0 ? -Math.floor(Math.abs(Dt)) : Math.floor(Dt) } const St = wt(vt), _t = lt.map(Dt => wt(Dt)); let Nt = lt[_t.indexOf(St) - 1]; if (typeof Nt > "u" && et.cssMode) { let Dt; lt.forEach((xt, Ct) => { St >= xt && (Dt = Ct) }), typeof Dt < "u" && (Nt = lt[Dt > 0 ? Dt - 1 : Dt]) } let kt = 0; if (typeof Nt < "u" && (kt = ft.indexOf(Nt), kt < 0 && (kt = c.activeIndex - 1), et.slidesPerView === "auto" && et.slidesPerGroup === 1 && et.slidesPerGroupAuto && (kt = kt - c.slidesPerViewDynamic("previous", !0) + 1, kt = Math.max(kt, 0))), et.rewind && c.isBeginning) { const Dt = c.params.virtual && c.params.virtual.enabled && c.virtual ? c.virtual.slides.length - 1 : c.slides.length - 1; return c.slideTo(Dt, e, s, o) } return c.slideTo(kt, e, s, o) } function slideReset(e = this.params.speed, s = !0, o) { const c = this; return c.slideTo(c.activeIndex, e, s, o) } function slideToClosest(e = this.params.speed, s = !0, o, c = .5) { const et = this; let at = et.activeIndex; const lt = Math.min(et.params.slidesPerGroupSkip, at), ft = lt + Math.floor((at - lt) / et.params.slidesPerGroup), dt = et.rtlTranslate ? et.translate : -et.translate; if (dt >= et.snapGrid[ft]) { const ht = et.snapGrid[ft], vt = et.snapGrid[ft + 1]; dt - ht > (vt - ht) * c && (at += et.params.slidesPerGroup) } else { const ht = et.snapGrid[ft - 1], vt = et.snapGrid[ft]; dt - ht <= (vt - ht) * c && (at -= et.params.slidesPerGroup) } return at = Math.max(at, 0), at = Math.min(at, et.slidesGrid.length - 1), et.slideTo(at, e, s, o) } function slideToClickedSlide() { const e = this, { params: s, $wrapperEl: o } = e, c = s.slidesPerView === "auto" ? e.slidesPerViewDynamic() : s.slidesPerView; let et = e.clickedIndex, at; if (s.loop) { if (e.animating) return; at = parseInt($$1(e.clickedSlide).attr("data-swiper-slide-index"), 10), s.centeredSlides ? et < e.loopedSlides - c / 2 || et > e.slides.length - e.loopedSlides + c / 2 ? (e.loopFix(), et = o.children(`.${s.slideClass}[data-swiper-slide-index="${at}"]:not(.${s.slideDuplicateClass})`).eq(0).index(), nextTick(() => { e.slideTo(et) })) : e.slideTo(et) : et > e.slides.length - c ? (e.loopFix(), et = o.children(`.${s.slideClass}[data-swiper-slide-index="${at}"]:not(.${s.slideDuplicateClass})`).eq(0).index(), nextTick(() => { e.slideTo(et) })) : e.slideTo(et) } else e.slideTo(et) } const slide = { slideTo, slideToLoop, slideNext, slidePrev, slideReset, slideToClosest, slideToClickedSlide }; function loopCreate() { const e = this, s = getDocument(), { params: o, $wrapperEl: c } = e, et = c.children().length > 0 ? $$1(c.children()[0].parentNode) : c; et.children(`.${o.slideClass}.${o.slideDuplicateClass}`).remove(); let at = et.children(`.${o.slideClass}`); if (o.loopFillGroupWithBlank) { const dt = o.slidesPerGroup - at.length % o.slidesPerGroup; if (dt !== o.slidesPerGroup) { for (let ht = 0; ht < dt; ht += 1) { const vt = $$1(s.createElement("div")).addClass(`${o.slideClass} ${o.slideBlankClass}`); et.append(vt) } at = et.children(`.${o.slideClass}`) } } o.slidesPerView === "auto" && !o.loopedSlides && (o.loopedSlides = at.length), e.loopedSlides = Math.ceil(parseFloat(o.loopedSlides || o.slidesPerView, 10)), e.loopedSlides += o.loopAdditionalSlides, e.loopedSlides > at.length && e.params.loopedSlidesLimit && (e.loopedSlides = at.length); const lt = [], ft = []; at.each((dt, ht) => { $$1(dt).attr("data-swiper-slide-index", ht) }); for (let dt = 0; dt < e.loopedSlides; dt += 1) { const ht = dt - Math.floor(dt / at.length) * at.length; ft.push(at.eq(ht)[0]), lt.unshift(at.eq(at.length - ht - 1)[0]) } for (let dt = 0; dt < ft.length; dt += 1)et.append($$1(ft[dt].cloneNode(!0)).addClass(o.slideDuplicateClass)); for (let dt = lt.length - 1; dt >= 0; dt -= 1)et.prepend($$1(lt[dt].cloneNode(!0)).addClass(o.slideDuplicateClass)) } function loopFix() { const e = this; e.emit("beforeLoopFix"); const { activeIndex: s, slides: o, loopedSlides: c, allowSlidePrev: et, allowSlideNext: at, snapGrid: lt, rtlTranslate: ft } = e; let dt; e.allowSlidePrev = !0, e.allowSlideNext = !0; const vt = -lt[s] - e.getTranslate(); s < c ? (dt = o.length - c * 3 + s, dt += c, e.slideTo(dt, 0, !1, !0) && vt !== 0 && e.setTranslate((ft ? -e.translate : e.translate) - vt)) : s >= o.length - c && (dt = -o.length + s + c, dt += c, e.slideTo(dt, 0, !1, !0) && vt !== 0 && e.setTranslate((ft ? -e.translate : e.translate) - vt)), e.allowSlidePrev = et, e.allowSlideNext = at, e.emit("loopFix") } function loopDestroy() { const e = this, { $wrapperEl: s, params: o, slides: c } = e; s.children(`.${o.slideClass}.${o.slideDuplicateClass},.${o.slideClass}.${o.slideBlankClass}`).remove(), c.removeAttr("data-swiper-slide-index") } const loop = { loopCreate, loopFix, loopDestroy }; function setGrabCursor(e) { const s = this; if (s.support.touch || !s.params.simulateTouch || s.params.watchOverflow && s.isLocked || s.params.cssMode) return; const o = s.params.touchEventsTarget === "container" ? s.el : s.wrapperEl; o.style.cursor = "move", o.style.cursor = e ? "grabbing" : "grab" } function unsetGrabCursor() { const e = this; e.support.touch || e.params.watchOverflow && e.isLocked || e.params.cssMode || (e[e.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "") } const grabCursor = { setGrabCursor, unsetGrabCursor }; function closestElement(e, s = this) { function o(c) { if (!c || c === getDocument() || c === getWindow()) return null; c.assignedSlot && (c = c.assignedSlot); const et = c.closest(e); return !et && !c.getRootNode ? null : et || o(c.getRootNode().host) } return o(s) } function onTouchStart(e) { const s = this, o = getDocument(), c = getWindow(), et = s.touchEventsData, { params: at, touches: lt, enabled: ft } = s; if (!ft || s.animating && at.preventInteractionOnTransition) return; !s.animating && at.cssMode && at.loop && s.loopFix(); let dt = e; dt.originalEvent && (dt = dt.originalEvent); let ht = $$1(dt.target); if (at.touchEventsTarget === "wrapper" && !ht.closest(s.wrapperEl).length || (et.isTouchEvent = dt.type === "touchstart", !et.isTouchEvent && "which" in dt && dt.which === 3) || !et.isTouchEvent && "button" in dt && dt.button > 0 || et.isTouched && et.isMoved) return; const vt = !!at.noSwipingClass && at.noSwipingClass !== "", wt = e.composedPath ? e.composedPath() : e.path; vt && dt.target && dt.target.shadowRoot && wt && (ht = $$1(wt[0])); const St = at.noSwipingSelector ? at.noSwipingSelector : `.${at.noSwipingClass}`, _t = !!(dt.target && dt.target.shadowRoot); if (at.noSwiping && (_t ? closestElement(St, ht[0]) : ht.closest(St)[0])) { s.allowClick = !0; return } if (at.swipeHandler && !ht.closest(at.swipeHandler)[0]) return; lt.currentX = dt.type === "touchstart" ? dt.targetTouches[0].pageX : dt.pageX, lt.currentY = dt.type === "touchstart" ? dt.targetTouches[0].pageY : dt.pageY; const Nt = lt.currentX, kt = lt.currentY, Dt = at.edgeSwipeDetection || at.iOSEdgeSwipeDetection, xt = at.edgeSwipeThreshold || at.iOSEdgeSwipeThreshold; if (Dt && (Nt <= xt || Nt >= c.innerWidth - xt)) if (Dt === "prevent") e.preventDefault(); else return; if (Object.assign(et, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), lt.startX = Nt, lt.startY = kt, et.touchStartTime = now(), s.allowClick = !0, s.updateSize(), s.swipeDirection = void 0, at.threshold > 0 && (et.allowThresholdMove = !1), dt.type !== "touchstart") { let Ct = !0; ht.is(et.focusableElements) && (Ct = !1, ht[0].nodeName === "SELECT" && (et.isTouched = !1)), o.activeElement && $$1(o.activeElement).is(et.focusableElements) && o.activeElement !== ht[0] && o.activeElement.blur(); const bt = Ct && s.allowTouchMove && at.touchStartPreventDefault; (at.touchStartForcePreventDefault || bt) && !ht[0].isContentEditable && dt.preventDefault() } s.params.freeMode && s.params.freeMode.enabled && s.freeMode && s.animating && !at.cssMode && s.freeMode.onTouchStart(), s.emit("touchStart", dt) } function onTouchMove(e) { const s = getDocument(), o = this, c = o.touchEventsData, { params: et, touches: at, rtlTranslate: lt, enabled: ft } = o; if (!ft) return; let dt = e; if (dt.originalEvent && (dt = dt.originalEvent), !c.isTouched) { c.startMoving && c.isScrolling && o.emit("touchMoveOpposite", dt); return } if (c.isTouchEvent && dt.type !== "touchmove") return; const ht = dt.type === "touchmove" && dt.targetTouches && (dt.targetTouches[0] || dt.changedTouches[0]), vt = dt.type === "touchmove" ? ht.pageX : dt.pageX, wt = dt.type === "touchmove" ? ht.pageY : dt.pageY; if (dt.preventedByNestedSwiper) { at.startX = vt, at.startY = wt; return } if (!o.allowTouchMove) { $$1(dt.target).is(c.focusableElements) || (o.allowClick = !1), c.isTouched && (Object.assign(at, { startX: vt, startY: wt, currentX: vt, currentY: wt }), c.touchStartTime = now()); return } if (c.isTouchEvent && et.touchReleaseOnEdges && !et.loop) { if (o.isVertical()) { if (wt < at.startY && o.translate <= o.maxTranslate() || wt > at.startY && o.translate >= o.minTranslate()) { c.isTouched = !1, c.isMoved = !1; return } } else if (vt < at.startX && o.translate <= o.maxTranslate() || vt > at.startX && o.translate >= o.minTranslate()) return } if (c.isTouchEvent && s.activeElement && dt.target === s.activeElement && $$1(dt.target).is(c.focusableElements)) { c.isMoved = !0, o.allowClick = !1; return } if (c.allowTouchCallbacks && o.emit("touchMove", dt), dt.targetTouches && dt.targetTouches.length > 1) return; at.currentX = vt, at.currentY = wt; const St = at.currentX - at.startX, _t = at.currentY - at.startY; if (o.params.threshold && Math.sqrt(St ** 2 + _t ** 2) < o.params.threshold) return; if (typeof c.isScrolling > "u") { let xt; o.isHorizontal() && at.currentY === at.startY || o.isVertical() && at.currentX === at.startX ? c.isScrolling = !1 : St * St + _t * _t >= 25 && (xt = Math.atan2(Math.abs(_t), Math.abs(St)) * 180 / Math.PI, c.isScrolling = o.isHorizontal() ? xt > et.touchAngle : 90 - xt > et.touchAngle) } if (c.isScrolling && o.emit("touchMoveOpposite", dt), typeof c.startMoving > "u" && (at.currentX !== at.startX || at.currentY !== at.startY) && (c.startMoving = !0), c.isScrolling) { c.isTouched = !1; return } if (!c.startMoving) return; o.allowClick = !1, !et.cssMode && dt.cancelable && dt.preventDefault(), et.touchMoveStopPropagation && !et.nested && dt.stopPropagation(), c.isMoved || (et.loop && !et.cssMode && o.loopFix(), c.startTranslate = o.getTranslate(), o.setTransition(0), o.animating && o.$wrapperEl.trigger("webkitTransitionEnd transitionend"), c.allowMomentumBounce = !1, et.grabCursor && (o.allowSlideNext === !0 || o.allowSlidePrev === !0) && o.setGrabCursor(!0), o.emit("sliderFirstMove", dt)), o.emit("sliderMove", dt), c.isMoved = !0; let Nt = o.isHorizontal() ? St : _t; at.diff = Nt, Nt *= et.touchRatio, lt && (Nt = -Nt), o.swipeDirection = Nt > 0 ? "prev" : "next", c.currentTranslate = Nt + c.startTranslate; let kt = !0, Dt = et.resistanceRatio; if (et.touchReleaseOnEdges && (Dt = 0), Nt > 0 && c.currentTranslate > o.minTranslate() ? (kt = !1, et.resistance && (c.currentTranslate = o.minTranslate() - 1 + (-o.minTranslate() + c.startTranslate + Nt) ** Dt)) : Nt < 0 && c.currentTranslate < o.maxTranslate() && (kt = !1, et.resistance && (c.currentTranslate = o.maxTranslate() + 1 - (o.maxTranslate() - c.startTranslate - Nt) ** Dt)), kt && (dt.preventedByNestedSwiper = !0), !o.allowSlideNext && o.swipeDirection === "next" && c.currentTranslate < c.startTranslate && (c.currentTranslate = c.startTranslate), !o.allowSlidePrev && o.swipeDirection === "prev" && c.currentTranslate > c.startTranslate && (c.currentTranslate = c.startTranslate), !o.allowSlidePrev && !o.allowSlideNext && (c.currentTranslate = c.startTranslate), et.threshold > 0) if (Math.abs(Nt) > et.threshold || c.allowThresholdMove) { if (!c.allowThresholdMove) { c.allowThresholdMove = !0, at.startX = at.currentX, at.startY = at.currentY, c.currentTranslate = c.startTranslate, at.diff = o.isHorizontal() ? at.currentX - at.startX : at.currentY - at.startY; return } } else { c.currentTranslate = c.startTranslate; return } !et.followFinger || et.cssMode || ((et.freeMode && et.freeMode.enabled && o.freeMode || et.watchSlidesProgress) && (o.updateActiveIndex(), o.updateSlidesClasses()), o.params.freeMode && et.freeMode.enabled && o.freeMode && o.freeMode.onTouchMove(), o.updateProgress(c.currentTranslate), o.setTranslate(c.currentTranslate)) } function onTouchEnd(e) { const s = this, o = s.touchEventsData, { params: c, touches: et, rtlTranslate: at, slidesGrid: lt, enabled: ft } = s; if (!ft) return; let dt = e; if (dt.originalEvent && (dt = dt.originalEvent), o.allowTouchCallbacks && s.emit("touchEnd", dt), o.allowTouchCallbacks = !1, !o.isTouched) { o.isMoved && c.grabCursor && s.setGrabCursor(!1), o.isMoved = !1, o.startMoving = !1; return } c.grabCursor && o.isMoved && o.isTouched && (s.allowSlideNext === !0 || s.allowSlidePrev === !0) && s.setGrabCursor(!1); const ht = now(), vt = ht - o.touchStartTime; if (s.allowClick) { const Ct = dt.path || dt.composedPath && dt.composedPath(); s.updateClickedSlide(Ct && Ct[0] || dt.target), s.emit("tap click", dt), vt < 300 && ht - o.lastClickTime < 300 && s.emit("doubleTap doubleClick", dt) } if (o.lastClickTime = now(), nextTick(() => { s.destroyed || (s.allowClick = !0) }), !o.isTouched || !o.isMoved || !s.swipeDirection || et.diff === 0 || o.currentTranslate === o.startTranslate) { o.isTouched = !1, o.isMoved = !1, o.startMoving = !1; return } o.isTouched = !1, o.isMoved = !1, o.startMoving = !1; let wt; if (c.followFinger ? wt = at ? s.translate : -s.translate : wt = -o.currentTranslate, c.cssMode) return; if (s.params.freeMode && c.freeMode.enabled) { s.freeMode.onTouchEnd({ currentPos: wt }); return } let St = 0, _t = s.slidesSizesGrid[0]; for (let Ct = 0; Ct < lt.length; Ct += Ct < c.slidesPerGroupSkip ? 1 : c.slidesPerGroup) { const bt = Ct < c.slidesPerGroupSkip - 1 ? 1 : c.slidesPerGroup; typeof lt[Ct + bt] < "u" ? wt >= lt[Ct] && wt < lt[Ct + bt] && (St = Ct, _t = lt[Ct + bt] - lt[Ct]) : wt >= lt[Ct] && (St = Ct, _t = lt[lt.length - 1] - lt[lt.length - 2]) } let Nt = null, kt = null; c.rewind && (s.isBeginning ? kt = s.params.virtual && s.params.virtual.enabled && s.virtual ? s.virtual.slides.length - 1 : s.slides.length - 1 : s.isEnd && (Nt = 0)); const Dt = (wt - lt[St]) / _t, xt = St < c.slidesPerGroupSkip - 1 ? 1 : c.slidesPerGroup; if (vt > c.longSwipesMs) { if (!c.longSwipes) { s.slideTo(s.activeIndex); return } s.swipeDirection === "next" && (Dt >= c.longSwipesRatio ? s.slideTo(c.rewind && s.isEnd ? Nt : St + xt) : s.slideTo(St)), s.swipeDirection === "prev" && (Dt > 1 - c.longSwipesRatio ? s.slideTo(St + xt) : kt !== null && Dt < 0 && Math.abs(Dt) > c.longSwipesRatio ? s.slideTo(kt) : s.slideTo(St)) } else { if (!c.shortSwipes) { s.slideTo(s.activeIndex); return } s.navigation && (dt.target === s.navigation.nextEl || dt.target === s.navigation.prevEl) ? dt.target === s.navigation.nextEl ? s.slideTo(St + xt) : s.slideTo(St) : (s.swipeDirection === "next" && s.slideTo(Nt !== null ? Nt : St + xt), s.swipeDirection === "prev" && s.slideTo(kt !== null ? kt : St)) } } function onResize() { const e = this, { params: s, el: o } = e; if (o && o.offsetWidth === 0) return; s.breakpoints && e.setBreakpoint(); const { allowSlideNext: c, allowSlidePrev: et, snapGrid: at } = e; e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(), (s.slidesPerView === "auto" || s.slidesPerView > 1) && e.isEnd && !e.isBeginning && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.run(), e.allowSlidePrev = et, e.allowSlideNext = c, e.params.watchOverflow && at !== e.snapGrid && e.checkOverflow() } function onClick(e) { const s = this; !s.enabled || s.allowClick || (s.params.preventClicks && e.preventDefault(), s.params.preventClicksPropagation && s.animating && (e.stopPropagation(), e.stopImmediatePropagation())) } function onScroll() { const e = this, { wrapperEl: s, rtlTranslate: o, enabled: c } = e; if (!c) return; e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -s.scrollLeft : e.translate = -s.scrollTop, e.translate === 0 && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses(); let et; const at = e.maxTranslate() - e.minTranslate(); at === 0 ? et = 0 : et = (e.translate - e.minTranslate()) / at, et !== e.progress && e.updateProgress(o ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1) } let dummyEventAttached = !1; function dummyEventListener() { } const events = (e, s) => { const o = getDocument(), { params: c, touchEvents: et, el: at, wrapperEl: lt, device: ft, support: dt } = e, ht = !!c.nested, vt = s === "on" ? "addEventListener" : "removeEventListener", wt = s; if (!dt.touch) at[vt](et.start, e.onTouchStart, !1), o[vt](et.move, e.onTouchMove, ht), o[vt](et.end, e.onTouchEnd, !1); else { const St = et.start === "touchstart" && dt.passiveListener && c.passiveListeners ? { passive: !0, capture: !1 } : !1; at[vt](et.start, e.onTouchStart, St), at[vt](et.move, e.onTouchMove, dt.passiveListener ? { passive: !1, capture: ht } : ht), at[vt](et.end, e.onTouchEnd, St), et.cancel && at[vt](et.cancel, e.onTouchEnd, St) } (c.preventClicks || c.preventClicksPropagation) && at[vt]("click", e.onClick, !0), c.cssMode && lt[vt]("scroll", e.onScroll), c.updateOnWindowResize ? e[wt](ft.ios || ft.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, !0) : e[wt]("observerUpdate", onResize, !0) }; function attachEvents() { const e = this, s = getDocument(), { params: o, support: c } = e; e.onTouchStart = onTouchStart.bind(e), e.onTouchMove = onTouchMove.bind(e), e.onTouchEnd = onTouchEnd.bind(e), o.cssMode && (e.onScroll = onScroll.bind(e)), e.onClick = onClick.bind(e), c.touch && !dummyEventAttached && (s.addEventListener("touchstart", dummyEventListener), dummyEventAttached = !0), events(e, "on") } function detachEvents() { events(this, "off") } const events$1 = { attachEvents, detachEvents }, isGridEnabled = (e, s) => e.grid && s.grid && s.grid.rows > 1; function setBreakpoint() { const e = this, { activeIndex: s, initialized: o, loopedSlides: c = 0, params: et, $el: at } = e, lt = et.breakpoints; if (!lt || lt && Object.keys(lt).length === 0) return; const ft = e.getBreakpoint(lt, e.params.breakpointsBase, e.el); if (!ft || e.currentBreakpoint === ft) return; const ht = (ft in lt ? lt[ft] : void 0) || e.originalParams, vt = isGridEnabled(e, et), wt = isGridEnabled(e, ht), St = et.enabled; vt && !wt ? (at.removeClass(`${et.containerModifierClass}grid ${et.containerModifierClass}grid-column`), e.emitContainerClasses()) : !vt && wt && (at.addClass(`${et.containerModifierClass}grid`), (ht.grid.fill && ht.grid.fill === "column" || !ht.grid.fill && et.grid.fill === "column") && at.addClass(`${et.containerModifierClass}grid-column`), e.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach(Dt => { const xt = et[Dt] && et[Dt].enabled, Ct = ht[Dt] && ht[Dt].enabled; xt && !Ct && e[Dt].disable(), !xt && Ct && e[Dt].enable() }); const _t = ht.direction && ht.direction !== et.direction, Nt = et.loop && (ht.slidesPerView !== et.slidesPerView || _t); _t && o && e.changeDirection(), extend$1(e.params, ht); const kt = e.params.enabled; Object.assign(e, { allowTouchMove: e.params.allowTouchMove, allowSlideNext: e.params.allowSlideNext, allowSlidePrev: e.params.allowSlidePrev }), St && !kt ? e.disable() : !St && kt && e.enable(), e.currentBreakpoint = ft, e.emit("_beforeBreakpoint", ht), Nt && o && (e.loopDestroy(), e.loopCreate(), e.updateSlides(), e.slideTo(s - c + e.loopedSlides, 0, !1)), e.emit("breakpoint", ht) } function getBreakpoint(e, s = "window", o) { if (!e || s === "container" && !o) return; let c = !1; const et = getWindow(), at = s === "window" ? et.innerHeight : o.clientHeight, lt = Object.keys(e).map(ft => { if (typeof ft == "string" && ft.indexOf("@") === 0) { const dt = parseFloat(ft.substr(1)); return { value: at * dt, point: ft } } return { value: ft, point: ft } }); lt.sort((ft, dt) => parseInt(ft.value, 10) - parseInt(dt.value, 10)); for (let ft = 0; ft < lt.length; ft += 1) { const { point: dt, value: ht } = lt[ft]; s === "window" ? et.matchMedia(`(min-width: ${ht}px)`).matches && (c = dt) : ht <= o.clientWidth && (c = dt) } return c || "max" } const breakpoints = { setBreakpoint, getBreakpoint }; function prepareClasses(e, s) { const o = []; return e.forEach(c => { typeof c == "object" ? Object.keys(c).forEach(et => { c[et] && o.push(s + et) }) : typeof c == "string" && o.push(s + c) }), o } function addClasses() { const e = this, { classNames: s, params: o, rtl: c, $el: et, device: at, support: lt } = e, ft = prepareClasses(["initialized", o.direction, { "pointer-events": !lt.touch }, { "free-mode": e.params.freeMode && o.freeMode.enabled }, { autoheight: o.autoHeight }, { rtl: c }, { grid: o.grid && o.grid.rows > 1 }, { "grid-column": o.grid && o.grid.rows > 1 && o.grid.fill === "column" }, { android: at.android }, { ios: at.ios }, { "css-mode": o.cssMode }, { centered: o.cssMode && o.centeredSlides }, { "watch-progress": o.watchSlidesProgress }], o.containerModifierClass); s.push(...ft), et.addClass([...s].join(" ")), e.emitContainerClasses() } function removeClasses() { const e = this, { $el: s, classNames: o } = e; s.removeClass(o.join(" ")), e.emitContainerClasses() } const classes = { addClasses, removeClasses }; function loadImage(e, s, o, c, et, at) { const lt = getWindow(); let ft; function dt() { at && at() } !$$1(e).parent("picture")[0] && (!e.complete || !et) && s ? (ft = new lt.Image, ft.onload = dt, ft.onerror = dt, c && (ft.sizes = c), o && (ft.srcset = o), s && (ft.src = s)) : dt() } function preloadImages() { const e = this; e.imagesToLoad = e.$el.find("img"); function s() { typeof e > "u" || e === null || !e || e.destroyed || (e.imagesLoaded !== void 0 && (e.imagesLoaded += 1), e.imagesLoaded === e.imagesToLoad.length && (e.params.updateOnImagesReady && e.update(), e.emit("imagesReady"))) } for (let o = 0; o < e.imagesToLoad.length; o += 1) { const c = e.imagesToLoad[o]; e.loadImage(c, c.currentSrc || c.getAttribute("src"), c.srcset || c.getAttribute("srcset"), c.sizes || c.getAttribute("sizes"), !0, s) } } const images = { loadImage, preloadImages }; function checkOverflow() { const e = this, { isLocked: s, params: o } = e, { slidesOffsetBefore: c } = o; if (c) { const et = e.slides.length - 1, at = e.slidesGrid[et] + e.slidesSizesGrid[et] + c * 2; e.isLocked = e.size > at } else e.isLocked = e.snapGrid.length === 1; o.allowSlideNext === !0 && (e.allowSlideNext = !e.isLocked), o.allowSlidePrev === !0 && (e.allowSlidePrev = !e.isLocked), s && s !== e.isLocked && (e.isEnd = !1), s !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock") } const checkOverflow$1 = { checkOverflow }, defaults = { init: !0, direction: "horizontal", touchEventsTarget: "wrapper", initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, resizeObserver: !0, nested: !1, createElements: !1, enabled: !0, focusableElements: "input, select, option, textarea, button, video, label", width: null, height: null, preventInteractionOnTransition: !1, userAgent: null, url: null, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: "slide", breakpoints: void 0, breakpointsBase: "window", spaceBetween: 0, slidesPerView: 1, slidesPerGroup: 1, slidesPerGroupSkip: 0, slidesPerGroupAuto: !1, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: .5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 0, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: .85, watchSlidesProgress: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, preloadImages: !0, updateOnImagesReady: !0, loop: !1, loopAdditionalSlides: 0, loopedSlides: null, loopedSlidesLimit: !0, loopFillGroupWithBlank: !1, loopPreventsSlide: !0, rewind: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: "swiper-no-swiping", noSwipingSelector: null, passiveListeners: !0, maxBackfaceHiddenSlides: 10, containerModifierClass: "swiper-", slideClass: "swiper-slide", slideBlankClass: "swiper-slide-invisible-blank", slideActiveClass: "swiper-slide-active", slideDuplicateActiveClass: "swiper-slide-duplicate-active", slideVisibleClass: "swiper-slide-visible", slideDuplicateClass: "swiper-slide-duplicate", slideNextClass: "swiper-slide-next", slideDuplicateNextClass: "swiper-slide-duplicate-next", slidePrevClass: "swiper-slide-prev", slideDuplicatePrevClass: "swiper-slide-duplicate-prev", wrapperClass: "swiper-wrapper", runCallbacksOnInit: !0, _emitClasses: !1 }; function moduleExtendParams(e, s) { return function (c = {}) { const et = Object.keys(c)[0], at = c[et]; if (typeof at != "object" || at === null) { extend$1(s, c); return } if (["navigation", "pagination", "scrollbar"].indexOf(et) >= 0 && e[et] === !0 && (e[et] = { auto: !0 }), !(et in e && "enabled" in at)) { extend$1(s, c); return } e[et] === !0 && (e[et] = { enabled: !0 }), typeof e[et] == "object" && !("enabled" in e[et]) && (e[et].enabled = !0), e[et] || (e[et] = { enabled: !1 }), extend$1(s, c) } } const prototypes = { eventsEmitter, update, translate, transition, slide, loop, grabCursor, events: events$1, breakpoints, checkOverflow: checkOverflow$1, classes, images }, extendedDefaults = {}; class Swiper$1 { constructor(...s) { let o, c; if (s.length === 1 && s[0].constructor && Object.prototype.toString.call(s[0]).slice(8, -1) === "Object" ? c = s[0] : [o, c] = s, c || (c = {}), c = extend$1({}, c), o && !c.el && (c.el = o), c.el && $$1(c.el).length > 1) { const ft = []; return $$1(c.el).each(dt => { const ht = extend$1({}, c, { el: dt }); ft.push(new Swiper$1(ht)) }), ft } const et = this; et.__swiper__ = !0, et.support = getSupport(), et.device = getDevice({ userAgent: c.userAgent }), et.browser = getBrowser(), et.eventsListeners = {}, et.eventsAnyListeners = [], et.modules = [...et.__modules__], c.modules && Array.isArray(c.modules) && et.modules.push(...c.modules); const at = {}; et.modules.forEach(ft => { ft({ swiper: et, extendParams: moduleExtendParams(c, at), on: et.on.bind(et), once: et.once.bind(et), off: et.off.bind(et), emit: et.emit.bind(et) }) }); const lt = extend$1({}, defaults, at); return et.params = extend$1({}, lt, extendedDefaults, c), et.originalParams = extend$1({}, et.params), et.passedParams = extend$1({}, c), et.params && et.params.on && Object.keys(et.params.on).forEach(ft => { et.on(ft, et.params.on[ft]) }), et.params && et.params.onAny && et.onAny(et.params.onAny), et.$ = $$1, Object.assign(et, { enabled: et.params.enabled, el: o, classNames: [], slides: $$1(), slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal() { return et.params.direction === "horizontal" }, isVertical() { return et.params.direction === "vertical" }, activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, allowSlideNext: et.params.allowSlideNext, allowSlidePrev: et.params.allowSlidePrev, touchEvents: function () { const dt = ["touchstart", "touchmove", "touchend", "touchcancel"], ht = ["pointerdown", "pointermove", "pointerup"]; return et.touchEventsTouch = { start: dt[0], move: dt[1], end: dt[2], cancel: dt[3] }, et.touchEventsDesktop = { start: ht[0], move: ht[1], end: ht[2] }, et.support.touch || !et.params.simulateTouch ? et.touchEventsTouch : et.touchEventsDesktop }(), touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, focusableElements: et.params.focusableElements, lastClickTime: now(), clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, isTouchEvent: void 0, startMoving: void 0 }, allowClick: !0, allowTouchMove: et.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), et.emit("_swiper"), et.params.init && et.init(), et } enable() { const s = this; s.enabled || (s.enabled = !0, s.params.grabCursor && s.setGrabCursor(), s.emit("enable")) } disable() { const s = this; !s.enabled || (s.enabled = !1, s.params.grabCursor && s.unsetGrabCursor(), s.emit("disable")) } setProgress(s, o) { const c = this; s = Math.min(Math.max(s, 0), 1); const et = c.minTranslate(), lt = (c.maxTranslate() - et) * s + et; c.translateTo(lt, typeof o > "u" ? 0 : o), c.updateActiveIndex(), c.updateSlidesClasses() } emitContainerClasses() { const s = this; if (!s.params._emitClasses || !s.el) return; const o = s.el.className.split(" ").filter(c => c.indexOf("swiper") === 0 || c.indexOf(s.params.containerModifierClass) === 0); s.emit("_containerClasses", o.join(" ")) } getSlideClasses(s) { const o = this; return o.destroyed ? "" : s.className.split(" ").filter(c => c.indexOf("swiper-slide") === 0 || c.indexOf(o.params.slideClass) === 0).join(" ") } emitSlidesClasses() { const s = this; if (!s.params._emitClasses || !s.el) return; const o = []; s.slides.each(c => { const et = s.getSlideClasses(c); o.push({ slideEl: c, classNames: et }), s.emit("_slideClass", c, et) }), s.emit("_slideClasses", o) } slidesPerViewDynamic(s = "current", o = !1) { const c = this, { params: et, slides: at, slidesGrid: lt, slidesSizesGrid: ft, size: dt, activeIndex: ht } = c; let vt = 1; if (et.centeredSlides) { let wt = at[ht].swiperSlideSize, St; for (let _t = ht + 1; _t < at.length; _t += 1)at[_t] && !St && (wt += at[_t].swiperSlideSize, vt += 1, wt > dt && (St = !0)); for (let _t = ht - 1; _t >= 0; _t -= 1)at[_t] && !St && (wt += at[_t].swiperSlideSize, vt += 1, wt > dt && (St = !0)) } else if (s === "current") for (let wt = ht + 1; wt < at.length; wt += 1)(o ? lt[wt] + ft[wt] - lt[ht] < dt : lt[wt] - lt[ht] < dt) && (vt += 1); else for (let wt = ht - 1; wt >= 0; wt -= 1)lt[ht] - lt[wt] < dt && (vt += 1); return vt } update() { const s = this; if (!s || s.destroyed) return; const { snapGrid: o, params: c } = s; c.breakpoints && s.setBreakpoint(), s.updateSize(), s.updateSlides(), s.updateProgress(), s.updateSlidesClasses(); function et() { const lt = s.rtlTranslate ? s.translate * -1 : s.translate, ft = Math.min(Math.max(lt, s.maxTranslate()), s.minTranslate()); s.setTranslate(ft), s.updateActiveIndex(), s.updateSlidesClasses() } let at; s.params.freeMode && s.params.freeMode.enabled ? (et(), s.params.autoHeight && s.updateAutoHeight()) : ((s.params.slidesPerView === "auto" || s.params.slidesPerView > 1) && s.isEnd && !s.params.centeredSlides ? at = s.slideTo(s.slides.length - 1, 0, !1, !0) : at = s.slideTo(s.activeIndex, 0, !1, !0), at || et()), c.watchOverflow && o !== s.snapGrid && s.checkOverflow(), s.emit("update") } changeDirection(s, o = !0) { const c = this, et = c.params.direction; return s || (s = et === "horizontal" ? "vertical" : "horizontal"), s === et || s !== "horizontal" && s !== "vertical" || (c.$el.removeClass(`${c.params.containerModifierClass}${et}`).addClass(`${c.params.containerModifierClass}${s}`), c.emitContainerClasses(), c.params.direction = s, c.slides.each(at => { s === "vertical" ? at.style.width = "" : at.style.height = "" }), c.emit("changeDirection"), o && c.update()), c } changeLanguageDirection(s) { const o = this; o.rtl && s === "rtl" || !o.rtl && s === "ltr" || (o.rtl = s === "rtl", o.rtlTranslate = o.params.direction === "horizontal" && o.rtl, o.rtl ? (o.$el.addClass(`${o.params.containerModifierClass}rtl`), o.el.dir = "rtl") : (o.$el.removeClass(`${o.params.containerModifierClass}rtl`), o.el.dir = "ltr"), o.update()) } mount(s) { const o = this; if (o.mounted) return !0; const c = $$1(s || o.params.el); if (s = c[0], !s) return !1; s.swiper = o; const et = () => `.${(o.params.wrapperClass || "").trim().split(" ").join(".")}`; let lt = (() => { if (s && s.shadowRoot && s.shadowRoot.querySelector) { const ft = $$1(s.shadowRoot.querySelector(et())); return ft.children = dt => c.children(dt), ft } return c.children ? c.children(et()) : $$1(c).children(et()) })(); if (lt.length === 0 && o.params.createElements) { const dt = getDocument().createElement("div"); lt = $$1(dt), dt.className = o.params.wrapperClass, c.append(dt), c.children(`.${o.params.slideClass}`).each(ht => { lt.append(ht) }) } return Object.assign(o, { $el: c, el: s, $wrapperEl: lt, wrapperEl: lt[0], mounted: !0, rtl: s.dir.toLowerCase() === "rtl" || c.css("direction") === "rtl", rtlTranslate: o.params.direction === "horizontal" && (s.dir.toLowerCase() === "rtl" || c.css("direction") === "rtl"), wrongRTL: lt.css("display") === "-webkit-box" }), !0 } init(s) { const o = this; return o.initialized || o.mount(s) === !1 || (o.emit("beforeInit"), o.params.breakpoints && o.setBreakpoint(), o.addClasses(), o.params.loop && o.loopCreate(), o.updateSize(), o.updateSlides(), o.params.watchOverflow && o.checkOverflow(), o.params.grabCursor && o.enabled && o.setGrabCursor(), o.params.preloadImages && o.preloadImages(), o.params.loop ? o.slideTo(o.params.initialSlide + o.loopedSlides, 0, o.params.runCallbacksOnInit, !1, !0) : o.slideTo(o.params.initialSlide, 0, o.params.runCallbacksOnInit, !1, !0), o.attachEvents(), o.initialized = !0, o.emit("init"), o.emit("afterInit")), o } destroy(s = !0, o = !0) { const c = this, { params: et, $el: at, $wrapperEl: lt, slides: ft } = c; return typeof c.params > "u" || c.destroyed || (c.emit("beforeDestroy"), c.initialized = !1, c.detachEvents(), et.loop && c.loopDestroy(), o && (c.removeClasses(), at.removeAttr("style"), lt.removeAttr("style"), ft && ft.length && ft.removeClass([et.slideVisibleClass, et.slideActiveClass, et.slideNextClass, et.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")), c.emit("destroy"), Object.keys(c.eventsListeners).forEach(dt => { c.off(dt) }), s !== !1 && (c.$el[0].swiper = null, deleteProps(c)), c.destroyed = !0), null } static extendDefaults(s) { extend$1(extendedDefaults, s) } static get extendedDefaults() { return extendedDefaults } static get defaults() { return defaults } static installModule(s) { Swiper$1.prototype.__modules__ || (Swiper$1.prototype.__modules__ = []); const o = Swiper$1.prototype.__modules__; typeof s == "function" && o.indexOf(s) < 0 && o.push(s) } static use(s) { return Array.isArray(s) ? (s.forEach(o => Swiper$1.installModule(o)), Swiper$1) : (Swiper$1.installModule(s), Swiper$1) } } Object.keys(prototypes).forEach(e => { Object.keys(prototypes[e]).forEach(s => { Swiper$1.prototype[s] = prototypes[e][s] }) }); Swiper$1.use([Resize, Observer]); function createElementIfNotDefined(e, s, o, c) { const et = getDocument(); return e.params.createElements && Object.keys(c).forEach(at => { if (!o[at] && o.auto === !0) { let lt = e.$el.children(`.${c[at]}`)[0]; lt || (lt = et.createElement("div"), lt.className = c[at], e.$el.append(lt)), o[at] = lt, s[at] = lt } }), o } function Navigation({ swiper: e, extendParams: s, on: o, emit: c }) { s({ navigation: { nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: "swiper-button-disabled", hiddenClass: "swiper-button-hidden", lockClass: "swiper-button-lock", navigationDisabledClass: "swiper-navigation-disabled" } }), e.navigation = { nextEl: null, $nextEl: null, prevEl: null, $prevEl: null }; function et(_t) { let Nt; return _t && (Nt = $$1(_t), e.params.uniqueNavElements && typeof _t == "string" && Nt.length > 1 && e.$el.find(_t).length === 1 && (Nt = e.$el.find(_t))), Nt } function at(_t, Nt) { const kt = e.params.navigation; _t && _t.length > 0 && (_t[Nt ? "addClass" : "removeClass"](kt.disabledClass), _t[0] && _t[0].tagName === "BUTTON" && (_t[0].disabled = Nt), e.params.watchOverflow && e.enabled && _t[e.isLocked ? "addClass" : "removeClass"](kt.lockClass)) } function lt() { if (e.params.loop) return; const { $nextEl: _t, $prevEl: Nt } = e.navigation; at(Nt, e.isBeginning && !e.params.rewind), at(_t, e.isEnd && !e.params.rewind) } function ft(_t) { _t.preventDefault(), !(e.isBeginning && !e.params.loop && !e.params.rewind) && (e.slidePrev(), c("navigationPrev")) } function dt(_t) { _t.preventDefault(), !(e.isEnd && !e.params.loop && !e.params.rewind) && (e.slideNext(), c("navigationNext")) } function ht() { const _t = e.params.navigation; if (e.params.navigation = createElementIfNotDefined(e, e.originalParams.navigation, e.params.navigation, { nextEl: "swiper-button-next", prevEl: "swiper-button-prev" }), !(_t.nextEl || _t.prevEl)) return; const Nt = et(_t.nextEl), kt = et(_t.prevEl); Nt && Nt.length > 0 && Nt.on("click", dt), kt && kt.length > 0 && kt.on("click", ft), Object.assign(e.navigation, { $nextEl: Nt, nextEl: Nt && Nt[0], $prevEl: kt, prevEl: kt && kt[0] }), e.enabled || (Nt && Nt.addClass(_t.lockClass), kt && kt.addClass(_t.lockClass)) } function vt() { const { $nextEl: _t, $prevEl: Nt } = e.navigation; _t && _t.length && (_t.off("click", dt), _t.removeClass(e.params.navigation.disabledClass)), Nt && Nt.length && (Nt.off("click", ft), Nt.removeClass(e.params.navigation.disabledClass)) } o("init", () => { e.params.navigation.enabled === !1 ? St() : (ht(), lt()) }), o("toEdge fromEdge lock unlock", () => { lt() }), o("destroy", () => { vt() }), o("enable disable", () => { const { $nextEl: _t, $prevEl: Nt } = e.navigation; _t && _t[e.enabled ? "removeClass" : "addClass"](e.params.navigation.lockClass), Nt && Nt[e.enabled ? "removeClass" : "addClass"](e.params.navigation.lockClass) }), o("click", (_t, Nt) => { const { $nextEl: kt, $prevEl: Dt } = e.navigation, xt = Nt.target; if (e.params.navigation.hideOnClick && !$$1(xt).is(Dt) && !$$1(xt).is(kt)) { if (e.pagination && e.params.pagination && e.params.pagination.clickable && (e.pagination.el === xt || e.pagination.el.contains(xt))) return; let Ct; kt ? Ct = kt.hasClass(e.params.navigation.hiddenClass) : Dt && (Ct = Dt.hasClass(e.params.navigation.hiddenClass)), c(Ct === !0 ? "navigationShow" : "navigationHide"), kt && kt.toggleClass(e.params.navigation.hiddenClass), Dt && Dt.toggleClass(e.params.navigation.hiddenClass) } }); const wt = () => { e.$el.removeClass(e.params.navigation.navigationDisabledClass), ht(), lt() }, St = () => { e.$el.addClass(e.params.navigation.navigationDisabledClass), vt() }; Object.assign(e.navigation, { enable: wt, disable: St, update: lt, init: ht, destroy: vt }) } function classesToSelector(e = "") { return `.${e.trim().replace(/([\.:!\/])/g, "\\$1").replace(/ /g, ".")}` } function Pagination({ swiper: e, extendParams: s, on: o, emit: c }) { const et = "swiper-pagination"; s({ pagination: { el: null, bulletElement: "span", clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: "bullets", dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent: kt => kt, formatFractionTotal: kt => kt, bulletClass: `${et}-bullet`, bulletActiveClass: `${et}-bullet-active`, modifierClass: `${et}-`, currentClass: `${et}-current`, totalClass: `${et}-total`, hiddenClass: `${et}-hidden`, progressbarFillClass: `${et}-progressbar-fill`, progressbarOppositeClass: `${et}-progressbar-opposite`, clickableClass: `${et}-clickable`, lockClass: `${et}-lock`, horizontalClass: `${et}-horizontal`, verticalClass: `${et}-vertical`, paginationDisabledClass: `${et}-disabled` } }), e.pagination = { el: null, $el: null, bullets: [] }; let at, lt = 0; function ft() { return !e.params.pagination.el || !e.pagination.el || !e.pagination.$el || e.pagination.$el.length === 0 } function dt(kt, Dt) { const { bulletActiveClass: xt } = e.params.pagination; kt[Dt]().addClass(`${xt}-${Dt}`)[Dt]().addClass(`${xt}-${Dt}-${Dt}`) } function ht() { const kt = e.rtl, Dt = e.params.pagination; if (ft()) return; const xt = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length, Ct = e.pagination.$el; let bt; const Pt = e.params.loop ? Math.ceil((xt - e.loopedSlides * 2) / e.params.slidesPerGroup) : e.snapGrid.length; if (e.params.loop ? (bt = Math.ceil((e.activeIndex - e.loopedSlides) / e.params.slidesPerGroup), bt > xt - 1 - e.loopedSlides * 2 && (bt -= xt - e.loopedSlides * 2), bt > Pt - 1 && (bt -= Pt), bt < 0 && e.params.paginationType !== "bullets" && (bt = Pt + bt)) : typeof e.snapIndex < "u" ? bt = e.snapIndex : bt = e.activeIndex || 0, Dt.type === "bullets" && e.pagination.bullets && e.pagination.bullets.length > 0) { const Rt = e.pagination.bullets; let Jn, er, Zt; if (Dt.dynamicBullets && (at = Rt.eq(0)[e.isHorizontal() ? "outerWidth" : "outerHeight"](!0), Ct.css(e.isHorizontal() ? "width" : "height", `${at * (Dt.dynamicMainBullets + 4)}px`), Dt.dynamicMainBullets > 1 && e.previousIndex !== void 0 && (lt += bt - (e.previousIndex - e.loopedSlides || 0), lt > Dt.dynamicMainBullets - 1 ? lt = Dt.dynamicMainBullets - 1 : lt < 0 && (lt = 0)), Jn = Math.max(bt - lt, 0), er = Jn + (Math.min(Rt.length, Dt.dynamicMainBullets) - 1), Zt = (er + Jn) / 2), Rt.removeClass(["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map(lr => `${Dt.bulletActiveClass}${lr}`).join(" ")), Ct.length > 1) Rt.each(lr => { const tr = $$1(lr), xn = tr.index(); xn === bt && tr.addClass(Dt.bulletActiveClass), Dt.dynamicBullets && (xn >= Jn && xn <= er && tr.addClass(`${Dt.bulletActiveClass}-main`), xn === Jn && dt(tr, "prev"), xn === er && dt(tr, "next")) }); else { const lr = Rt.eq(bt), tr = lr.index(); if (lr.addClass(Dt.bulletActiveClass), Dt.dynamicBullets) { const xn = Rt.eq(Jn), jt = Rt.eq(er); for (let Gt = Jn; Gt <= er; Gt += 1)Rt.eq(Gt).addClass(`${Dt.bulletActiveClass}-main`); if (e.params.loop) if (tr >= Rt.length) { for (let Gt = Dt.dynamicMainBullets; Gt >= 0; Gt -= 1)Rt.eq(Rt.length - Gt).addClass(`${Dt.bulletActiveClass}-main`); Rt.eq(Rt.length - Dt.dynamicMainBullets - 1).addClass(`${Dt.bulletActiveClass}-prev`) } else dt(xn, "prev"), dt(jt, "next"); else dt(xn, "prev"), dt(jt, "next") } } if (Dt.dynamicBullets) { const lr = Math.min(Rt.length, Dt.dynamicMainBullets + 4), tr = (at * lr - at) / 2 - Zt * at, xn = kt ? "right" : "left"; Rt.css(e.isHorizontal() ? xn : "top", `${tr}px`) } } if (Dt.type === "fraction" && (Ct.find(classesToSelector(Dt.currentClass)).text(Dt.formatFractionCurrent(bt + 1)), Ct.find(classesToSelector(Dt.totalClass)).text(Dt.formatFractionTotal(Pt))), Dt.type === "progressbar") { let Rt; Dt.progressbarOpposite ? Rt = e.isHorizontal() ? "vertical" : "horizontal" : Rt = e.isHorizontal() ? "horizontal" : "vertical"; const Jn = (bt + 1) / Pt; let er = 1, Zt = 1; Rt === "horizontal" ? er = Jn : Zt = Jn, Ct.find(classesToSelector(Dt.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${er}) scaleY(${Zt})`).transition(e.params.speed) } Dt.type === "custom" && Dt.renderCustom ? (Ct.html(Dt.renderCustom(e, bt + 1, Pt)), c("paginationRender", Ct[0])) : c("paginationUpdate", Ct[0]), e.params.watchOverflow && e.enabled && Ct[e.isLocked ? "addClass" : "removeClass"](Dt.lockClass) } function vt() { const kt = e.params.pagination; if (ft()) return; const Dt = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length, xt = e.pagination.$el; let Ct = ""; if (kt.type === "bullets") { let bt = e.params.loop ? Math.ceil((Dt - e.loopedSlides * 2) / e.params.slidesPerGroup) : e.snapGrid.length; e.params.freeMode && e.params.freeMode.enabled && !e.params.loop && bt > Dt && (bt = Dt); for (let Pt = 0; Pt < bt; Pt += 1)kt.renderBullet ? Ct += kt.renderBullet.call(e, Pt, kt.bulletClass) : Ct += `<${kt.bulletElement} class="${kt.bulletClass}"></${kt.bulletElement}>`; xt.html(Ct), e.pagination.bullets = xt.find(classesToSelector(kt.bulletClass)) } kt.type === "fraction" && (kt.renderFraction ? Ct = kt.renderFraction.call(e, kt.currentClass, kt.totalClass) : Ct = `<span class="${kt.currentClass}"></span> / <span class="${kt.totalClass}"></span>`, xt.html(Ct)), kt.type === "progressbar" && (kt.renderProgressbar ? Ct = kt.renderProgressbar.call(e, kt.progressbarFillClass) : Ct = `<span class="${kt.progressbarFillClass}"></span>`, xt.html(Ct)), kt.type !== "custom" && c("paginationRender", e.pagination.$el[0]) } function wt() { e.params.pagination = createElementIfNotDefined(e, e.originalParams.pagination, e.params.pagination, { el: "swiper-pagination" }); const kt = e.params.pagination; if (!kt.el) return; let Dt = $$1(kt.el); Dt.length !== 0 && (e.params.uniqueNavElements && typeof kt.el == "string" && Dt.length > 1 && (Dt = e.$el.find(kt.el), Dt.length > 1 && (Dt = Dt.filter(xt => $$1(xt).parents(".swiper")[0] === e.el))), kt.type === "bullets" && kt.clickable && Dt.addClass(kt.clickableClass), Dt.addClass(kt.modifierClass + kt.type), Dt.addClass(e.isHorizontal() ? kt.horizontalClass : kt.verticalClass), kt.type === "bullets" && kt.dynamicBullets && (Dt.addClass(`${kt.modifierClass}${kt.type}-dynamic`), lt = 0, kt.dynamicMainBullets < 1 && (kt.dynamicMainBullets = 1)), kt.type === "progressbar" && kt.progressbarOpposite && Dt.addClass(kt.progressbarOppositeClass), kt.clickable && Dt.on("click", classesToSelector(kt.bulletClass), function (Ct) { Ct.preventDefault(); let bt = $$1(this).index() * e.params.slidesPerGroup; e.params.loop && (bt += e.loopedSlides), e.slideTo(bt) }), Object.assign(e.pagination, { $el: Dt, el: Dt[0] }), e.enabled || Dt.addClass(kt.lockClass)) } function St() { const kt = e.params.pagination; if (ft()) return; const Dt = e.pagination.$el; Dt.removeClass(kt.hiddenClass), Dt.removeClass(kt.modifierClass + kt.type), Dt.removeClass(e.isHorizontal() ? kt.horizontalClass : kt.verticalClass), e.pagination.bullets && e.pagination.bullets.removeClass && e.pagination.bullets.removeClass(kt.bulletActiveClass), kt.clickable && Dt.off("click", classesToSelector(kt.bulletClass)) } o("init", () => { e.params.pagination.enabled === !1 ? Nt() : (wt(), vt(), ht()) }), o("activeIndexChange", () => { (e.params.loop || typeof e.snapIndex > "u") && ht() }), o("snapIndexChange", () => { e.params.loop || ht() }), o("slidesLengthChange", () => { e.params.loop && (vt(), ht()) }), o("snapGridLengthChange", () => { e.params.loop || (vt(), ht()) }), o("destroy", () => { St() }), o("enable disable", () => { const { $el: kt } = e.pagination; kt && kt[e.enabled ? "removeClass" : "addClass"](e.params.pagination.lockClass) }), o("lock unlock", () => { ht() }), o("click", (kt, Dt) => { const xt = Dt.target, { $el: Ct } = e.pagination; if (e.params.pagination.el && e.params.pagination.hideOnClick && Ct && Ct.length > 0 && !$$1(xt).hasClass(e.params.pagination.bulletClass)) { if (e.navigation && (e.navigation.nextEl && xt === e.navigation.nextEl || e.navigation.prevEl && xt === e.navigation.prevEl)) return; const bt = Ct.hasClass(e.params.pagination.hiddenClass); c(bt === !0 ? "paginationShow" : "paginationHide"), Ct.toggleClass(e.params.pagination.hiddenClass) } }); const _t = () => { e.$el.removeClass(e.params.pagination.paginationDisabledClass), e.pagination.$el && e.pagination.$el.removeClass(e.params.pagination.paginationDisabledClass), wt(), vt(), ht() }, Nt = () => { e.$el.addClass(e.params.pagination.paginationDisabledClass), e.pagination.$el && e.pagination.$el.addClass(e.params.pagination.paginationDisabledClass), St() }; Object.assign(e.pagination, { enable: _t, disable: Nt, render: vt, update: ht, init: wt, destroy: St }) } function Scrollbar({ swiper: e, extendParams: s, on: o, emit: c }) { const et = getDocument(); let at = !1, lt = null, ft = null, dt, ht, vt, wt; s({ scrollbar: { el: null, dragSize: "auto", hide: !1, draggable: !1, snapOnRelease: !0, lockClass: "swiper-scrollbar-lock", dragClass: "swiper-scrollbar-drag", scrollbarDisabledClass: "swiper-scrollbar-disabled", horizontalClass: "swiper-scrollbar-horizontal", verticalClass: "swiper-scrollbar-vertical" } }), e.scrollbar = { el: null, dragEl: null, $el: null, $dragEl: null }; function St() { if (!e.params.scrollbar.el || !e.scrollbar.el) return; const { scrollbar: xn, rtlTranslate: jt, progress: Gt } = e, { $dragEl: nr, $el: sr } = xn, rr = e.params.scrollbar; let ar = ht, _n = (vt - ht) * Gt; jt ? (_n = -_n, _n > 0 ? (ar = ht - _n, _n = 0) : -_n + ht > vt && (ar = vt + _n)) : _n < 0 ? (ar = ht + _n, _n = 0) : _n + ht > vt && (ar = vt - _n), e.isHorizontal() ? (nr.transform(`translate3d(${_n}px, 0, 0)`), nr[0].style.width = `${ar}px`) : (nr.transform(`translate3d(0px, ${_n}px, 0)`), nr[0].style.height = `${ar}px`), rr.hide && (clearTimeout(lt), sr[0].style.opacity = 1, lt = setTimeout(() => { sr[0].style.opacity = 0, sr.transition(400) }, 1e3)) } function _t(xn) { !e.params.scrollbar.el || !e.scrollbar.el || e.scrollbar.$dragEl.transition(xn) } function Nt() { if (!e.params.scrollbar.el || !e.scrollbar.el) return; const { scrollbar: xn } = e, { $dragEl: jt, $el: Gt } = xn; jt[0].style.width = "", jt[0].style.height = "", vt = e.isHorizontal() ? Gt[0].offsetWidth : Gt[0].offsetHeight, wt = e.size / (e.virtualSize + e.params.slidesOffsetBefore - (e.params.centeredSlides ? e.snapGrid[0] : 0)), e.params.scrollbar.dragSize === "auto" ? ht = vt * wt : ht = parseInt(e.params.scrollbar.dragSize, 10), e.isHorizontal() ? jt[0].style.width = `${ht}px` : jt[0].style.height = `${ht}px`, wt >= 1 ? Gt[0].style.display = "none" : Gt[0].style.display = "", e.params.scrollbar.hide && (Gt[0].style.opacity = 0), e.params.watchOverflow && e.enabled && xn.$el[e.isLocked ? "addClass" : "removeClass"](e.params.scrollbar.lockClass) } function kt(xn) { return e.isHorizontal() ? xn.type === "touchstart" || xn.type === "touchmove" ? xn.targetTouches[0].clientX : xn.clientX : xn.type === "touchstart" || xn.type === "touchmove" ? xn.targetTouches[0].clientY : xn.clientY } function Dt(xn) { const { scrollbar: jt, rtlTranslate: Gt } = e, { $el: nr } = jt; let sr; sr = (kt(xn) - nr.offset()[e.isHorizontal() ? "left" : "top"] - (dt !== null ? dt : ht / 2)) / (vt - ht), sr = Math.max(Math.min(sr, 1), 0), Gt && (sr = 1 - sr); const rr = e.minTranslate() + (e.maxTranslate() - e.minTranslate()) * sr; e.updateProgress(rr), e.setTranslate(rr), e.updateActiveIndex(), e.updateSlidesClasses() } function xt(xn) { const jt = e.params.scrollbar, { scrollbar: Gt, $wrapperEl: nr } = e, { $el: sr, $dragEl: rr } = Gt; at = !0, dt = xn.target === rr[0] || xn.target === rr ? kt(xn) - xn.target.getBoundingClientRect()[e.isHorizontal() ? "left" : "top"] : null, xn.preventDefault(), xn.stopPropagation(), nr.transition(100), rr.transition(100), Dt(xn), clearTimeout(ft), sr.transition(0), jt.hide && sr.css("opacity", 1), e.params.cssMode && e.$wrapperEl.css("scroll-snap-type", "none"), c("scrollbarDragStart", xn) } function Ct(xn) { const { scrollbar: jt, $wrapperEl: Gt } = e, { $el: nr, $dragEl: sr } = jt; !at || (xn.preventDefault ? xn.preventDefault() : xn.returnValue = !1, Dt(xn), Gt.transition(0), nr.transition(0), sr.transition(0), c("scrollbarDragMove", xn)) } function bt(xn) { const jt = e.params.scrollbar, { scrollbar: Gt, $wrapperEl: nr } = e, { $el: sr } = Gt; !at || (at = !1, e.params.cssMode && (e.$wrapperEl.css("scroll-snap-type", ""), nr.transition("")), jt.hide && (clearTimeout(ft), ft = nextTick(() => { sr.css("opacity", 0), sr.transition(400) }, 1e3)), c("scrollbarDragEnd", xn), jt.snapOnRelease && e.slideToClosest()) } function Pt(xn) { const { scrollbar: jt, touchEventsTouch: Gt, touchEventsDesktop: nr, params: sr, support: rr } = e, ar = jt.$el; if (!ar) return; const _n = ar[0], ir = rr.passiveListener && sr.passiveListeners ? { passive: !1, capture: !1 } : !1, or = rr.passiveListener && sr.passiveListeners ? { passive: !0, capture: !1 } : !1; if (!_n) return; const ur = xn === "on" ? "addEventListener" : "removeEventListener"; rr.touch ? (_n[ur](Gt.start, xt, ir), _n[ur](Gt.move, Ct, ir), _n[ur](Gt.end, bt, or)) : (_n[ur](nr.start, xt, ir), et[ur](nr.move, Ct, ir), et[ur](nr.end, bt, or)) } function Rt() { !e.params.scrollbar.el || !e.scrollbar.el || Pt("on") } function Jn() { !e.params.scrollbar.el || !e.scrollbar.el || Pt("off") } function er() { const { scrollbar: xn, $el: jt } = e; e.params.scrollbar = createElementIfNotDefined(e, e.originalParams.scrollbar, e.params.scrollbar, { el: "swiper-scrollbar" }); const Gt = e.params.scrollbar; if (!Gt.el) return; let nr = $$1(Gt.el); e.params.uniqueNavElements && typeof Gt.el == "string" && nr.length > 1 && jt.find(Gt.el).length === 1 && (nr = jt.find(Gt.el)), nr.addClass(e.isHorizontal() ? Gt.horizontalClass : Gt.verticalClass); let sr = nr.find(`.${e.params.scrollbar.dragClass}`); sr.length === 0 && (sr = $$1(`<div class="${e.params.scrollbar.dragClass}"></div>`), nr.append(sr)), Object.assign(xn, { $el: nr, el: nr[0], $dragEl: sr, dragEl: sr[0] }), Gt.draggable && Rt(), nr && nr[e.enabled ? "removeClass" : "addClass"](e.params.scrollbar.lockClass) } function Zt() { const xn = e.params.scrollbar, jt = e.scrollbar.$el; jt && jt.removeClass(e.isHorizontal() ? xn.horizontalClass : xn.verticalClass), Jn() } o("init", () => { e.params.scrollbar.enabled === !1 ? tr() : (er(), Nt(), St()) }), o("update resize observerUpdate lock unlock", () => { Nt() }), o("setTranslate", () => { St() }), o("setTransition", (xn, jt) => { _t(jt) }), o("enable disable", () => { const { $el: xn } = e.scrollbar; xn && xn[e.enabled ? "removeClass" : "addClass"](e.params.scrollbar.lockClass) }), o("destroy", () => { Zt() }); const lr = () => { e.$el.removeClass(e.params.scrollbar.scrollbarDisabledClass), e.scrollbar.$el && e.scrollbar.$el.removeClass(e.params.scrollbar.scrollbarDisabledClass), er(), Nt(), St() }, tr = () => { e.$el.addClass(e.params.scrollbar.scrollbarDisabledClass), e.scrollbar.$el && e.scrollbar.$el.addClass(e.params.scrollbar.scrollbarDisabledClass), Zt() }; Object.assign(e.scrollbar, { enable: lr, disable: tr, updateSize: Nt, setTranslate: St, init: er, destroy: Zt }) } function A11y({ swiper: e, extendParams: s, on: o }) { s({ a11y: { enabled: !0, notificationClass: "swiper-notification", prevSlideMessage: "Previous slide", nextSlideMessage: "Next slide", firstSlideMessage: "This is the first slide", lastSlideMessage: "This is the last slide", paginationBulletMessage: "Go to slide {{index}}", slideLabelMessage: "{{index}} / {{slidesLength}}", containerMessage: null, containerRoleDescriptionMessage: null, itemRoleDescriptionMessage: null, slideRole: "group", id: null } }), e.a11y = { clicked: !1 }; let c = null; function et(jt) { const Gt = c; Gt.length !== 0 && (Gt.html(""), Gt.html(jt)) } function at(jt = 16) { const Gt = () => Math.round(16 * Math.random()).toString(16); return "x".repeat(jt).replace(/x/g, Gt) } function lt(jt) { jt.attr("tabIndex", "0") } function ft(jt) { jt.attr("tabIndex", "-1") } function dt(jt, Gt) { jt.attr("role", Gt) } function ht(jt, Gt) { jt.attr("aria-roledescription", Gt) } function vt(jt, Gt) { jt.attr("aria-controls", Gt) } function wt(jt, Gt) { jt.attr("aria-label", Gt) } function St(jt, Gt) { jt.attr("id", Gt) } function _t(jt, Gt) { jt.attr("aria-live", Gt) } function Nt(jt) { jt.attr("aria-disabled", !0) } function kt(jt) { jt.attr("aria-disabled", !1) } function Dt(jt) { if (jt.keyCode !== 13 && jt.keyCode !== 32) return; const Gt = e.params.a11y, nr = $$1(jt.target); e.navigation && e.navigation.$nextEl && nr.is(e.navigation.$nextEl) && (e.isEnd && !e.params.loop || e.slideNext(), e.isEnd ? et(Gt.lastSlideMessage) : et(Gt.nextSlideMessage)), e.navigation && e.navigation.$prevEl && nr.is(e.navigation.$prevEl) && (e.isBeginning && !e.params.loop || e.slidePrev(), e.isBeginning ? et(Gt.firstSlideMessage) : et(Gt.prevSlideMessage)), e.pagination && nr.is(classesToSelector(e.params.pagination.bulletClass)) && nr[0].click() } function xt() { if (e.params.loop || e.params.rewind || !e.navigation) return; const { $nextEl: jt, $prevEl: Gt } = e.navigation; Gt && Gt.length > 0 && (e.isBeginning ? (Nt(Gt), ft(Gt)) : (kt(Gt), lt(Gt))), jt && jt.length > 0 && (e.isEnd ? (Nt(jt), ft(jt)) : (kt(jt), lt(jt))) } function Ct() { return e.pagination && e.pagination.bullets && e.pagination.bullets.length } function bt() { return Ct() && e.params.pagination.clickable } function Pt() { const jt = e.params.a11y; !Ct() || e.pagination.bullets.each(Gt => { const nr = $$1(Gt); e.params.pagination.clickable && (lt(nr), e.params.pagination.renderBullet || (dt(nr, "button"), wt(nr, jt.paginationBulletMessage.replace(/\{\{index\}\}/, nr.index() + 1)))), nr.is(`.${e.params.pagination.bulletActiveClass}`) ? nr.attr("aria-current", "true") : nr.removeAttr("aria-current") }) } const Rt = (jt, Gt, nr) => { lt(jt), jt[0].tagName !== "BUTTON" && (dt(jt, "button"), jt.on("keydown", Dt)), wt(jt, nr), vt(jt, Gt) }, Jn = () => { e.a11y.clicked = !0 }, er = () => { requestAnimationFrame(() => { requestAnimationFrame(() => { e.a11y.clicked = !1 }) }) }, Zt = jt => { if (e.a11y.clicked) return; const Gt = jt.target.closest(`.${e.params.slideClass}`); if (!Gt || !e.slides.includes(Gt)) return; const nr = e.slides.indexOf(Gt) === e.activeIndex, sr = e.params.watchSlidesProgress && e.visibleSlides && e.visibleSlides.includes(Gt); nr || sr || (e.isHorizontal() ? e.el.scrollLeft = 0 : e.el.scrollTop = 0, e.slideTo(e.slides.indexOf(Gt), 0)) }, lr = () => { const jt = e.params.a11y; jt.itemRoleDescriptionMessage && ht($$1(e.slides), jt.itemRoleDescriptionMessage), jt.slideRole && dt($$1(e.slides), jt.slideRole); const Gt = e.params.loop ? e.slides.filter(nr => !nr.classList.contains(e.params.slideDuplicateClass)).length : e.slides.length; jt.slideLabelMessage && e.slides.each((nr, sr) => { const rr = $$1(nr), ar = e.params.loop ? parseInt(rr.attr("data-swiper-slide-index"), 10) : sr, _n = jt.slideLabelMessage.replace(/\{\{index\}\}/, ar + 1).replace(/\{\{slidesLength\}\}/, Gt); wt(rr, _n) }) }, tr = () => { const jt = e.params.a11y; e.$el.append(c); const Gt = e.$el; jt.containerRoleDescriptionMessage && ht(Gt, jt.containerRoleDescriptionMessage), jt.containerMessage && wt(Gt, jt.containerMessage); const nr = e.$wrapperEl, sr = jt.id || nr.attr("id") || `swiper-wrapper-${at(16)}`, rr = e.params.autoplay && e.params.autoplay.enabled ? "off" : "polite"; St(nr, sr), _t(nr, rr), lr(); let ar, _n; e.navigation && e.navigation.$nextEl && (ar = e.navigation.$nextEl), e.navigation && e.navigation.$prevEl && (_n = e.navigation.$prevEl), ar && ar.length && Rt(ar, sr, jt.nextSlideMessage), _n && _n.length && Rt(_n, sr, jt.prevSlideMessage), bt() && e.pagination.$el.on("keydown", classesToSelector(e.params.pagination.bulletClass), Dt), e.$el.on("focus", Zt, !0), e.$el.on("pointerdown", Jn, !0), e.$el.on("pointerup", er, !0) }; function xn() { c && c.length > 0 && c.remove(); let jt, Gt; e.navigation && e.navigation.$nextEl && (jt = e.navigation.$nextEl), e.navigation && e.navigation.$prevEl && (Gt = e.navigation.$prevEl), jt && jt.off("keydown", Dt), Gt && Gt.off("keydown", Dt), bt() && e.pagination.$el.off("keydown", classesToSelector(e.params.pagination.bulletClass), Dt), e.$el.off("focus", Zt, !0), e.$el.off("pointerdown", Jn, !0), e.$el.off("pointerup", er, !0) } o("beforeInit", () => { c = $$1(`<span class="${e.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`) }), o("afterInit", () => { !e.params.a11y.enabled || tr() }), o("slidesLengthChange snapGridLengthChange slidesGridLengthChange", () => { !e.params.a11y.enabled || lr() }), o("fromEdge toEdge afterInit lock unlock", () => { !e.params.a11y.enabled || xt() }), o("paginationUpdate", () => { !e.params.a11y.enabled || Pt() }), o("destroy", () => { !e.params.a11y.enabled || xn() }) } function Autoplay({ swiper: e, extendParams: s, on: o, emit: c }) { let et; e.autoplay = { running: !1, paused: !1 }, s({ autoplay: { enabled: !1, delay: 3e3, waitForTransition: !0, disableOnInteraction: !0, stopOnLastSlide: !1, reverseDirection: !1, pauseOnMouseEnter: !1 } }); function at() { if (!e.size) { e.autoplay.running = !1, e.autoplay.paused = !1; return } const kt = e.slides.eq(e.activeIndex); let Dt = e.params.autoplay.delay; kt.attr("data-swiper-autoplay") && (Dt = kt.attr("data-swiper-autoplay") || e.params.autoplay.delay), clearTimeout(et), et = nextTick(() => { let xt; e.params.autoplay.reverseDirection ? e.params.loop ? (e.loopFix(), xt = e.slidePrev(e.params.speed, !0, !0), c("autoplay")) : e.isBeginning ? e.params.autoplay.stopOnLastSlide ? ft() : (xt = e.slideTo(e.slides.length - 1, e.params.speed, !0, !0), c("autoplay")) : (xt = e.slidePrev(e.params.speed, !0, !0), c("autoplay")) : e.params.loop ? (e.loopFix(), xt = e.slideNext(e.params.speed, !0, !0), c("autoplay")) : e.isEnd ? e.params.autoplay.stopOnLastSlide ? ft() : (xt = e.slideTo(0, e.params.speed, !0, !0), c("autoplay")) : (xt = e.slideNext(e.params.speed, !0, !0), c("autoplay")), (e.params.cssMode && e.autoplay.running || xt === !1) && at() }, Dt) } function lt() { return typeof et < "u" || e.autoplay.running ? !1 : (e.autoplay.running = !0, c("autoplayStart"), at(), !0) } function ft() { return !e.autoplay.running || typeof et > "u" ? !1 : (et && (clearTimeout(et), et = void 0), e.autoplay.running = !1, c("autoplayStop"), !0) } function dt(kt) { !e.autoplay.running || e.autoplay.paused || (et && clearTimeout(et), e.autoplay.paused = !0, kt === 0 || !e.params.autoplay.waitForTransition ? (e.autoplay.paused = !1, at()) : ["transitionend", "webkitTransitionEnd"].forEach(Dt => { e.$wrapperEl[0].addEventListener(Dt, vt) })) } function ht() { const kt = getDocument(); kt.visibilityState === "hidden" && e.autoplay.running && dt(), kt.visibilityState === "visible" && e.autoplay.paused && (at(), e.autoplay.paused = !1) } function vt(kt) { !e || e.destroyed || !e.$wrapperEl || kt.target === e.$wrapperEl[0] && (["transitionend", "webkitTransitionEnd"].forEach(Dt => { e.$wrapperEl[0].removeEventListener(Dt, vt) }), e.autoplay.paused = !1, e.autoplay.running ? at() : ft()) } function wt() { e.params.autoplay.disableOnInteraction ? ft() : (c("autoplayPause"), dt()), ["transitionend", "webkitTransitionEnd"].forEach(kt => { e.$wrapperEl[0].removeEventListener(kt, vt) }) } function St() { e.params.autoplay.disableOnInteraction || (e.autoplay.paused = !1, c("autoplayResume"), at()) } function _t() { e.params.autoplay.pauseOnMouseEnter && (e.$el.on("mouseenter", wt), e.$el.on("mouseleave", St)) } function Nt() { e.$el.off("mouseenter", wt), e.$el.off("mouseleave", St) } o("init", () => { e.params.autoplay.enabled && (lt(), getDocument().addEventListener("visibilitychange", ht), _t()) }), o("beforeTransitionStart", (kt, Dt, xt) => { e.autoplay.running && (xt || !e.params.autoplay.disableOnInteraction ? e.autoplay.pause(Dt) : ft()) }), o("sliderFirstMove", () => { e.autoplay.running && (e.params.autoplay.disableOnInteraction ? ft() : dt()) }), o("touchEnd", () => { e.params.cssMode && e.autoplay.paused && !e.params.autoplay.disableOnInteraction && at() }), o("destroy", () => { Nt(), e.autoplay.running && ft(), getDocument().removeEventListener("visibilitychange", ht) }), Object.assign(e.autoplay, { pause: dt, run: at, start: lt, stop: ft }) } function isObject$1(e) { return typeof e == "object" && e !== null && e.constructor && Object.prototype.toString.call(e).slice(8, -1) === "Object" } function extend(e, s) { const o = ["__proto__", "constructor", "prototype"]; Object.keys(s).filter(c => o.indexOf(c) < 0).forEach(c => { typeof e[c] > "u" ? e[c] = s[c] : isObject$1(s[c]) && isObject$1(e[c]) && Object.keys(s[c]).length > 0 ? s[c].__swiper__ ? e[c] = s[c] : extend(e[c], s[c]) : e[c] = s[c] }) } function needsNavigation(e = {}) { return e.navigation && typeof e.navigation.nextEl > "u" && typeof e.navigation.prevEl > "u" } function needsPagination(e = {}) { return e.pagination && typeof e.pagination.el > "u" } function needsScrollbar(e = {}) { return e.scrollbar && typeof e.scrollbar.el > "u" } function uniqueClasses(e = "") { const s = e.split(" ").map(c => c.trim()).filter(c => !!c), o = []; return s.forEach(c => { o.indexOf(c) < 0 && o.push(c) }), o.join(" ") } const paramsList = ["modules", "init", "_direction", "touchEventsTarget", "initialSlide", "_speed", "cssMode", "updateOnWindowResize", "resizeObserver", "nested", "focusableElements", "_enabled", "_width", "_height", "preventInteractionOnTransition", "userAgent", "url", "_edgeSwipeDetection", "_edgeSwipeThreshold", "_freeMode", "_autoHeight", "setWrapperSize", "virtualTranslate", "_effect", "breakpoints", "_spaceBetween", "_slidesPerView", "maxBackfaceHiddenSlides", "_grid", "_slidesPerGroup", "_slidesPerGroupSkip", "_slidesPerGroupAuto", "_centeredSlides", "_centeredSlidesBounds", "_slidesOffsetBefore", "_slidesOffsetAfter", "normalizeSlideIndex", "_centerInsufficientSlides", "_watchOverflow", "roundLengths", "touchRatio", "touchAngle", "simulateTouch", "_shortSwipes", "_longSwipes", "longSwipesRatio", "longSwipesMs", "_followFinger", "allowTouchMove", "_threshold", "touchMoveStopPropagation", "touchStartPreventDefault", "touchStartForcePreventDefault", "touchReleaseOnEdges", "uniqueNavElements", "_resistance", "_resistanceRatio", "_watchSlidesProgress", "_grabCursor", "preventClicks", "preventClicksPropagation", "_slideToClickedSlide", "_preloadImages", "updateOnImagesReady", "_loop", "_loopAdditionalSlides", "_loopedSlides", "_loopedSlidesLimit", "_loopFillGroupWithBlank", "loopPreventsSlide", "_rewind", "_allowSlidePrev", "_allowSlideNext", "_swipeHandler", "_noSwiping", "noSwipingClass", "noSwipingSelector", "passiveListeners", "containerModifierClass", "slideClass", "slideBlankClass", "slideActiveClass", "slideDuplicateActiveClass", "slideVisibleClass", "slideDuplicateClass", "slideNextClass", "slideDuplicateNextClass", "slidePrevClass", "slideDuplicatePrevClass", "wrapperClass", "runCallbacksOnInit", "observer", "observeParents", "observeSlideChildren", "a11y", "_autoplay", "_controller", "coverflowEffect", "cubeEffect", "fadeEffect", "flipEffect", "creativeEffect", "cardsEffect", "hashNavigation", "history", "keyboard", "lazy", "mousewheel", "_navigation", "_pagination", "parallax", "_scrollbar", "_thumbs", "virtual", "zoom"]; function getParams(e = {}, s = !0) { const o = { on: {} }, c = {}, et = {}; extend(o, Swiper$1.defaults), extend(o, Swiper$1.extendedDefaults), o._emitClasses = !0, o.init = !1; const at = {}, lt = paramsList.map(dt => dt.replace(/_/, "")), ft = Object.assign({}, e); return Object.keys(ft).forEach(dt => { typeof e[dt] > "u" || (lt.indexOf(dt) >= 0 ? isObject$1(e[dt]) ? (o[dt] = {}, et[dt] = {}, extend(o[dt], e[dt]), extend(et[dt], e[dt])) : (o[dt] = e[dt], et[dt] = e[dt]) : dt.search(/on[A-Z]/) === 0 && typeof e[dt] == "function" ? s ? c[`${dt[2].toLowerCase()}${dt.substr(3)}`] = e[dt] : o.on[`${dt[2].toLowerCase()}${dt.substr(3)}`] = e[dt] : at[dt] = e[dt]) }), ["navigation", "pagination", "scrollbar"].forEach(dt => { o[dt] === !0 && (o[dt] = {}), o[dt] === !1 && delete o[dt] }), { params: o, passedParams: et, rest: at, events: c } } function mountSwiper({ el: e, nextEl: s, prevEl: o, paginationEl: c, scrollbarEl: et, swiper: at }, lt) { needsNavigation(lt) && s && o && (at.params.navigation.nextEl = s, at.originalParams.navigation.nextEl = s, at.params.navigation.prevEl = o, at.originalParams.navigation.prevEl = o), needsPagination(lt) && c && (at.params.pagination.el = c, at.originalParams.pagination.el = c), needsScrollbar(lt) && et && (at.params.scrollbar.el = et, at.originalParams.scrollbar.el = et), at.init(e) } const calcLoopedSlides = (e, s) => { let o = s.slidesPerView; if (s.breakpoints) { const et = Swiper$1.prototype.getBreakpoint(s.breakpoints), at = et in s.breakpoints ? s.breakpoints[et] : void 0; at && at.slidesPerView && (o = at.slidesPerView) } let c = Math.ceil(parseFloat(s.loopedSlides || o, 10)); return c += s.loopAdditionalSlides, c > e.length && s.loopedSlidesLimit && (c = e.length), c }; function renderLoop(e, s, o) { const c = s.map((dt, ht) => React.cloneElement(dt, { swiper: e, "data-swiper-slide-index": ht })); function et(dt, ht, vt) { return React.cloneElement(dt, { key: `${dt.key}-duplicate-${ht}-${vt}`, className: `${dt.props.className || ""} ${o.slideDuplicateClass}` }) } if (o.loopFillGroupWithBlank) { const dt = o.slidesPerGroup - c.length % o.slidesPerGroup; if (dt !== o.slidesPerGroup) for (let ht = 0; ht < dt; ht += 1) { const vt = jsx("div", { className: `${o.slideClass} ${o.slideBlankClass}` }); c.push(vt) } } o.slidesPerView === "auto" && !o.loopedSlides && (o.loopedSlides = c.length); const at = calcLoopedSlides(c, o), lt = [], ft = []; for (let dt = 0; dt < at; dt += 1) { const ht = dt - Math.floor(dt / c.length) * c.length; ft.push(et(c[ht], dt, "append")), lt.unshift(et(c[c.length - ht - 1], dt, "prepend")) } return e && (e.loopedSlides = at), [...lt, ...c, ...ft] } function getChangedParams(e, s, o, c, et) { const at = []; if (!s) return at; const lt = dt => { at.indexOf(dt) < 0 && at.push(dt) }; if (o && c) { const dt = c.map(et), ht = o.map(et); dt.join("") !== ht.join("") && lt("children"), c.length !== o.length && lt("children") } return paramsList.filter(dt => dt[0] === "_").map(dt => dt.replace(/_/, "")).forEach(dt => { if (dt in e && dt in s) if (isObject$1(e[dt]) && isObject$1(s[dt])) { const ht = Object.keys(e[dt]), vt = Object.keys(s[dt]); ht.length !== vt.length ? lt(dt) : (ht.forEach(wt => { e[dt][wt] !== s[dt][wt] && lt(dt) }), vt.forEach(wt => { e[dt][wt] !== s[dt][wt] && lt(dt) })) } else e[dt] !== s[dt] && lt(dt) }), at } function isChildSwiperSlide(e) { return e.type && e.type.displayName && e.type.displayName.includes("SwiperSlide") } function processChildren(e) { const s = []; return React.Children.toArray(e).forEach(o => { isChildSwiperSlide(o) ? s.push(o) : o.props && o.props.children && processChildren(o.props.children).forEach(c => s.push(c)) }), s } function getChildren(e) { const s = [], o = { "container-start": [], "container-end": [], "wrapper-start": [], "wrapper-end": [] }; return React.Children.toArray(e).forEach(c => { if (isChildSwiperSlide(c)) s.push(c); else if (c.props && c.props.slot && o[c.props.slot]) o[c.props.slot].push(c); else if (c.props && c.props.children) { const et = processChildren(c.props.children); et.length > 0 ? et.forEach(at => s.push(at)) : o["container-end"].push(c) } else o["container-end"].push(c) }), { slides: s, slots: o } } function updateSwiper({ swiper: e, slides: s, passedParams: o, changedParams: c, nextEl: et, prevEl: at, scrollbarEl: lt, paginationEl: ft }) { const dt = c.filter(Rt => Rt !== "children" && Rt !== "direction"), { params: ht, pagination: vt, navigation: wt, scrollbar: St, virtual: _t, thumbs: Nt } = e; let kt, Dt, xt, Ct, bt; c.includes("thumbs") && o.thumbs && o.thumbs.swiper && ht.thumbs && !ht.thumbs.swiper && (kt = !0), c.includes("controller") && o.controller && o.controller.control && ht.controller && !ht.controller.control && (Dt = !0), c.includes("pagination") && o.pagination && (o.pagination.el || ft) && (ht.pagination || ht.pagination === !1) && vt && !vt.el && (xt = !0), c.includes("scrollbar") && o.scrollbar && (o.scrollbar.el || lt) && (ht.scrollbar || ht.scrollbar === !1) && St && !St.el && (Ct = !0), c.includes("navigation") && o.navigation && (o.navigation.prevEl || at) && (o.navigation.nextEl || et) && (ht.navigation || ht.navigation === !1) && wt && !wt.prevEl && !wt.nextEl && (bt = !0); const Pt = Rt => { !e[Rt] || (e[Rt].destroy(), Rt === "navigation" ? (ht[Rt].prevEl = void 0, ht[Rt].nextEl = void 0, e[Rt].prevEl = void 0, e[Rt].nextEl = void 0) : (ht[Rt].el = void 0, e[Rt].el = void 0)) }; dt.forEach(Rt => { if (isObject$1(ht[Rt]) && isObject$1(o[Rt])) extend(ht[Rt], o[Rt]); else { const Jn = o[Rt]; (Jn === !0 || Jn === !1) && (Rt === "navigation" || Rt === "pagination" || Rt === "scrollbar") ? Jn === !1 && Pt(Rt) : ht[Rt] = o[Rt] } }), dt.includes("controller") && !Dt && e.controller && e.controller.control && ht.controller && ht.controller.control && (e.controller.control = ht.controller.control), c.includes("children") && s && _t && ht.virtual.enabled ? (_t.slides = s, _t.update(!0)) : c.includes("children") && e.lazy && e.params.lazy.enabled && e.lazy.load(), kt && Nt.init() && Nt.update(!0), Dt && (e.controller.control = ht.controller.control), xt && (ft && (ht.pagination.el = ft), vt.init(), vt.render(), vt.update()), Ct && (lt && (ht.scrollbar.el = lt), St.init(), St.updateSize(), St.setTranslate()), bt && (et && (ht.navigation.nextEl = et), at && (ht.navigation.prevEl = at), wt.init(), wt.update()), c.includes("allowSlideNext") && (e.allowSlideNext = o.allowSlideNext), c.includes("allowSlidePrev") && (e.allowSlidePrev = o.allowSlidePrev), c.includes("direction") && e.changeDirection(o.direction, !1), e.update() } function renderVirtual(e, s, o) { if (!o) return null; const c = e.isHorizontal() ? { [e.rtlTranslate ? "right" : "left"]: `${o.offset}px` } : { top: `${o.offset}px` }; return s.filter((et, at) => at >= o.from && at <= o.to).map(et => React.cloneElement(et, { swiper: e, style: c })) } const updateOnVirtualData = e => { !e || e.destroyed || !e.params.virtual || e.params.virtual && !e.params.virtual.enabled || (e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.lazy && e.params.lazy.enabled && e.lazy.load(), e.parallax && e.params.parallax && e.params.parallax.enabled && e.parallax.setTranslate()) }; function useIsomorphicLayoutEffect(e, s) { return typeof window > "u" ? react.exports.useEffect(e, s) : react.exports.useLayoutEffect(e, s) } const SwiperSlideContext = react.exports.createContext(null), SwiperContext = react.exports.createContext(null), Swiper = react.exports.forwardRef(function (e, s) { let { className: o, tag: c = "div", wrapperTag: et = "div", children: at, onSwiper: lt, ...ft } = e === void 0 ? {} : e, dt = !1; const [ht, vt] = react.exports.useState("swiper"), [wt, St] = react.exports.useState(null), [_t, Nt] = react.exports.useState(!1), kt = react.exports.useRef(!1), Dt = react.exports.useRef(null), xt = react.exports.useRef(null), Ct = react.exports.useRef(null), bt = react.exports.useRef(null), Pt = react.exports.useRef(null), Rt = react.exports.useRef(null), Jn = react.exports.useRef(null), er = react.exports.useRef(null), { params: Zt, passedParams: lr, rest: tr, events: xn } = getParams(ft), { slides: jt, slots: Gt } = getChildren(at), nr = () => { Nt(!_t) }; Object.assign(Zt.on, { _containerClasses(ir, or) { vt(or) } }); const sr = () => { if (Object.assign(Zt.on, xn), dt = !0, xt.current = new Swiper$1(Zt), xt.current.loopCreate = () => { }, xt.current.loopDestroy = () => { }, Zt.loop && (xt.current.loopedSlides = calcLoopedSlides(jt, Zt)), xt.current.virtual && xt.current.params.virtual.enabled) { xt.current.virtual.slides = jt; const ir = { cache: !1, slides: jt, renderExternal: St, renderExternalUpdate: !1 }; extend(xt.current.params.virtual, ir), extend(xt.current.originalParams.virtual, ir) } }; Dt.current || sr(), xt.current && xt.current.on("_beforeBreakpoint", nr); const rr = () => { dt || !xn || !xt.current || Object.keys(xn).forEach(ir => { xt.current.on(ir, xn[ir]) }) }, ar = () => { !xn || !xt.current || Object.keys(xn).forEach(ir => { xt.current.off(ir, xn[ir]) }) }; react.exports.useEffect(() => () => { xt.current && xt.current.off("_beforeBreakpoint", nr) }), react.exports.useEffect(() => { !kt.current && xt.current && (xt.current.emitSlidesClasses(), kt.current = !0) }), useIsomorphicLayoutEffect(() => { if (s && (s.current = Dt.current), !!Dt.current) return xt.current.destroyed && sr(), mountSwiper({ el: Dt.current, nextEl: Pt.current, prevEl: Rt.current, paginationEl: Jn.current, scrollbarEl: er.current, swiper: xt.current }, Zt), lt && lt(xt.current), () => { xt.current && !xt.current.destroyed && xt.current.destroy(!0, !1) } }, []), useIsomorphicLayoutEffect(() => { rr(); const ir = getChangedParams(lr, Ct.current, jt, bt.current, or => or.key); return Ct.current = lr, bt.current = jt, ir.length && xt.current && !xt.current.destroyed && updateSwiper({ swiper: xt.current, slides: jt, passedParams: lr, changedParams: ir, nextEl: Pt.current, prevEl: Rt.current, scrollbarEl: er.current, paginationEl: Jn.current }), () => { ar() } }), useIsomorphicLayoutEffect(() => { updateOnVirtualData(xt.current) }, [wt]); function _n() { return Zt.virtual ? renderVirtual(xt.current, jt, wt) : !Zt.loop || xt.current && xt.current.destroyed ? jt.map(ir => React.cloneElement(ir, { swiper: xt.current })) : renderLoop(xt.current, jt, Zt) } return jsx(c, { ref: Dt, className: uniqueClasses(`${ht}${o ? ` ${o}` : ""}`), ...tr, children: jsxs(SwiperContext.Provider, { value: xt.current, children: [Gt["container-start"], jsxs(et, { className: "swiper-wrapper", children: [Gt["wrapper-start"], _n(), Gt["wrapper-end"]] }), needsNavigation(Zt) && jsxs(Fragment, { children: [jsx("div", { ref: Rt, className: "swiper-button-prev" }), jsx("div", { ref: Pt, className: "swiper-button-next" })] }), needsScrollbar(Zt) && jsx("div", { ref: er, className: "swiper-scrollbar" }), needsPagination(Zt) && jsx("div", { ref: Jn, className: "swiper-pagination" }), Gt["container-end"]] }) }) }); Swiper.displayName = "Swiper"; const SwiperSlide = react.exports.forwardRef(function (e, s) { let { tag: o = "div", children: c, className: et = "", swiper: at, zoom: lt, virtualIndex: ft, ...dt } = e === void 0 ? {} : e; const ht = react.exports.useRef(null), [vt, wt] = react.exports.useState("swiper-slide"); function St(kt, Dt, xt) { Dt === ht.current && wt(xt) } useIsomorphicLayoutEffect(() => { if (s && (s.current = ht.current), !(!ht.current || !at)) { if (at.destroyed) { vt !== "swiper-slide" && wt("swiper-slide"); return } return at.on("_slideClass", St), () => { !at || at.off("_slideClass", St) } } }), useIsomorphicLayoutEffect(() => { at && ht.current && !at.destroyed && wt(at.getSlideClasses(ht.current)) }, [at]); const _t = { isActive: vt.indexOf("swiper-slide-active") >= 0 || vt.indexOf("swiper-slide-duplicate-active") >= 0, isVisible: vt.indexOf("swiper-slide-visible") >= 0, isDuplicate: vt.indexOf("swiper-slide-duplicate") >= 0, isPrev: vt.indexOf("swiper-slide-prev") >= 0 || vt.indexOf("swiper-slide-duplicate-prev") >= 0, isNext: vt.indexOf("swiper-slide-next") >= 0 || vt.indexOf("swiper-slide-duplicate-next") >= 0 }, Nt = () => typeof c == "function" ? c(_t) : c; return jsx(o, { ref: ht, className: uniqueClasses(`${vt}${et ? ` ${et}` : ""}`), "data-swiper-slide-index": ft, ...dt, children: jsx(SwiperSlideContext.Provider, { value: _t, children: lt ? jsx("div", { className: "swiper-zoom-container", "data-swiper-zoom": typeof lt == "number" ? lt : void 0, children: Nt() }) : Nt() }) }) }); SwiperSlide.displayName = "SwiperSlide"; const swiper_min = "", navigation_min = "", pagination_min = "", scrollbar_min = "", autoplay_min = "", Testimonials = () => jsxs("section", { id: "reviews", className: `${styles$1.paddingY}`, children: [jsx("div", { className: "block ss:hidden min-h-[100px]" }), jsxs("div", { className: "py-5", children: [jsx("h2", { className: `${styles$1.heading2}`, children: "Clients Reviews" }), jsx("p", { className: `${styles$1.paragraph}`, children: " What our clients say about us" })] }), jsxs("div", { className: " py-5 flex items-start flex-wrap justify-between", children: [jsx("div", { className: "w-[100%] sm:w-[78%] md:w-[70%] bg-dimBlue p-4 ss:p-14", children: jsx(Swiper, { modules: [Autoplay, Navigation, Pagination, Scrollbar, A11y], spaceBetween: 50, slidesPerView: 1, autoplay: !0, navigation: { prevEl: ".swiper-button-prev", nextEl: ".swiper-button-next" }, pagination: { el: ".swiper-pagination-div", type: "fraction", clickable: !0, renderBullet: (e, s) => '<span class="' + s + '">' + (e + 1) + "</span>" }, children: testimonials.map(e => jsxs(SwiperSlide, { children: [jsx("div", { children: jsxs("p", { className: `${styles$1.paragraph} mt-5`, children: [" ", e.content, " "] }) }), jsxs("div", { className: "flex items-center mt-5", children: [jsx("div", { className: "w-[80px] h-[80px] rounded-full mt-5", children: jsx("img", { className: "w-[100%] h-[100%] object-contain rounded-full", src: e.img, alt: "" }) }), jsxs("div", { className: "mx-5", children: [jsxs("h4", { className: "font-normal text-[16px] leading-[30.8px] mt-2", children: [" ", e.name, " "] }), jsxs("p", { className: "font-normal text-greyish text-[14px] leading-[30.8px]", children: [" ", e.title, " "] })] })] })] }, e.id)) }) }), jsxs("div", { className: "w-[50%] ss:w-[20%] md:w-[25%] text-center py-5 sm:py-0 sm:h-[300px] flex items-center justify-center flex-col", children: [jsxs("div", { className: "flex", children: [jsx("div", { className: "swiper-pagination-div text-xl" }), jsx("span", { className: "ml-3 text-xl", children: " People " })] }), jsxs("div", { className: "flex my-5 pb-5", children: [jsx("div", { className: "text-3xl text-blue-300", children: jsx(AiFillStar, {}) }), jsx("div", { className: "text-3xl text-blue-300", children: jsx(AiFillStar, {}) }), jsx("div", { className: "text-3xl text-blue-300", children: jsx(AiFillStar, {}) }), jsx("div", { className: "text-3xl text-blue-300", children: jsx(AiFillStar, {}) }), jsx("div", { className: "text-3xl", children: jsx(AiFillStar, {}) })] }), jsxs("div", { className: "relative w-[90%] md:w-[50%]", children: [jsx("div", { className: "swiper-button-next", children: " " }), jsx("div", { className: "swiper-button-prev ", children: " " })] })] })] })] }), Explore = () => jsxs("section", { id: "explore", className: `flex flex-col md:flex-row ${styles$1.paddingY}`, children: [jsxs("div", { className: layout.sectionInfo, children: [jsxs("h2", { className: styles$1.heading2, children: ["Move ahead with us to  ", jsx("br", { className: "hidden md:block" }), "explore the world"] }), jsx("p", { className: `${styles$1.paragraph} max-w-[470px] mt-5`, children: "Lorem ipsum dolor sit amet consectetur adipisicing elit. Nihil reprehenderit natus culpa error modi" }), jsx(Button, { title: "Let's Get Started", icon: jsx(AiOutlineArrowRight, {}) })] }), jsx("div", { className: `${layout.sectionImg}`, children: jsx("img", { src: app$1, alt: "App" }) })] }), Connect = () => { const [e, s] = react.exports.useState(!1), o = () => { s(!0) }, c = () => { s(!1) }; return jsxs("section", { id: "contact", children: [jsx("div", { className: "block ss:hidden min-h-[100px]" }), jsxs("div", { className: `${styles$1.flexCenter} ${styles$1.marginY} ${styles$1.padding} sm:flex-row flex-col bg-black-gradient-2 rounded-[20px] transparent_box_shadow`, children: [jsxs("div", { className: "flex-1 flex flex-col", children: [jsx("h2", { className: styles$1.heading2, children: "Get in touch with us!" }), jsx("p", { className: `${styles$1.paragraph} max-w-[470px] mt-2 sm:mt-5`, children: "Have any query ? No worries, connect with us today by clicking on contact us button and send you message directly with us" })] }), jsx("div", { className: `md:${styles$1.flexCenter} inline-block w-full sm:w-auto sm:ml-10 ml-0 sm:mt-0 mt-10`, children: jsx(Button, { onclick: o, title: "Contact Us", icon: jsx(AiFillPhone, {}) }) }), e && jsx(ContactModal, { close: c })] })] }) };/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const stringToByteArray$1 = function (e) { const s = []; let o = 0; for (let c = 0; c < e.length; c++) { let et = e.charCodeAt(c); et < 128 ? s[o++] = et : et < 2048 ? (s[o++] = et >> 6 | 192, s[o++] = et & 63 | 128) : (et & 64512) === 55296 && c + 1 < e.length && (e.charCodeAt(c + 1) & 64512) === 56320 ? (et = 65536 + ((et & 1023) << 10) + (e.charCodeAt(++c) & 1023), s[o++] = et >> 18 | 240, s[o++] = et >> 12 & 63 | 128, s[o++] = et >> 6 & 63 | 128, s[o++] = et & 63 | 128) : (s[o++] = et >> 12 | 224, s[o++] = et >> 6 & 63 | 128, s[o++] = et & 63 | 128) } return s }, byteArrayToString = function (e) { const s = []; let o = 0, c = 0; for (; o < e.length;) { const et = e[o++]; if (et < 128) s[c++] = String.fromCharCode(et); else if (et > 191 && et < 224) { const at = e[o++]; s[c++] = String.fromCharCode((et & 31) << 6 | at & 63) } else if (et > 239 && et < 365) { const at = e[o++], lt = e[o++], ft = e[o++], dt = ((et & 7) << 18 | (at & 63) << 12 | (lt & 63) << 6 | ft & 63) - 65536; s[c++] = String.fromCharCode(55296 + (dt >> 10)), s[c++] = String.fromCharCode(56320 + (dt & 1023)) } else { const at = e[o++], lt = e[o++]; s[c++] = String.fromCharCode((et & 15) << 12 | (at & 63) << 6 | lt & 63) } } return s.join("") }, base64 = { byteToCharMap_: null, charToByteMap_: null, byteToCharMapWebSafe_: null, charToByteMapWebSafe_: null, ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", get ENCODED_VALS() { return this.ENCODED_VALS_BASE + "+/=" }, get ENCODED_VALS_WEBSAFE() { return this.ENCODED_VALS_BASE + "-_." }, HAS_NATIVE_SUPPORT: typeof atob == "function", encodeByteArray(e, s) { if (!Array.isArray(e)) throw Error("encodeByteArray takes an array as a parameter"); this.init_(); const o = s ? this.byteToCharMapWebSafe_ : this.byteToCharMap_, c = []; for (let et = 0; et < e.length; et += 3) { const at = e[et], lt = et + 1 < e.length, ft = lt ? e[et + 1] : 0, dt = et + 2 < e.length, ht = dt ? e[et + 2] : 0, vt = at >> 2, wt = (at & 3) << 4 | ft >> 4; let St = (ft & 15) << 2 | ht >> 6, _t = ht & 63; dt || (_t = 64, lt || (St = 64)), c.push(o[vt], o[wt], o[St], o[_t]) } return c.join("") }, encodeString(e, s) { return this.HAS_NATIVE_SUPPORT && !s ? btoa(e) : this.encodeByteArray(stringToByteArray$1(e), s) }, decodeString(e, s) { return this.HAS_NATIVE_SUPPORT && !s ? atob(e) : byteArrayToString(this.decodeStringToByteArray(e, s)) }, decodeStringToByteArray(e, s) { this.init_(); const o = s ? this.charToByteMapWebSafe_ : this.charToByteMap_, c = []; for (let et = 0; et < e.length;) { const at = o[e.charAt(et++)], ft = et < e.length ? o[e.charAt(et)] : 0; ++et; const ht = et < e.length ? o[e.charAt(et)] : 64; ++et; const wt = et < e.length ? o[e.charAt(et)] : 64; if (++et, at == null || ft == null || ht == null || wt == null) throw Error(); const St = at << 2 | ft >> 4; if (c.push(St), ht !== 64) { const _t = ft << 4 & 240 | ht >> 2; if (c.push(_t), wt !== 64) { const Nt = ht << 6 & 192 | wt; c.push(Nt) } } } return c }, init_() { if (!this.byteToCharMap_) { this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {}; for (let e = 0; e < this.ENCODED_VALS.length; e++)this.byteToCharMap_[e] = this.ENCODED_VALS.charAt(e), this.charToByteMap_[this.byteToCharMap_[e]] = e, this.byteToCharMapWebSafe_[e] = this.ENCODED_VALS_WEBSAFE.charAt(e), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[e]] = e, e >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(e)] = e, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(e)] = e) } } }, base64Encode = function (e) { const s = stringToByteArray$1(e); return base64.encodeByteArray(s, !0) }, base64urlEncodeWithoutPadding = function (e) { return base64Encode(e).replace(/\./g, "") }, base64Decode = function (e) { try { return base64.decodeString(e, !0) } catch (s) { console.error("base64Decode failed: ", s) } return null }; function isIndexedDBAvailable() { return typeof indexedDB == "object" } function validateIndexedDBOpenable() { return new Promise((e, s) => { try { let o = !0; const c = "validate-browser-context-for-indexeddb-analytics-module", et = self.indexedDB.open(c); et.onsuccess = () => { et.result.close(), o || self.indexedDB.deleteDatabase(c), e(!0) }, et.onupgradeneeded = () => { o = !1 }, et.onerror = () => { var at; s(((at = et.error) === null || at === void 0 ? void 0 : at.message) || "") } } catch (o) { s(o) } }) } function getGlobal() { if (typeof self < "u") return self; if (typeof window < "u") return window; if (typeof global < "u") return global; throw new Error("Unable to locate global object.") }/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const getDefaultsFromGlobal = () => getGlobal().__FIREBASE_DEFAULTS__, getDefaultsFromEnvVariable = () => { if (typeof process > "u" || typeof process.env > "u") return; const e = process.env.__FIREBASE_DEFAULTS__; if (e) return JSON.parse(e) }, getDefaultsFromCookie = () => { if (typeof document > "u") return; let e; try { e = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/) } catch { return } const s = e && base64Decode(e[1]); return s && JSON.parse(s) }, getDefaults = () => { try { return getDefaultsFromGlobal() || getDefaultsFromEnvVariable() || getDefaultsFromCookie() } catch (e) { console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`); return } }, getDefaultEmulatorHost = e => { var s, o; return (o = (s = getDefaults()) === null || s === void 0 ? void 0 : s.emulatorHosts) === null || o === void 0 ? void 0 : o[e] }, getDefaultEmulatorHostnameAndPort = e => { const s = getDefaultEmulatorHost(e); if (!s) return; const o = s.lastIndexOf(":"); if (o <= 0 || o + 1 === s.length) throw new Error(`Invalid host ${s} with no separate hostname and port!`); const c = parseInt(s.substring(o + 1), 10); return s[0] === "[" ? [s.substring(1, o - 1), c] : [s.substring(0, o), c] }, getDefaultAppConfig = () => { var e; return (e = getDefaults()) === null || e === void 0 ? void 0 : e.config };/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Deferred { constructor() { this.reject = () => { }, this.resolve = () => { }, this.promise = new Promise((s, o) => { this.resolve = s, this.reject = o }) } wrapCallback(s) { return (o, c) => { o ? this.reject(o) : this.resolve(c), typeof s == "function" && (this.promise.catch(() => { }), s.length === 1 ? s(o) : s(o, c)) } } }/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function createMockUserToken(e, s) { if (e.uid) throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.'); const o = { alg: "none", type: "JWT" }, c = s || "demo-project", et = e.iat || 0, at = e.sub || e.user_id; if (!at) throw new Error("mockUserToken must contain 'sub' or 'user_id' field!"); const lt = Object.assign({ iss: `https://securetoken.google.com/${c}`, aud: c, iat: et, exp: et + 3600, auth_time: et, sub: at, user_id: at, firebase: { sign_in_provider: "custom", identities: {} } }, e), ft = ""; return [base64urlEncodeWithoutPadding(JSON.stringify(o)), base64urlEncodeWithoutPadding(JSON.stringify(lt)), ft].join(".") }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const ERROR_NAME = "FirebaseError"; class FirebaseError extends Error { constructor(s, o, c) { super(o), this.code = s, this.customData = c, this.name = ERROR_NAME, Object.setPrototypeOf(this, FirebaseError.prototype), Error.captureStackTrace && Error.captureStackTrace(this, ErrorFactory.prototype.create) } } class ErrorFactory { constructor(s, o, c) { this.service = s, this.serviceName = o, this.errors = c } create(s, ...o) { const c = o[0] || {}, et = `${this.service}/${s}`, at = this.errors[s], lt = at ? replaceTemplate(at, c) : "Error", ft = `${this.serviceName}: ${lt} (${et}).`; return new FirebaseError(et, ft, c) } } function replaceTemplate(e, s) { return e.replace(PATTERN, (o, c) => { const et = s[c]; return et != null ? String(et) : `<${c}?>` }) } const PATTERN = /\{\$([^}]+)}/g; function deepEqual(e, s) { if (e === s) return !0; const o = Object.keys(e), c = Object.keys(s); for (const et of o) { if (!c.includes(et)) return !1; const at = e[et], lt = s[et]; if (isObject(at) && isObject(lt)) { if (!deepEqual(at, lt)) return !1 } else if (at !== lt) return !1 } for (const et of c) if (!o.includes(et)) return !1; return !0 } function isObject(e) { return e !== null && typeof e == "object" }/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function getModularInstance(e) { return e && e._delegate ? e._delegate : e } class Component { constructor(s, o, c) { this.name = s, this.instanceFactory = o, this.type = c, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null } setInstantiationMode(s) { return this.instantiationMode = s, this } setMultipleInstances(s) { return this.multipleInstances = s, this } setServiceProps(s) { return this.serviceProps = s, this } setInstanceCreatedCallback(s) { return this.onInstanceCreated = s, this } }/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const DEFAULT_ENTRY_NAME$1 = "[DEFAULT]";/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Provider { constructor(s, o) { this.name = s, this.container = o, this.component = null, this.instances = new Map, this.instancesDeferred = new Map, this.instancesOptions = new Map, this.onInitCallbacks = new Map } get(s) { const o = this.normalizeInstanceIdentifier(s); if (!this.instancesDeferred.has(o)) { const c = new Deferred; if (this.instancesDeferred.set(o, c), this.isInitialized(o) || this.shouldAutoInitialize()) try { const et = this.getOrInitializeService({ instanceIdentifier: o }); et && c.resolve(et) } catch { } } return this.instancesDeferred.get(o).promise } getImmediate(s) { var o; const c = this.normalizeInstanceIdentifier(s == null ? void 0 : s.identifier), et = (o = s == null ? void 0 : s.optional) !== null && o !== void 0 ? o : !1; if (this.isInitialized(c) || this.shouldAutoInitialize()) try { return this.getOrInitializeService({ instanceIdentifier: c }) } catch (at) { if (et) return null; throw at } else { if (et) return null; throw Error(`Service ${this.name} is not available`) } } getComponent() { return this.component } setComponent(s) { if (s.name !== this.name) throw Error(`Mismatching Component ${s.name} for Provider ${this.name}.`); if (this.component) throw Error(`Component for ${this.name} has already been provided`); if (this.component = s, !!this.shouldAutoInitialize()) { if (isComponentEager(s)) try { this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME$1 }) } catch { } for (const [o, c] of this.instancesDeferred.entries()) { const et = this.normalizeInstanceIdentifier(o); try { const at = this.getOrInitializeService({ instanceIdentifier: et }); c.resolve(at) } catch { } } } } clearInstance(s = DEFAULT_ENTRY_NAME$1) { this.instancesDeferred.delete(s), this.instancesOptions.delete(s), this.instances.delete(s) } async delete() { const s = Array.from(this.instances.values()); await Promise.all([...s.filter(o => "INTERNAL" in o).map(o => o.INTERNAL.delete()), ...s.filter(o => "_delete" in o).map(o => o._delete())]) } isComponentSet() { return this.component != null } isInitialized(s = DEFAULT_ENTRY_NAME$1) { return this.instances.has(s) } getOptions(s = DEFAULT_ENTRY_NAME$1) { return this.instancesOptions.get(s) || {} } initialize(s = {}) { const { options: o = {} } = s, c = this.normalizeInstanceIdentifier(s.instanceIdentifier); if (this.isInitialized(c)) throw Error(`${this.name}(${c}) has already been initialized`); if (!this.isComponentSet()) throw Error(`Component ${this.name} has not been registered yet`); const et = this.getOrInitializeService({ instanceIdentifier: c, options: o }); for (const [at, lt] of this.instancesDeferred.entries()) { const ft = this.normalizeInstanceIdentifier(at); c === ft && lt.resolve(et) } return et } onInit(s, o) { var c; const et = this.normalizeInstanceIdentifier(o), at = (c = this.onInitCallbacks.get(et)) !== null && c !== void 0 ? c : new Set; at.add(s), this.onInitCallbacks.set(et, at); const lt = this.instances.get(et); return lt && s(lt, et), () => { at.delete(s) } } invokeOnInitCallbacks(s, o) { const c = this.onInitCallbacks.get(o); if (!!c) for (const et of c) try { et(s, o) } catch { } } getOrInitializeService({ instanceIdentifier: s, options: o = {} }) { let c = this.instances.get(s); if (!c && this.component && (c = this.component.instanceFactory(this.container, { instanceIdentifier: normalizeIdentifierForFactory(s), options: o }), this.instances.set(s, c), this.instancesOptions.set(s, o), this.invokeOnInitCallbacks(c, s), this.component.onInstanceCreated)) try { this.component.onInstanceCreated(this.container, s, c) } catch { } return c || null } normalizeInstanceIdentifier(s = DEFAULT_ENTRY_NAME$1) { return this.component ? this.component.multipleInstances ? s : DEFAULT_ENTRY_NAME$1 : s } shouldAutoInitialize() { return !!this.component && this.component.instantiationMode !== "EXPLICIT" } } function normalizeIdentifierForFactory(e) { return e === DEFAULT_ENTRY_NAME$1 ? void 0 : e } function isComponentEager(e) { return e.instantiationMode === "EAGER" }/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class ComponentContainer { constructor(s) { this.name = s, this.providers = new Map } addComponent(s) { const o = this.getProvider(s.name); if (o.isComponentSet()) throw new Error(`Component ${s.name} has already been registered with ${this.name}`); o.setComponent(s) } addOrOverwriteComponent(s) { this.getProvider(s.name).isComponentSet() && this.providers.delete(s.name), this.addComponent(s) } getProvider(s) { if (this.providers.has(s)) return this.providers.get(s); const o = new Provider(s, this); return this.providers.set(s, o), o } getProviders() { return Array.from(this.providers.values()) } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var LogLevel; (function (e) { e[e.DEBUG = 0] = "DEBUG", e[e.VERBOSE = 1] = "VERBOSE", e[e.INFO = 2] = "INFO", e[e.WARN = 3] = "WARN", e[e.ERROR = 4] = "ERROR", e[e.SILENT = 5] = "SILENT" })(LogLevel || (LogLevel = {})); const levelStringToEnum = { debug: LogLevel.DEBUG, verbose: LogLevel.VERBOSE, info: LogLevel.INFO, warn: LogLevel.WARN, error: LogLevel.ERROR, silent: LogLevel.SILENT }, defaultLogLevel = LogLevel.INFO, ConsoleMethod = { [LogLevel.DEBUG]: "log", [LogLevel.VERBOSE]: "log", [LogLevel.INFO]: "info", [LogLevel.WARN]: "warn", [LogLevel.ERROR]: "error" }, defaultLogHandler = (e, s, ...o) => { if (s < e.logLevel) return; const c = new Date().toISOString(), et = ConsoleMethod[s]; if (et) console[et](`[${c}]  ${e.name}:`, ...o); else throw new Error(`Attempted to log a message with an invalid logType (value: ${s})`) }; class Logger { constructor(s) { this.name = s, this._logLevel = defaultLogLevel, this._logHandler = defaultLogHandler, this._userLogHandler = null } get logLevel() { return this._logLevel } set logLevel(s) { if (!(s in LogLevel)) throw new TypeError(`Invalid value "${s}" assigned to \`logLevel\``); this._logLevel = s } setLogLevel(s) { this._logLevel = typeof s == "string" ? levelStringToEnum[s] : s } get logHandler() { return this._logHandler } set logHandler(s) { if (typeof s != "function") throw new TypeError("Value assigned to `logHandler` must be a function"); this._logHandler = s } get userLogHandler() { return this._userLogHandler } set userLogHandler(s) { this._userLogHandler = s } debug(...s) { this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...s), this._logHandler(this, LogLevel.DEBUG, ...s) } log(...s) { this._userLogHandler && this._userLogHandler(this, LogLevel.VERBOSE, ...s), this._logHandler(this, LogLevel.VERBOSE, ...s) } info(...s) { this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...s), this._logHandler(this, LogLevel.INFO, ...s) } warn(...s) { this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...s), this._logHandler(this, LogLevel.WARN, ...s) } error(...s) { this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...s), this._logHandler(this, LogLevel.ERROR, ...s) } } const instanceOfAny = (e, s) => s.some(o => e instanceof o); let idbProxyableTypes, cursorAdvanceMethods; function getIdbProxyableTypes() { return idbProxyableTypes || (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]) } function getCursorAdvanceMethods() { return cursorAdvanceMethods || (cursorAdvanceMethods = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]) } const cursorRequestMap = new WeakMap, transactionDoneMap = new WeakMap, transactionStoreNamesMap = new WeakMap, transformCache = new WeakMap, reverseTransformCache = new WeakMap; function promisifyRequest(e) { const s = new Promise((o, c) => { const et = () => { e.removeEventListener("success", at), e.removeEventListener("error", lt) }, at = () => { o(wrap(e.result)), et() }, lt = () => { c(e.error), et() }; e.addEventListener("success", at), e.addEventListener("error", lt) }); return s.then(o => { o instanceof IDBCursor && cursorRequestMap.set(o, e) }).catch(() => { }), reverseTransformCache.set(s, e), s } function cacheDonePromiseForTransaction(e) { if (transactionDoneMap.has(e)) return; const s = new Promise((o, c) => { const et = () => { e.removeEventListener("complete", at), e.removeEventListener("error", lt), e.removeEventListener("abort", lt) }, at = () => { o(), et() }, lt = () => { c(e.error || new DOMException("AbortError", "AbortError")), et() }; e.addEventListener("complete", at), e.addEventListener("error", lt), e.addEventListener("abort", lt) }); transactionDoneMap.set(e, s) } let idbProxyTraps = { get(e, s, o) { if (e instanceof IDBTransaction) { if (s === "done") return transactionDoneMap.get(e); if (s === "objectStoreNames") return e.objectStoreNames || transactionStoreNamesMap.get(e); if (s === "store") return o.objectStoreNames[1] ? void 0 : o.objectStore(o.objectStoreNames[0]) } return wrap(e[s]) }, set(e, s, o) { return e[s] = o, !0 }, has(e, s) { return e instanceof IDBTransaction && (s === "done" || s === "store") ? !0 : s in e } }; function replaceTraps(e) { idbProxyTraps = e(idbProxyTraps) } function wrapFunction(e) { return e === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function (s, ...o) { const c = e.call(unwrap(this), s, ...o); return transactionStoreNamesMap.set(c, s.sort ? s.sort() : [s]), wrap(c) } : getCursorAdvanceMethods().includes(e) ? function (...s) { return e.apply(unwrap(this), s), wrap(cursorRequestMap.get(this)) } : function (...s) { return wrap(e.apply(unwrap(this), s)) } } function transformCachableValue(e) { return typeof e == "function" ? wrapFunction(e) : (e instanceof IDBTransaction && cacheDonePromiseForTransaction(e), instanceOfAny(e, getIdbProxyableTypes()) ? new Proxy(e, idbProxyTraps) : e) } function wrap(e) { if (e instanceof IDBRequest) return promisifyRequest(e); if (transformCache.has(e)) return transformCache.get(e); const s = transformCachableValue(e); return s !== e && (transformCache.set(e, s), reverseTransformCache.set(s, e)), s } const unwrap = e => reverseTransformCache.get(e); function openDB(e, s, { blocked: o, upgrade: c, blocking: et, terminated: at } = {}) { const lt = indexedDB.open(e, s), ft = wrap(lt); return c && lt.addEventListener("upgradeneeded", dt => { c(wrap(lt.result), dt.oldVersion, dt.newVersion, wrap(lt.transaction)) }), o && lt.addEventListener("blocked", () => o()), ft.then(dt => { at && dt.addEventListener("close", () => at()), et && dt.addEventListener("versionchange", () => et()) }).catch(() => { }), ft } const readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"], writeMethods = ["put", "add", "delete", "clear"], cachedMethods = new Map; function getMethod(e, s) { if (!(e instanceof IDBDatabase && !(s in e) && typeof s == "string")) return; if (cachedMethods.get(s)) return cachedMethods.get(s); const o = s.replace(/FromIndex$/, ""), c = s !== o, et = writeMethods.includes(o); if (!(o in (c ? IDBIndex : IDBObjectStore).prototype) || !(et || readMethods.includes(o))) return; const at = async function (lt, ...ft) { const dt = this.transaction(lt, et ? "readwrite" : "readonly"); let ht = dt.store; return c && (ht = ht.index(ft.shift())), (await Promise.all([ht[o](...ft), et && dt.done]))[0] }; return cachedMethods.set(s, at), at } replaceTraps(e => ({ ...e, get: (s, o, c) => getMethod(s, o) || e.get(s, o, c), has: (s, o) => !!getMethod(s, o) || e.has(s, o) }));/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class PlatformLoggerServiceImpl { constructor(s) { this.container = s } getPlatformInfoString() { return this.container.getProviders().map(o => { if (isVersionServiceProvider(o)) { const c = o.getImmediate(); return `${c.library}/${c.version}` } else return null }).filter(o => o).join(" ") } } function isVersionServiceProvider(e) { const s = e.getComponent(); return (s == null ? void 0 : s.type) === "VERSION" } const name$o = "@firebase/app", version$1 = "0.8.3";/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const logger = new Logger("@firebase/app"), name$n = "@firebase/app-compat", name$m = "@firebase/analytics-compat", name$l = "@firebase/analytics", name$k = "@firebase/app-check-compat", name$j = "@firebase/app-check", name$i = "@firebase/auth", name$h = "@firebase/auth-compat", name$g = "@firebase/database", name$f = "@firebase/database-compat", name$e = "@firebase/functions", name$d = "@firebase/functions-compat", name$c = "@firebase/installations", name$b = "@firebase/installations-compat", name$a = "@firebase/messaging", name$9 = "@firebase/messaging-compat", name$8 = "@firebase/performance", name$7 = "@firebase/performance-compat", name$6 = "@firebase/remote-config", name$5 = "@firebase/remote-config-compat", name$4 = "@firebase/storage", name$3 = "@firebase/storage-compat", name$2 = "@firebase/firestore", name$1 = "@firebase/firestore-compat", name$p = "firebase", version$2 = "9.13.0";/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const DEFAULT_ENTRY_NAME = "[DEFAULT]", PLATFORM_LOG_STRING = { [name$o]: "fire-core", [name$n]: "fire-core-compat", [name$l]: "fire-analytics", [name$m]: "fire-analytics-compat", [name$j]: "fire-app-check", [name$k]: "fire-app-check-compat", [name$i]: "fire-auth", [name$h]: "fire-auth-compat", [name$g]: "fire-rtdb", [name$f]: "fire-rtdb-compat", [name$e]: "fire-fn", [name$d]: "fire-fn-compat", [name$c]: "fire-iid", [name$b]: "fire-iid-compat", [name$a]: "fire-fcm", [name$9]: "fire-fcm-compat", [name$8]: "fire-perf", [name$7]: "fire-perf-compat", [name$6]: "fire-rc", [name$5]: "fire-rc-compat", [name$4]: "fire-gcs", [name$3]: "fire-gcs-compat", [name$2]: "fire-fst", [name$1]: "fire-fst-compat", "fire-js": "fire-js", [name$p]: "fire-js-all" };/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const _apps = new Map, _components = new Map; function _addComponent(e, s) { try { e.container.addComponent(s) } catch (o) { logger.debug(`Component ${s.name} failed to register with FirebaseApp ${e.name}`, o) } } function _registerComponent(e) { const s = e.name; if (_components.has(s)) return logger.debug(`There were multiple attempts to register component ${s}.`), !1; _components.set(s, e); for (const o of _apps.values()) _addComponent(o, e); return !0 } function _getProvider(e, s) { const o = e.container.getProvider("heartbeat").getImmediate({ optional: !0 }); return o && o.triggerHeartbeat(), e.container.getProvider(s) }/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const ERRORS = { ["no-app"]: "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()", ["bad-app-name"]: "Illegal App name: '{$appName}", ["duplicate-app"]: "Firebase App named '{$appName}' already exists with different options or config", ["app-deleted"]: "Firebase App named '{$appName}' already deleted", ["no-options"]: "Need to provide options, when not being deployed to hosting via source.", ["invalid-app-argument"]: "firebase.{$appName}() takes either no argument or a Firebase App instance.", ["invalid-log-argument"]: "First argument to `onLog` must be null or a function.", ["idb-open"]: "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.", ["idb-get"]: "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.", ["idb-set"]: "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.", ["idb-delete"]: "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}." }, ERROR_FACTORY = new ErrorFactory("app", "Firebase", ERRORS);/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class FirebaseAppImpl { constructor(s, o, c) { this._isDeleted = !1, this._options = Object.assign({}, s), this._config = Object.assign({}, o), this._name = o.name, this._automaticDataCollectionEnabled = o.automaticDataCollectionEnabled, this._container = c, this.container.addComponent(new Component("app", () => this, "PUBLIC")) } get automaticDataCollectionEnabled() { return this.checkDestroyed(), this._automaticDataCollectionEnabled } set automaticDataCollectionEnabled(s) { this.checkDestroyed(), this._automaticDataCollectionEnabled = s } get name() { return this.checkDestroyed(), this._name } get options() { return this.checkDestroyed(), this._options } get config() { return this.checkDestroyed(), this._config } get container() { return this._container } get isDeleted() { return this._isDeleted } set isDeleted(s) { this._isDeleted = s } checkDestroyed() { if (this.isDeleted) throw ERROR_FACTORY.create("app-deleted", { appName: this._name }) } }/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const SDK_VERSION = version$2; function initializeApp(e, s = {}) { let o = e; typeof s != "object" && (s = { name: s }); const c = Object.assign({ name: DEFAULT_ENTRY_NAME, automaticDataCollectionEnabled: !1 }, s), et = c.name; if (typeof et != "string" || !et) throw ERROR_FACTORY.create("bad-app-name", { appName: String(et) }); if (o || (o = getDefaultAppConfig()), !o) throw ERROR_FACTORY.create("no-options"); const at = _apps.get(et); if (at) { if (deepEqual(o, at.options) && deepEqual(c, at.config)) return at; throw ERROR_FACTORY.create("duplicate-app", { appName: et }) } const lt = new ComponentContainer(et); for (const dt of _components.values()) lt.addComponent(dt); const ft = new FirebaseAppImpl(o, c, lt); return _apps.set(et, ft), ft } function getApp(e = DEFAULT_ENTRY_NAME) { const s = _apps.get(e); if (!s && e === DEFAULT_ENTRY_NAME) return initializeApp(); if (!s) throw ERROR_FACTORY.create("no-app", { appName: e }); return s } function registerVersion(e, s, o) { var c; let et = (c = PLATFORM_LOG_STRING[e]) !== null && c !== void 0 ? c : e; o && (et += `-${o}`); const at = et.match(/\s|\//), lt = s.match(/\s|\//); if (at || lt) { const ft = [`Unable to register library "${et}" with version "${s}":`]; at && ft.push(`library name "${et}" contains illegal characters (whitespace or "/")`), at && lt && ft.push("and"), lt && ft.push(`version name "${s}" contains illegal characters (whitespace or "/")`), logger.warn(ft.join(" ")); return } _registerComponent(new Component(`${et}-version`, () => ({ library: et, version: s }), "VERSION")) }/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const DB_NAME = "firebase-heartbeat-database", DB_VERSION = 1, STORE_NAME = "firebase-heartbeat-store"; let dbPromise = null; function getDbPromise() { return dbPromise || (dbPromise = openDB(DB_NAME, DB_VERSION, { upgrade: (e, s) => { switch (s) { case 0: e.createObjectStore(STORE_NAME) } } }).catch(e => { throw ERROR_FACTORY.create("idb-open", { originalErrorMessage: e.message }) })), dbPromise } async function readHeartbeatsFromIndexedDB(e) { var s; try { return (await getDbPromise()).transaction(STORE_NAME).objectStore(STORE_NAME).get(computeKey(e)) } catch (o) { if (o instanceof FirebaseError) logger.warn(o.message); else { const c = ERROR_FACTORY.create("idb-get", { originalErrorMessage: (s = o) === null || s === void 0 ? void 0 : s.message }); logger.warn(c.message) } } } async function writeHeartbeatsToIndexedDB(e, s) { var o; try { const et = (await getDbPromise()).transaction(STORE_NAME, "readwrite"); return await et.objectStore(STORE_NAME).put(s, computeKey(e)), et.done } catch (c) { if (c instanceof FirebaseError) logger.warn(c.message); else { const et = ERROR_FACTORY.create("idb-set", { originalErrorMessage: (o = c) === null || o === void 0 ? void 0 : o.message }); logger.warn(et.message) } } } function computeKey(e) { return `${e.name}!${e.options.appId}` }/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const MAX_HEADER_BYTES = 1024, STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1e3; class HeartbeatServiceImpl { constructor(s) { this.container = s, this._heartbeatsCache = null; const o = this.container.getProvider("app").getImmediate(); this._storage = new HeartbeatStorageImpl(o), this._heartbeatsCachePromise = this._storage.read().then(c => (this._heartbeatsCache = c, c)) } async triggerHeartbeat() { const o = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(), c = getUTCDateString(); if (this._heartbeatsCache === null && (this._heartbeatsCache = await this._heartbeatsCachePromise), !(this._heartbeatsCache.lastSentHeartbeatDate === c || this._heartbeatsCache.heartbeats.some(et => et.date === c))) return this._heartbeatsCache.heartbeats.push({ date: c, agent: o }), this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter(et => { const at = new Date(et.date).valueOf(); return Date.now() - at <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS }), this._storage.overwrite(this._heartbeatsCache) } async getHeartbeatsHeader() { if (this._heartbeatsCache === null && await this._heartbeatsCachePromise, this._heartbeatsCache === null || this._heartbeatsCache.heartbeats.length === 0) return ""; const s = getUTCDateString(), { heartbeatsToSend: o, unsentEntries: c } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats), et = base64urlEncodeWithoutPadding(JSON.stringify({ version: 2, heartbeats: o })); return this._heartbeatsCache.lastSentHeartbeatDate = s, c.length > 0 ? (this._heartbeatsCache.heartbeats = c, await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [], this._storage.overwrite(this._heartbeatsCache)), et } } function getUTCDateString() { return new Date().toISOString().substring(0, 10) } function extractHeartbeatsForHeader(e, s = MAX_HEADER_BYTES) { const o = []; let c = e.slice(); for (const et of e) { const at = o.find(lt => lt.agent === et.agent); if (at) { if (at.dates.push(et.date), countBytes(o) > s) { at.dates.pop(); break } } else if (o.push({ agent: et.agent, dates: [et.date] }), countBytes(o) > s) { o.pop(); break } c = c.slice(1) } return { heartbeatsToSend: o, unsentEntries: c } } class HeartbeatStorageImpl { constructor(s) { this.app = s, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck() } async runIndexedDBEnvironmentCheck() { return isIndexedDBAvailable() ? validateIndexedDBOpenable().then(() => !0).catch(() => !1) : !1 } async read() { return await this._canUseIndexedDBPromise ? await readHeartbeatsFromIndexedDB(this.app) || { heartbeats: [] } : { heartbeats: [] } } async overwrite(s) { var o; if (await this._canUseIndexedDBPromise) { const et = await this.read(); return writeHeartbeatsToIndexedDB(this.app, { lastSentHeartbeatDate: (o = s.lastSentHeartbeatDate) !== null && o !== void 0 ? o : et.lastSentHeartbeatDate, heartbeats: s.heartbeats }) } else return } async add(s) { var o; if (await this._canUseIndexedDBPromise) { const et = await this.read(); return writeHeartbeatsToIndexedDB(this.app, { lastSentHeartbeatDate: (o = s.lastSentHeartbeatDate) !== null && o !== void 0 ? o : et.lastSentHeartbeatDate, heartbeats: [...et.heartbeats, ...s.heartbeats] }) } else return } } function countBytes(e) { return base64urlEncodeWithoutPadding(JSON.stringify({ version: 2, heartbeats: e })).length }/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function registerCoreComponents(e) { _registerComponent(new Component("platform-logger", s => new PlatformLoggerServiceImpl(s), "PRIVATE")), _registerComponent(new Component("heartbeat", s => new HeartbeatServiceImpl(s), "PRIVATE")), registerVersion(name$o, version$1, e), registerVersion(name$o, version$1, "esm2017"), registerVersion("fire-js", "") } registerCoreComponents(""); var name = "firebase", version = "9.13.0";/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */registerVersion(name, version, "app"); var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, k$1, goog = goog || {}, l = commonjsGlobal || self; function aa() { } function ba(e) { var s = typeof e; return s = s != "object" ? s : e ? Array.isArray(e) ? "array" : s : "null", s == "array" || s == "object" && typeof e.length == "number" } function p(e) { var s = typeof e; return s == "object" && e != null || s == "function" } function ca(e) { return Object.prototype.hasOwnProperty.call(e, da) && e[da] || (e[da] = ++ea$1) } var da = "closure_uid_" + (1e9 * Math.random() >>> 0), ea$1 = 0; function fa(e, s, o) { return e.call.apply(e.bind, arguments) } function ha(e, s, o) { if (!e) throw Error(); if (2 < arguments.length) { var c = Array.prototype.slice.call(arguments, 2); return function () { var et = Array.prototype.slice.call(arguments); return Array.prototype.unshift.apply(et, c), e.apply(s, et) } } return function () { return e.apply(s, arguments) } } function q$1(e, s, o) { return Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? q$1 = fa : q$1 = ha, q$1.apply(null, arguments) } function ia(e, s) { var o = Array.prototype.slice.call(arguments, 1); return function () { var c = o.slice(); return c.push.apply(c, arguments), e.apply(this, c) } } function t(e, s) { function o() { } o.prototype = s.prototype, e.X = s.prototype, e.prototype = new o, e.prototype.constructor = e, e.Wb = function (c, et, at) { for (var lt = Array(arguments.length - 2), ft = 2; ft < arguments.length; ft++)lt[ft - 2] = arguments[ft]; return s.prototype[et].apply(c, lt) } } function v$1() { this.s = this.s, this.o = this.o } var ja = 0; v$1.prototype.s = !1; v$1.prototype.na = function () { !this.s && (this.s = !0, this.M(), ja != 0) && ca(this) }; v$1.prototype.M = function () { if (this.o) for (; this.o.length;)this.o.shift()() }; const la = Array.prototype.indexOf ? function (e, s) { return Array.prototype.indexOf.call(e, s, void 0) } : function (e, s) { if (typeof e == "string") return typeof s != "string" || s.length != 1 ? -1 : e.indexOf(s, 0); for (let o = 0; o < e.length; o++)if (o in e && e[o] === s) return o; return -1 }; function ma$1(e) { const s = e.length; if (0 < s) { const o = Array(s); for (let c = 0; c < s; c++)o[c] = e[c]; return o } return [] } function na(e, s) { for (let o = 1; o < arguments.length; o++) { const c = arguments[o]; if (ba(c)) { const et = e.length || 0, at = c.length || 0; e.length = et + at; for (let lt = 0; lt < at; lt++)e[et + lt] = c[lt] } else e.push(c) } } function w(e, s) { this.type = e, this.g = this.target = s, this.defaultPrevented = !1 } w.prototype.h = function () { this.defaultPrevented = !0 }; var oa = function () { if (!l.addEventListener || !Object.defineProperty) return !1; var e = !1, s = Object.defineProperty({}, "passive", { get: function () { e = !0 } }); try { l.addEventListener("test", aa, s), l.removeEventListener("test", aa, s) } catch { } return e }(); function pa(e) { return /^[\s\xa0]*$/.test(e) } var qa$1 = String.prototype.trim ? function (e) { return e.trim() } : function (e) { return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(e)[1] }; function ra(e, s) { return e < s ? -1 : e > s ? 1 : 0 } function sa$1() { var e = l.navigator; return e && (e = e.userAgent) ? e : "" } function x$1(e) { return sa$1().indexOf(e) != -1 } function ta$1(e) { return ta$1[" "](e), e } ta$1[" "] = aa; function ua(e) { var s = va; return Object.prototype.hasOwnProperty.call(s, 9) ? s[9] : s[9] = e(9) } var wa$1 = x$1("Opera"), y = x$1("Trident") || x$1("MSIE"), xa = x$1("Edge"), ya$1 = xa || y, za = x$1("Gecko") && !(sa$1().toLowerCase().indexOf("webkit") != -1 && !x$1("Edge")) && !(x$1("Trident") || x$1("MSIE")) && !x$1("Edge"), Aa = sa$1().toLowerCase().indexOf("webkit") != -1 && !x$1("Edge"); function Ba() { var e = l.document; return e ? e.documentMode : void 0 } var Ea$1; e: { var Fa = "", Ga = function () { var e = sa$1(); if (za) return /rv:([^\);]+)(\)|;)/.exec(e); if (xa) return /Edge\/([\d\.]+)/.exec(e); if (y) return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(e); if (Aa) return /WebKit\/(\S+)/.exec(e); if (wa$1) return /(?:Version)[ \/]?(\S+)/.exec(e) }(); if (Ga && (Fa = Ga ? Ga[1] : ""), y) { var Ha = Ba(); if (Ha != null && Ha > parseFloat(Fa)) { Ea$1 = String(Ha); break e } } Ea$1 = Fa } var va = {}; function Ia() { return ua(function () { let e = 0; const s = qa$1(String(Ea$1)).split("."), o = qa$1("9").split("."), c = Math.max(s.length, o.length); for (let lt = 0; e == 0 && lt < c; lt++) { var et = s[lt] || "", at = o[lt] || ""; do { if (et = /(\d*)(\D*)(.*)/.exec(et) || ["", "", "", ""], at = /(\d*)(\D*)(.*)/.exec(at) || ["", "", "", ""], et[0].length == 0 && at[0].length == 0) break; e = ra(et[1].length == 0 ? 0 : parseInt(et[1], 10), at[1].length == 0 ? 0 : parseInt(at[1], 10)) || ra(et[2].length == 0, at[2].length == 0) || ra(et[2], at[2]), et = et[3], at = at[3] } while (e == 0) } return 0 <= e }) } var Ja; if (l.document && y) { var Ka = Ba(); Ja = Ka || parseInt(Ea$1, 10) || void 0 } else Ja = void 0; var La$1 = Ja; function z$1(e, s) { if (w.call(this, e ? e.type : ""), this.relatedTarget = this.g = this.target = null, this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0, this.key = "", this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1, this.state = null, this.pointerId = 0, this.pointerType = "", this.i = null, e) { var o = this.type = e.type, c = e.changedTouches && e.changedTouches.length ? e.changedTouches[0] : null; if (this.target = e.target || e.srcElement, this.g = s, s = e.relatedTarget) { if (za) { e: { try { ta$1(s.nodeName); var et = !0; break e } catch { } et = !1 } et || (s = null) } } else o == "mouseover" ? s = e.fromElement : o == "mouseout" && (s = e.toElement); this.relatedTarget = s, c ? (this.clientX = c.clientX !== void 0 ? c.clientX : c.pageX, this.clientY = c.clientY !== void 0 ? c.clientY : c.pageY, this.screenX = c.screenX || 0, this.screenY = c.screenY || 0) : (this.clientX = e.clientX !== void 0 ? e.clientX : e.pageX, this.clientY = e.clientY !== void 0 ? e.clientY : e.pageY, this.screenX = e.screenX || 0, this.screenY = e.screenY || 0), this.button = e.button, this.key = e.key || "", this.ctrlKey = e.ctrlKey, this.altKey = e.altKey, this.shiftKey = e.shiftKey, this.metaKey = e.metaKey, this.pointerId = e.pointerId || 0, this.pointerType = typeof e.pointerType == "string" ? e.pointerType : Ma[e.pointerType] || "", this.state = e.state, this.i = e, e.defaultPrevented && z$1.X.h.call(this) } } t(z$1, w); var Ma = { 2: "touch", 3: "pen", 4: "mouse" }; z$1.prototype.h = function () { z$1.X.h.call(this); var e = this.i; e.preventDefault ? e.preventDefault() : e.returnValue = !1 }; var A = "closure_listenable_" + (1e6 * Math.random() | 0), Na = 0; function Oa(e, s, o, c, et) { this.listener = e, this.proxy = null, this.src = s, this.type = o, this.capture = !!c, this.ha = et, this.key = ++Na, this.ba = this.ea = !1 } function Pa(e) { e.ba = !0, e.listener = null, e.proxy = null, e.src = null, e.ha = null } function Qa(e, s, o) { for (const c in e) s.call(o, e[c], c, e) } function Ra(e) { const s = {}; for (const o in e) s[o] = e[o]; return s } const Sa = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "); function Ta(e, s) { let o, c; for (let et = 1; et < arguments.length; et++) { c = arguments[et]; for (o in c) e[o] = c[o]; for (let at = 0; at < Sa.length; at++)o = Sa[at], Object.prototype.hasOwnProperty.call(c, o) && (e[o] = c[o]) } } function Ua$1(e) { this.src = e, this.g = {}, this.h = 0 } Ua$1.prototype.add = function (e, s, o, c, et) { var at = e.toString(); e = this.g[at], e || (e = this.g[at] = [], this.h++); var lt = Va(e, s, c, et); return -1 < lt ? (s = e[lt], o || (s.ea = !1)) : (s = new Oa(s, this.src, at, !!c, et), s.ea = o, e.push(s)), s }; function Wa(e, s) { var o = s.type; if (o in e.g) { var c = e.g[o], et = la(c, s), at; (at = 0 <= et) && Array.prototype.splice.call(c, et, 1), at && (Pa(s), e.g[o].length == 0 && (delete e.g[o], e.h--)) } } function Va(e, s, o, c) { for (var et = 0; et < e.length; ++et) { var at = e[et]; if (!at.ba && at.listener == s && at.capture == !!o && at.ha == c) return et } return -1 } var Xa = "closure_lm_" + (1e6 * Math.random() | 0), Ya = {}; function $a$1(e, s, o, c, et) { if (c && c.once) return ab(e, s, o, c, et); if (Array.isArray(s)) { for (var at = 0; at < s.length; at++)$a$1(e, s[at], o, c, et); return null } return o = bb(o), e && e[A] ? e.N(s, o, p(c) ? !!c.capture : !!c, et) : cb(e, s, o, !1, c, et) } function cb(e, s, o, c, et, at) { if (!s) throw Error("Invalid event type"); var lt = p(et) ? !!et.capture : !!et, ft = db$1(e); if (ft || (e[Xa] = ft = new Ua$1(e)), o = ft.add(s, o, c, lt, at), o.proxy) return o; if (c = eb(), o.proxy = c, c.src = e, c.listener = o, e.addEventListener) oa || (et = lt), et === void 0 && (et = !1), e.addEventListener(s.toString(), c, et); else if (e.attachEvent) e.attachEvent(fb(s.toString()), c); else if (e.addListener && e.removeListener) e.addListener(c); else throw Error("addEventListener and attachEvent are unavailable."); return o } function eb() { function e(o) { return s.call(e.src, e.listener, o) } const s = gb; return e } function ab(e, s, o, c, et) { if (Array.isArray(s)) { for (var at = 0; at < s.length; at++)ab(e, s[at], o, c, et); return null } return o = bb(o), e && e[A] ? e.O(s, o, p(c) ? !!c.capture : !!c, et) : cb(e, s, o, !0, c, et) } function hb(e, s, o, c, et) { if (Array.isArray(s)) for (var at = 0; at < s.length; at++)hb(e, s[at], o, c, et); else c = p(c) ? !!c.capture : !!c, o = bb(o), e && e[A] ? (e = e.i, s = String(s).toString(), s in e.g && (at = e.g[s], o = Va(at, o, c, et), -1 < o && (Pa(at[o]), Array.prototype.splice.call(at, o, 1), at.length == 0 && (delete e.g[s], e.h--)))) : e && (e = db$1(e)) && (s = e.g[s.toString()], e = -1, s && (e = Va(s, o, c, et)), (o = -1 < e ? s[e] : null) && ib(o)) } function ib(e) { if (typeof e != "number" && e && !e.ba) { var s = e.src; if (s && s[A]) Wa(s.i, e); else { var o = e.type, c = e.proxy; s.removeEventListener ? s.removeEventListener(o, c, e.capture) : s.detachEvent ? s.detachEvent(fb(o), c) : s.addListener && s.removeListener && s.removeListener(c), (o = db$1(s)) ? (Wa(o, e), o.h == 0 && (o.src = null, s[Xa] = null)) : Pa(e) } } } function fb(e) { return e in Ya ? Ya[e] : Ya[e] = "on" + e } function gb(e, s) { if (e.ba) e = !0; else { s = new z$1(s, this); var o = e.listener, c = e.ha || e.src; e.ea && ib(e), e = o.call(c, s) } return e } function db$1(e) { return e = e[Xa], e instanceof Ua$1 ? e : null } var jb = "__closure_events_fn_" + (1e9 * Math.random() >>> 0); function bb(e) { return typeof e == "function" ? e : (e[jb] || (e[jb] = function (s) { return e.handleEvent(s) }), e[jb]) } function B$1() { v$1.call(this), this.i = new Ua$1(this), this.P = this, this.I = null } t(B$1, v$1); B$1.prototype[A] = !0; B$1.prototype.removeEventListener = function (e, s, o, c) { hb(this, e, s, o, c) }; function C$1(e, s) { var o, c = e.I; if (c) for (o = []; c; c = c.I)o.push(c); if (e = e.P, c = s.type || s, typeof s == "string") s = new w(s, e); else if (s instanceof w) s.target = s.target || e; else { var et = s; s = new w(c, e), Ta(s, et) } if (et = !0, o) for (var at = o.length - 1; 0 <= at; at--) { var lt = s.g = o[at]; et = kb(lt, c, !0, s) && et } if (lt = s.g = e, et = kb(lt, c, !0, s) && et, et = kb(lt, c, !1, s) && et, o) for (at = 0; at < o.length; at++)lt = s.g = o[at], et = kb(lt, c, !1, s) && et } B$1.prototype.M = function () { if (B$1.X.M.call(this), this.i) { var e = this.i, s; for (s in e.g) { for (var o = e.g[s], c = 0; c < o.length; c++)Pa(o[c]); delete e.g[s], e.h-- } } this.I = null }; B$1.prototype.N = function (e, s, o, c) { return this.i.add(String(e), s, !1, o, c) }; B$1.prototype.O = function (e, s, o, c) { return this.i.add(String(e), s, !0, o, c) }; function kb(e, s, o, c) { if (s = e.i.g[String(s)], !s) return !0; s = s.concat(); for (var et = !0, at = 0; at < s.length; ++at) { var lt = s[at]; if (lt && !lt.ba && lt.capture == o) { var ft = lt.listener, dt = lt.ha || lt.src; lt.ea && Wa(e.i, lt), et = ft.call(dt, c) !== !1 && et } } return et && !c.defaultPrevented } var lb = l.JSON.stringify; function mb() { var e = nb; let s = null; return e.g && (s = e.g, e.g = e.g.next, e.g || (e.h = null), s.next = null), s } class ob { constructor() { this.h = this.g = null } add(s, o) { const c = pb.get(); c.set(s, o), this.h ? this.h.next = c : this.g = c, this.h = c } } var pb = new class { constructor(e, s) { this.i = e, this.j = s, this.h = 0, this.g = null } get() { let e; return 0 < this.h ? (this.h--, e = this.g, this.g = e.next, e.next = null) : e = this.i(), e } }(() => new qb, e => e.reset()); class qb { constructor() { this.next = this.g = this.h = null } set(s, o) { this.h = s, this.g = o, this.next = null } reset() { this.next = this.g = this.h = null } } function rb(e) { l.setTimeout(() => { throw e }, 0) } function sb(e, s) { ub || vb(), wb || (ub(), wb = !0), nb.add(e, s) } var ub; function vb() { var e = l.Promise.resolve(void 0); ub = function () { e.then(xb) } } var wb = !1, nb = new ob; function xb() { for (var e; e = mb();) { try { e.h.call(e.g) } catch (o) { rb(o) } var s = pb; s.j(e), 100 > s.h && (s.h++, e.next = s.g, s.g = e) } wb = !1 } function yb(e, s) { B$1.call(this), this.h = e || 1, this.g = s || l, this.j = q$1(this.lb, this), this.l = Date.now() } t(yb, B$1); k$1 = yb.prototype; k$1.ca = !1; k$1.R = null; k$1.lb = function () { if (this.ca) { var e = Date.now() - this.l; 0 < e && e < .8 * this.h ? this.R = this.g.setTimeout(this.j, this.h - e) : (this.R && (this.g.clearTimeout(this.R), this.R = null), C$1(this, "tick"), this.ca && (zb(this), this.start())) } }; k$1.start = function () { this.ca = !0, this.R || (this.R = this.g.setTimeout(this.j, this.h), this.l = Date.now()) }; function zb(e) { e.ca = !1, e.R && (e.g.clearTimeout(e.R), e.R = null) } k$1.M = function () { yb.X.M.call(this), zb(this), delete this.g }; function Ab(e, s, o) { if (typeof e == "function") o && (e = q$1(e, o)); else if (e && typeof e.handleEvent == "function") e = q$1(e.handleEvent, e); else throw Error("Invalid listener argument"); return 2147483647 < Number(s) ? -1 : l.setTimeout(e, s || 0) } function Bb(e) { e.g = Ab(() => { e.g = null, e.i && (e.i = !1, Bb(e)) }, e.j); const s = e.h; e.h = null, e.m.apply(null, s) } class Cb extends v$1 { constructor(s, o) { super(), this.m = s, this.j = o, this.h = null, this.i = !1, this.g = null } l(s) { this.h = arguments, this.g ? this.i = !0 : Bb(this) } M() { super.M(), this.g && (l.clearTimeout(this.g), this.g = null, this.i = !1, this.h = null) } } function D(e) { v$1.call(this), this.h = e, this.g = {} } t(D, v$1); var Db = []; function Eb(e, s, o, c) { Array.isArray(o) || (o && (Db[0] = o.toString()), o = Db); for (var et = 0; et < o.length; et++) { var at = $a$1(s, o[et], c || e.handleEvent, !1, e.h || e); if (!at) break; e.g[at.key] = at } } function Fb(e) { Qa(e.g, function (s, o) { this.g.hasOwnProperty(o) && ib(s) }, e), e.g = {} } D.prototype.M = function () { D.X.M.call(this), Fb(this) }; D.prototype.handleEvent = function () { throw Error("EventHandler.handleEvent not implemented") }; function Gb() { this.g = !0 } Gb.prototype.Aa = function () { this.g = !1 }; function Hb(e, s, o, c, et, at) {
	e.info(function () {
		if (e.g) if (at) for (var lt = "", ft = at.split("&"), dt = 0; dt < ft.length; dt++) { var ht = ft[dt].split("="); if (1 < ht.length) { var vt = ht[0]; ht = ht[1]; var wt = vt.split("_"); lt = 2 <= wt.length && wt[1] == "type" ? lt + (vt + "=" + ht + "&") : lt + (vt + "=redacted&") } } else lt = null; else lt = at; return "XMLHTTP REQ (" + c + ") [attempt " + et + "]: " + s + `
`+ o + `
`+ lt
	})
} function Ib(e, s, o, c, et, at, lt) {
	e.info(function () {
		return "XMLHTTP RESP (" + c + ") [ attempt " + et + "]: " + s + `
`+ o + `
`+ at + " " + lt
	})
} function E(e, s, o, c) { e.info(function () { return "XMLHTTP TEXT (" + s + "): " + Jb(e, o) + (c ? " " + c : "") }) } function Kb(e, s) { e.info(function () { return "TIMEOUT: " + s }) } Gb.prototype.info = function () { }; function Jb(e, s) { if (!e.g) return s; if (!s) return null; try { var o = JSON.parse(s); if (o) { for (e = 0; e < o.length; e++)if (Array.isArray(o[e])) { var c = o[e]; if (!(2 > c.length)) { var et = c[1]; if (Array.isArray(et) && !(1 > et.length)) { var at = et[0]; if (at != "noop" && at != "stop" && at != "close") for (var lt = 1; lt < et.length; lt++)et[lt] = "" } } } } return lb(o) } catch { return s } } var G$1 = {}, Lb = null; function Mb() { return Lb = Lb || new B$1 } G$1.Pa = "serverreachability"; function Nb(e) { w.call(this, G$1.Pa, e) } t(Nb, w); function H$1(e) { const s = Mb(); C$1(s, new Nb(s)) } G$1.STAT_EVENT = "statevent"; function Ob(e, s) { w.call(this, G$1.STAT_EVENT, e), this.stat = s } t(Ob, w); function I(e) { const s = Mb(); C$1(s, new Ob(s, e)) } G$1.Qa = "timingevent"; function Pb(e, s) { w.call(this, G$1.Qa, e), this.size = s } t(Pb, w); function J(e, s) { if (typeof e != "function") throw Error("Fn must not be null and must be a function"); return l.setTimeout(function () { e() }, s) } var Qb = { NO_ERROR: 0, mb: 1, zb: 2, yb: 3, tb: 4, xb: 5, Ab: 6, Ma: 7, TIMEOUT: 8, Db: 9 }, Rb = { rb: "complete", Nb: "success", Na: "error", Ma: "abort", Fb: "ready", Gb: "readystatechange", TIMEOUT: "timeout", Bb: "incrementaldata", Eb: "progress", ub: "downloadprogress", Vb: "uploadprogress" }; function Sb() { } Sb.prototype.h = null; function Tb(e) { return e.h || (e.h = e.i()) } function Ub() { } var K$1 = { OPEN: "a", qb: "b", Na: "c", Cb: "d" }; function Vb() { w.call(this, "d") } t(Vb, w); function Wb() { w.call(this, "c") } t(Wb, w); var Xb; function Yb() { } t(Yb, Sb); Yb.prototype.g = function () { return new XMLHttpRequest }; Yb.prototype.i = function () { return {} }; Xb = new Yb; function L$1(e, s, o, c) { this.l = e, this.j = s, this.m = o, this.U = c || 1, this.S = new D(this), this.O = Zb, e = ya$1 ? 125 : void 0, this.T = new yb(e), this.H = null, this.i = !1, this.s = this.A = this.v = this.K = this.F = this.V = this.B = null, this.D = [], this.g = null, this.C = 0, this.o = this.u = null, this.Y = -1, this.I = !1, this.N = 0, this.L = null, this.$ = this.J = this.Z = this.P = !1, this.h = new $b } function $b() { this.i = null, this.g = "", this.h = !1 } var Zb = 45e3, ac = {}, bc = {}; k$1 = L$1.prototype; k$1.setTimeout = function (e) { this.O = e }; function cc$1(e, s, o) { e.K = 1, e.v = dc$1(M$1(s)), e.s = o, e.P = !0, ec(e, null) } function ec(e, s) { e.F = Date.now(), N$1(e), e.A = M$1(e.v); var o = e.A, c = e.U; Array.isArray(c) || (c = [String(c)]), fc$1(o.i, "t", c), e.C = 0, o = e.l.H, e.h = new $b, e.g = gc(e.l, o ? s : null, !e.s), 0 < e.N && (e.L = new Cb(q$1(e.La, e, e.g), e.N)), Eb(e.S, e.g, "readystatechange", e.ib), s = e.H ? Ra(e.H) : {}, e.s ? (e.u || (e.u = "POST"), s["Content-Type"] = "application/x-www-form-urlencoded", e.g.da(e.A, e.u, e.s, s)) : (e.u = "GET", e.g.da(e.A, e.u, null, s)), H$1(), Hb(e.j, e.u, e.A, e.m, e.U, e.s) } k$1.ib = function (e) { e = e.target; const s = this.L; s && O$1(e) == 3 ? s.l() : this.La(e) }; k$1.La = function (e) { try { if (e == this.g) e: { const vt = O$1(this.g); var s = this.g.Ea(); const wt = this.g.aa(); if (!(3 > vt) && (vt != 3 || ya$1 || this.g && (this.h.h || this.g.fa() || hc$1(this.g)))) { this.I || vt != 4 || s == 7 || (s == 8 || 0 >= wt ? H$1(3) : H$1(2)), ic$1(this); var o = this.g.aa(); this.Y = o; t: if (jc$1(this)) { var c = hc$1(this.g); e = ""; var et = c.length, at = O$1(this.g) == 4; if (!this.h.i) { if (typeof TextDecoder > "u") { P$1(this), Q$1(this); var lt = ""; break t } this.h.i = new l.TextDecoder } for (s = 0; s < et; s++)this.h.h = !0, e += this.h.i.decode(c[s], { stream: at && s == et - 1 }); c.splice(0, et), this.h.g += e, this.C = 0, lt = this.h.g } else lt = this.g.fa(); if (this.i = o == 200, Ib(this.j, this.u, this.A, this.m, this.U, vt, o), this.i) { if (this.Z && !this.J) { t: { if (this.g) { var ft, dt = this.g; if ((ft = dt.g ? dt.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !pa(ft)) { var ht = ft; break t } } ht = null } if (o = ht) E(this.j, this.m, o, "Initial handshake response via X-HTTP-Initial-Response"), this.J = !0, kc(this, o); else { this.i = !1, this.o = 3, I(12), P$1(this), Q$1(this); break e } } this.P ? (lc(this, vt, lt), ya$1 && this.i && vt == 3 && (Eb(this.S, this.T, "tick", this.hb), this.T.start())) : (E(this.j, this.m, lt, null), kc(this, lt)), vt == 4 && P$1(this), this.i && !this.I && (vt == 4 ? mc$1(this.l, this) : (this.i = !1, N$1(this))) } else o == 400 && 0 < lt.indexOf("Unknown SID") ? (this.o = 3, I(12)) : (this.o = 0, I(13)), P$1(this), Q$1(this) } } } catch { } finally { } }; function jc$1(e) { return e.g ? e.u == "GET" && e.K != 2 && e.l.Da : !1 } function lc(e, s, o) { let c = !0, et; for (; !e.I && e.C < o.length;)if (et = nc(e, o), et == bc) { s == 4 && (e.o = 4, I(14), c = !1), E(e.j, e.m, null, "[Incomplete Response]"); break } else if (et == ac) { e.o = 4, I(15), E(e.j, e.m, o, "[Invalid Chunk]"), c = !1; break } else E(e.j, e.m, et, null), kc(e, et); jc$1(e) && et != bc && et != ac && (e.h.g = "", e.C = 0), s != 4 || o.length != 0 || e.h.h || (e.o = 1, I(16), c = !1), e.i = e.i && c, c ? 0 < o.length && !e.$ && (e.$ = !0, s = e.l, s.g == e && s.$ && !s.K && (s.j.info("Great, no buffering proxy detected. Bytes received: " + o.length), oc(s), s.K = !0, I(11))) : (E(e.j, e.m, o, "[Invalid Chunked Response]"), P$1(e), Q$1(e)) } k$1.hb = function () { if (this.g) { var e = O$1(this.g), s = this.g.fa(); this.C < s.length && (ic$1(this), lc(this, e, s), this.i && e != 4 && N$1(this)) } }; function nc(e, s) {
	var o = e.C, c = s.indexOf(`
`, o); return c == -1 ? bc : (o = Number(s.substring(o, c)), isNaN(o) ? ac : (c += 1, c + o > s.length ? bc : (s = s.substr(c, o), e.C = c + o, s)))
} k$1.cancel = function () { this.I = !0, P$1(this) }; function N$1(e) { e.V = Date.now() + e.O, pc(e, e.O) } function pc(e, s) { if (e.B != null) throw Error("WatchDog timer not null"); e.B = J(q$1(e.gb, e), s) } function ic$1(e) { e.B && (l.clearTimeout(e.B), e.B = null) } k$1.gb = function () { this.B = null; const e = Date.now(); 0 <= e - this.V ? (Kb(this.j, this.A), this.K != 2 && (H$1(), I(17)), P$1(this), this.o = 2, Q$1(this)) : pc(this, this.V - e) }; function Q$1(e) { e.l.G == 0 || e.I || mc$1(e.l, e) } function P$1(e) { ic$1(e); var s = e.L; s && typeof s.na == "function" && s.na(), e.L = null, zb(e.T), Fb(e.S), e.g && (s = e.g, e.g = null, s.abort(), s.na()) } function kc(e, s) { try { var o = e.l; if (o.G != 0 && (o.g == e || qc$1(o.h, e))) { if (!e.J && qc$1(o.h, e) && o.G == 3) { try { var c = o.Fa.g.parse(s) } catch { c = null } if (Array.isArray(c) && c.length == 3) { var et = c; if (et[0] == 0) { e: if (!o.u) { if (o.g) if (o.g.F + 3e3 < e.F) rc(o), sc(o); else break e; tc(o), I(18) } } else o.Ba = et[1], 0 < o.Ba - o.T && 37500 > et[2] && o.L && o.A == 0 && !o.v && (o.v = J(q$1(o.cb, o), 6e3)); if (1 >= uc(o.h) && o.ja) { try { o.ja() } catch { } o.ja = void 0 } } else R(o, 11) } else if ((e.J || o.g == e) && rc(o), !pa(s)) for (et = o.Fa.g.parse(s), s = 0; s < et.length; s++) { let ht = et[s]; if (o.T = ht[0], ht = ht[1], o.G == 2) if (ht[0] == "c") { o.I = ht[1], o.ka = ht[2]; const vt = ht[3]; vt != null && (o.ma = vt, o.j.info("VER=" + o.ma)); const wt = ht[4]; wt != null && (o.Ca = wt, o.j.info("SVER=" + o.Ca)); const St = ht[5]; St != null && typeof St == "number" && 0 < St && (c = 1.5 * St, o.J = c, o.j.info("backChannelRequestTimeoutMs_=" + c)), c = o; const _t = e.g; if (_t) { const Nt = _t.g ? _t.g.getResponseHeader("X-Client-Wire-Protocol") : null; if (Nt) { var at = c.h; at.g || Nt.indexOf("spdy") == -1 && Nt.indexOf("quic") == -1 && Nt.indexOf("h2") == -1 || (at.j = at.l, at.g = new Set, at.h && (vc(at, at.h), at.h = null)) } if (c.D) { const kt = _t.g ? _t.g.getResponseHeader("X-HTTP-Session-Id") : null; kt && (c.za = kt, S$1(c.F, c.D, kt)) } } o.G = 3, o.l && o.l.xa(), o.$ && (o.P = Date.now() - e.F, o.j.info("Handshake RTT: " + o.P + "ms")), c = o; var lt = e; if (c.sa = wc$1(c, c.H ? c.ka : null, c.V), lt.J) { xc(c.h, lt); var ft = lt, dt = c.J; dt && ft.setTimeout(dt), ft.B && (ic$1(ft), N$1(ft)), c.g = lt } else yc(c); 0 < o.i.length && zc$1(o) } else ht[0] != "stop" && ht[0] != "close" || R(o, 7); else o.G == 3 && (ht[0] == "stop" || ht[0] == "close" ? ht[0] == "stop" ? R(o, 7) : Ac$1(o) : ht[0] != "noop" && o.l && o.l.wa(ht), o.A = 0) } } H$1(4) } catch { } } function Bc(e) { if (e.W && typeof e.W == "function") return e.W(); if (typeof Map < "u" && e instanceof Map || typeof Set < "u" && e instanceof Set) return Array.from(e.values()); if (typeof e == "string") return e.split(""); if (ba(e)) { for (var s = [], o = e.length, c = 0; c < o; c++)s.push(e[c]); return s } s = [], o = 0; for (c in e) s[o++] = e[c]; return s } function Cc(e) { if (e.oa && typeof e.oa == "function") return e.oa(); if (!e.W || typeof e.W != "function") { if (typeof Map < "u" && e instanceof Map) return Array.from(e.keys()); if (!(typeof Set < "u" && e instanceof Set)) { if (ba(e) || typeof e == "string") { var s = []; e = e.length; for (var o = 0; o < e; o++)s.push(o); return s } s = [], o = 0; for (const c in e) s[o++] = c; return s } } } function Dc(e, s) { if (e.forEach && typeof e.forEach == "function") e.forEach(s, void 0); else if (ba(e) || typeof e == "string") Array.prototype.forEach.call(e, s, void 0); else for (var o = Cc(e), c = Bc(e), et = c.length, at = 0; at < et; at++)s.call(void 0, c[at], o && o[at], e) } var Ec$1 = RegExp("^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$"); function Fc$1(e, s) { if (e) { e = e.split("&"); for (var o = 0; o < e.length; o++) { var c = e[o].indexOf("="), et = null; if (0 <= c) { var at = e[o].substring(0, c); et = e[o].substring(c + 1) } else at = e[o]; s(at, et ? decodeURIComponent(et.replace(/\+/g, " ")) : "") } } } function T(e, s) { if (this.g = this.s = this.j = "", this.m = null, this.o = this.l = "", this.h = !1, e instanceof T) { this.h = s !== void 0 ? s : e.h, Gc$1(this, e.j), this.s = e.s, this.g = e.g, Hc$1(this, e.m), this.l = e.l, s = e.i; var o = new Ic; o.i = s.i, s.g && (o.g = new Map(s.g), o.h = s.h), Jc$1(this, o), this.o = e.o } else e && (o = String(e).match(Ec$1)) ? (this.h = !!s, Gc$1(this, o[1] || "", !0), this.s = Kc$1(o[2] || ""), this.g = Kc$1(o[3] || "", !0), Hc$1(this, o[4]), this.l = Kc$1(o[5] || "", !0), Jc$1(this, o[6] || "", !0), this.o = Kc$1(o[7] || "")) : (this.h = !!s, this.i = new Ic(null, this.h)) } T.prototype.toString = function () { var e = [], s = this.j; s && e.push(Lc$1(s, Mc, !0), ":"); var o = this.g; return (o || s == "file") && (e.push("//"), (s = this.s) && e.push(Lc$1(s, Mc, !0), "@"), e.push(encodeURIComponent(String(o)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), o = this.m, o != null && e.push(":", String(o))), (o = this.l) && (this.g && o.charAt(0) != "/" && e.push("/"), e.push(Lc$1(o, o.charAt(0) == "/" ? Nc : Oc$1, !0))), (o = this.i.toString()) && e.push("?", o), (o = this.o) && e.push("#", Lc$1(o, Pc)), e.join("") }; function M$1(e) { return new T(e) } function Gc$1(e, s, o) { e.j = o ? Kc$1(s, !0) : s, e.j && (e.j = e.j.replace(/:$/, "")) } function Hc$1(e, s) { if (s) { if (s = Number(s), isNaN(s) || 0 > s) throw Error("Bad port number " + s); e.m = s } else e.m = null } function Jc$1(e, s, o) { s instanceof Ic ? (e.i = s, Qc$1(e.i, e.h)) : (o || (s = Lc$1(s, Rc)), e.i = new Ic(s, e.h)) } function S$1(e, s, o) { e.i.set(s, o) } function dc$1(e) { return S$1(e, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36)), e } function Kc$1(e, s) { return e ? s ? decodeURI(e.replace(/%25/g, "%2525")) : decodeURIComponent(e) : "" } function Lc$1(e, s, o) { return typeof e == "string" ? (e = encodeURI(e).replace(s, Sc), o && (e = e.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), e) : null } function Sc(e) { return e = e.charCodeAt(0), "%" + (e >> 4 & 15).toString(16) + (e & 15).toString(16) } var Mc = /[#\/\?@]/g, Oc$1 = /[#\?:]/g, Nc = /[#\?]/g, Rc = /[#\?@]/g, Pc = /#/g; function Ic(e, s) { this.h = this.g = null, this.i = e || null, this.j = !!s } function U$1(e) { e.g || (e.g = new Map, e.h = 0, e.i && Fc$1(e.i, function (s, o) { e.add(decodeURIComponent(s.replace(/\+/g, " ")), o) })) } k$1 = Ic.prototype; k$1.add = function (e, s) { U$1(this), this.i = null, e = V$1(this, e); var o = this.g.get(e); return o || this.g.set(e, o = []), o.push(s), this.h += 1, this }; function Tc(e, s) { U$1(e), s = V$1(e, s), e.g.has(s) && (e.i = null, e.h -= e.g.get(s).length, e.g.delete(s)) } function Uc$1(e, s) { return U$1(e), s = V$1(e, s), e.g.has(s) } k$1.forEach = function (e, s) { U$1(this), this.g.forEach(function (o, c) { o.forEach(function (et) { e.call(s, et, c, this) }, this) }, this) }; k$1.oa = function () { U$1(this); const e = Array.from(this.g.values()), s = Array.from(this.g.keys()), o = []; for (let c = 0; c < s.length; c++) { const et = e[c]; for (let at = 0; at < et.length; at++)o.push(s[c]) } return o }; k$1.W = function (e) { U$1(this); let s = []; if (typeof e == "string") Uc$1(this, e) && (s = s.concat(this.g.get(V$1(this, e)))); else { e = Array.from(this.g.values()); for (let o = 0; o < e.length; o++)s = s.concat(e[o]) } return s }; k$1.set = function (e, s) { return U$1(this), this.i = null, e = V$1(this, e), Uc$1(this, e) && (this.h -= this.g.get(e).length), this.g.set(e, [s]), this.h += 1, this }; k$1.get = function (e, s) { return e ? (e = this.W(e), 0 < e.length ? String(e[0]) : s) : s }; function fc$1(e, s, o) { Tc(e, s), 0 < o.length && (e.i = null, e.g.set(V$1(e, s), ma$1(o)), e.h += o.length) } k$1.toString = function () { if (this.i) return this.i; if (!this.g) return ""; const e = [], s = Array.from(this.g.keys()); for (var o = 0; o < s.length; o++) { var c = s[o]; const at = encodeURIComponent(String(c)), lt = this.W(c); for (c = 0; c < lt.length; c++) { var et = at; lt[c] !== "" && (et += "=" + encodeURIComponent(String(lt[c]))), e.push(et) } } return this.i = e.join("&") }; function V$1(e, s) { return s = String(s), e.j && (s = s.toLowerCase()), s } function Qc$1(e, s) { s && !e.j && (U$1(e), e.i = null, e.g.forEach(function (o, c) { var et = c.toLowerCase(); c != et && (Tc(this, c), fc$1(this, et, o)) }, e)), e.j = s } var Vc = class { constructor(e, s) { this.h = e, this.g = s } }; function Wc(e) { this.l = e || Xc$1, l.PerformanceNavigationTiming ? (e = l.performance.getEntriesByType("navigation"), e = 0 < e.length && (e[0].nextHopProtocol == "hq" || e[0].nextHopProtocol == "h2")) : e = !!(l.g && l.g.Ga && l.g.Ga() && l.g.Ga().$b), this.j = e ? this.l : 1, this.g = null, 1 < this.j && (this.g = new Set), this.h = null, this.i = [] } var Xc$1 = 10; function Yc$1(e) { return e.h ? !0 : e.g ? e.g.size >= e.j : !1 } function uc(e) { return e.h ? 1 : e.g ? e.g.size : 0 } function qc$1(e, s) { return e.h ? e.h == s : e.g ? e.g.has(s) : !1 } function vc(e, s) { e.g ? e.g.add(s) : e.h = s } function xc(e, s) { e.h && e.h == s ? e.h = null : e.g && e.g.has(s) && e.g.delete(s) } Wc.prototype.cancel = function () { if (this.i = Zc$1(this), this.h) this.h.cancel(), this.h = null; else if (this.g && this.g.size !== 0) { for (const e of this.g.values()) e.cancel(); this.g.clear() } }; function Zc$1(e) { if (e.h != null) return e.i.concat(e.h.D); if (e.g != null && e.g.size !== 0) { let s = e.i; for (const o of e.g.values()) s = s.concat(o.D); return s } return ma$1(e.i) } function $c() { } $c.prototype.stringify = function (e) { return l.JSON.stringify(e, void 0) }; $c.prototype.parse = function (e) { return l.JSON.parse(e, void 0) }; function ad() { this.g = new $c } function bd(e, s, o) { const c = o || ""; try { Dc(e, function (et, at) { let lt = et; p(et) && (lt = lb(et)), s.push(c + at + "=" + encodeURIComponent(lt)) }) } catch (et) { throw s.push(c + "type=" + encodeURIComponent("_badmap")), et } } function cd(e, s) { const o = new Gb; if (l.Image) { const c = new Image; c.onload = ia(dd, o, c, "TestLoadImage: loaded", !0, s), c.onerror = ia(dd, o, c, "TestLoadImage: error", !1, s), c.onabort = ia(dd, o, c, "TestLoadImage: abort", !1, s), c.ontimeout = ia(dd, o, c, "TestLoadImage: timeout", !1, s), l.setTimeout(function () { c.ontimeout && c.ontimeout() }, 1e4), c.src = e } else s(!1) } function dd(e, s, o, c, et) { try { s.onload = null, s.onerror = null, s.onabort = null, s.ontimeout = null, et(c) } catch { } } function ed(e) { this.l = e.ac || null, this.j = e.jb || !1 } t(ed, Sb); ed.prototype.g = function () { return new fd(this.l, this.j) }; ed.prototype.i = function (e) { return function () { return e } }({}); function fd(e, s) { B$1.call(this), this.D = e, this.u = s, this.m = void 0, this.readyState = gd, this.status = 0, this.responseType = this.responseText = this.response = this.statusText = "", this.onreadystatechange = null, this.v = new Headers, this.h = null, this.C = "GET", this.B = "", this.g = !1, this.A = this.j = this.l = null } t(fd, B$1); var gd = 0; k$1 = fd.prototype; k$1.open = function (e, s) { if (this.readyState != gd) throw this.abort(), Error("Error reopening a connection"); this.C = e, this.B = s, this.readyState = 1, hd(this) }; k$1.send = function (e) { if (this.readyState != 1) throw this.abort(), Error("need to call open() first. "); this.g = !0; const s = { headers: this.v, method: this.C, credentials: this.m, cache: void 0 }; e && (s.body = e), (this.D || l).fetch(new Request(this.B, s)).then(this.Wa.bind(this), this.ga.bind(this)) }; k$1.abort = function () { this.response = this.responseText = "", this.v = new Headers, this.status = 0, this.j && this.j.cancel("Request was aborted.").catch(() => { }), 1 <= this.readyState && this.g && this.readyState != 4 && (this.g = !1, id(this)), this.readyState = gd }; k$1.Wa = function (e) { if (this.g && (this.l = e, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = e.headers, this.readyState = 2, hd(this)), this.g && (this.readyState = 3, hd(this), this.g))) if (this.responseType === "arraybuffer") e.arrayBuffer().then(this.Ua.bind(this), this.ga.bind(this)); else if (typeof l.ReadableStream < "u" && "body" in e) { if (this.j = e.body.getReader(), this.u) { if (this.responseType) throw Error('responseType must be empty for "streamBinaryChunks" mode responses.'); this.response = [] } else this.response = this.responseText = "", this.A = new TextDecoder; jd(this) } else e.text().then(this.Va.bind(this), this.ga.bind(this)) }; function jd(e) { e.j.read().then(e.Ta.bind(e)).catch(e.ga.bind(e)) } k$1.Ta = function (e) { if (this.g) { if (this.u && e.value) this.response.push(e.value); else if (!this.u) { var s = e.value ? e.value : new Uint8Array(0); (s = this.A.decode(s, { stream: !e.done })) && (this.response = this.responseText += s) } e.done ? id(this) : hd(this), this.readyState == 3 && jd(this) } }; k$1.Va = function (e) { this.g && (this.response = this.responseText = e, id(this)) }; k$1.Ua = function (e) { this.g && (this.response = e, id(this)) }; k$1.ga = function () { this.g && id(this) }; function id(e) { e.readyState = 4, e.l = null, e.j = null, e.A = null, hd(e) } k$1.setRequestHeader = function (e, s) { this.v.append(e, s) }; k$1.getResponseHeader = function (e) { return this.h && this.h.get(e.toLowerCase()) || "" }; k$1.getAllResponseHeaders = function () {
	if (!this.h) return ""; const e = [], s = this.h.entries(); for (var o = s.next(); !o.done;)o = o.value, e.push(o[0] + ": " + o[1]), o = s.next(); return e.join(`\r
`)
}; function hd(e) { e.onreadystatechange && e.onreadystatechange.call(e) } Object.defineProperty(fd.prototype, "withCredentials", { get: function () { return this.m === "include" }, set: function (e) { this.m = e ? "include" : "same-origin" } }); var kd = l.JSON.parse; function W$1(e) { B$1.call(this), this.headers = new Map, this.u = e || null, this.h = !1, this.C = this.g = null, this.H = "", this.m = 0, this.j = "", this.l = this.F = this.v = this.D = !1, this.B = 0, this.A = null, this.J = ld, this.K = this.L = !1 } t(W$1, B$1); var ld = "", md = /^https?$/i, nd = ["POST", "PUT"]; k$1 = W$1.prototype; k$1.Ka = function (e) { this.L = e }; k$1.da = function (e, s, o, c) { if (this.g) throw Error("[goog.net.XhrIo] Object is active with another request=" + this.H + "; newUri=" + e); s = s ? s.toUpperCase() : "GET", this.H = e, this.j = "", this.m = 0, this.D = !1, this.h = !0, this.g = this.u ? this.u.g() : Xb.g(), this.C = this.u ? Tb(this.u) : Tb(Xb), this.g.onreadystatechange = q$1(this.Ha, this); try { this.F = !0, this.g.open(s, String(e), !0), this.F = !1 } catch (at) { od(this, at); return } if (e = o || "", o = new Map(this.headers), c) if (Object.getPrototypeOf(c) === Object.prototype) for (var et in c) o.set(et, c[et]); else if (typeof c.keys == "function" && typeof c.get == "function") for (const at of c.keys()) o.set(at, c.get(at)); else throw Error("Unknown input type for opt_headers: " + String(c)); c = Array.from(o.keys()).find(at => at.toLowerCase() == "content-type"), et = l.FormData && e instanceof l.FormData, !(0 <= la(nd, s)) || c || et || o.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8"); for (const [at, lt] of o) this.g.setRequestHeader(at, lt); this.J && (this.g.responseType = this.J), "withCredentials" in this.g && this.g.withCredentials !== this.L && (this.g.withCredentials = this.L); try { pd(this), 0 < this.B && ((this.K = qd(this.g)) ? (this.g.timeout = this.B, this.g.ontimeout = q$1(this.qa, this)) : this.A = Ab(this.qa, this.B, this)), this.v = !0, this.g.send(e), this.v = !1 } catch (at) { od(this, at) } }; function qd(e) { return y && Ia() && typeof e.timeout == "number" && e.ontimeout !== void 0 } k$1.qa = function () { typeof goog < "u" && this.g && (this.j = "Timed out after " + this.B + "ms, aborting", this.m = 8, C$1(this, "timeout"), this.abort(8)) }; function od(e, s) { e.h = !1, e.g && (e.l = !0, e.g.abort(), e.l = !1), e.j = s, e.m = 5, rd(e), sd(e) } function rd(e) { e.D || (e.D = !0, C$1(e, "complete"), C$1(e, "error")) } k$1.abort = function (e) { this.g && this.h && (this.h = !1, this.l = !0, this.g.abort(), this.l = !1, this.m = e || 7, C$1(this, "complete"), C$1(this, "abort"), sd(this)) }; k$1.M = function () { this.g && (this.h && (this.h = !1, this.l = !0, this.g.abort(), this.l = !1), sd(this, !0)), W$1.X.M.call(this) }; k$1.Ha = function () { this.s || (this.F || this.v || this.l ? td(this) : this.fb()) }; k$1.fb = function () { td(this) }; function td(e) { if (e.h && typeof goog < "u" && (!e.C[1] || O$1(e) != 4 || e.aa() != 2)) { if (e.v && O$1(e) == 4) Ab(e.Ha, 0, e); else if (C$1(e, "readystatechange"), O$1(e) == 4) { e.h = !1; try { const ft = e.aa(); e: switch (ft) { case 200: case 201: case 202: case 204: case 206: case 304: case 1223: var s = !0; break e; default: s = !1 }var o; if (!(o = s)) { var c; if (c = ft === 0) { var et = String(e.H).match(Ec$1)[1] || null; if (!et && l.self && l.self.location) { var at = l.self.location.protocol; et = at.substr(0, at.length - 1) } c = !md.test(et ? et.toLowerCase() : "") } o = c } if (o) C$1(e, "complete"), C$1(e, "success"); else { e.m = 6; try { var lt = 2 < O$1(e) ? e.g.statusText : "" } catch { lt = "" } e.j = lt + " [" + e.aa() + "]", rd(e) } } finally { sd(e) } } } } function sd(e, s) { if (e.g) { pd(e); const o = e.g, c = e.C[0] ? aa : null; e.g = null, e.C = null, s || C$1(e, "ready"); try { o.onreadystatechange = c } catch { } } } function pd(e) { e.g && e.K && (e.g.ontimeout = null), e.A && (l.clearTimeout(e.A), e.A = null) } function O$1(e) { return e.g ? e.g.readyState : 0 } k$1.aa = function () { try { return 2 < O$1(this) ? this.g.status : -1 } catch { return -1 } }; k$1.fa = function () { try { return this.g ? this.g.responseText : "" } catch { return "" } }; k$1.Sa = function (e) { if (this.g) { var s = this.g.responseText; return e && s.indexOf(e) == 0 && (s = s.substring(e.length)), kd(s) } }; function hc$1(e) { try { if (!e.g) return null; if ("response" in e.g) return e.g.response; switch (e.J) { case ld: case "text": return e.g.responseText; case "arraybuffer": if ("mozResponseArrayBuffer" in e.g) return e.g.mozResponseArrayBuffer }return null } catch { return null } } k$1.Ea = function () { return this.m }; k$1.Oa = function () { return typeof this.j == "string" ? this.j : String(this.j) }; function ud(e) {
	let s = ""; return Qa(e, function (o, c) {
		s += c, s += ":", s += o, s += `\r
`}), s
} function vd(e, s, o) { e: { for (c in o) { var c = !1; break e } c = !0 } c || (o = ud(o), typeof e == "string" ? o != null && encodeURIComponent(String(o)) : S$1(e, s, o)) } function wd(e, s, o) { return o && o.internalChannelParams && o.internalChannelParams[e] || s } function xd(e) { this.Ca = 0, this.i = [], this.j = new Gb, this.ka = this.sa = this.F = this.V = this.g = this.za = this.D = this.ia = this.o = this.S = this.s = null, this.ab = this.U = 0, this.Za = wd("failFast", !1, e), this.L = this.v = this.u = this.m = this.l = null, this.Y = !0, this.pa = this.Ba = this.T = -1, this.Z = this.A = this.C = 0, this.Xa = wd("baseRetryDelayMs", 5e3, e), this.bb = wd("retryDelaySeedMs", 1e4, e), this.$a = wd("forwardChannelMaxRetries", 2, e), this.ta = wd("forwardChannelRequestTimeoutMs", 2e4, e), this.ra = e && e.xmlHttpFactory || void 0, this.Da = e && e.Zb || !1, this.J = void 0, this.H = e && e.supportsCrossDomainXhr || !1, this.I = "", this.h = new Wc(e && e.concurrentRequestLimit), this.Fa = new ad, this.O = e && e.fastHandshake || !1, this.N = e && e.encodeInitMessageHeaders || !1, this.O && this.N && (this.N = !1), this.Ya = e && e.Xb || !1, e && e.Aa && this.j.Aa(), e && e.forceLongPolling && (this.Y = !1), this.$ = !this.O && this.Y && e && e.detectBufferingProxy || !1, this.ja = void 0, this.P = 0, this.K = !1, this.la = this.B = null } k$1 = xd.prototype; k$1.ma = 8; k$1.G = 1; function Ac$1(e) { if (yd(e), e.G == 3) { var s = e.U++, o = M$1(e.F); S$1(o, "SID", e.I), S$1(o, "RID", s), S$1(o, "TYPE", "terminate"), zd(e, o), s = new L$1(e, e.j, s, void 0), s.K = 2, s.v = dc$1(M$1(o)), o = !1, l.navigator && l.navigator.sendBeacon && (o = l.navigator.sendBeacon(s.v.toString(), "")), !o && l.Image && (new Image().src = s.v, o = !0), o || (s.g = gc(s.l, null), s.g.da(s.v)), s.F = Date.now(), N$1(s) } Ad(e) } function sc(e) { e.g && (oc(e), e.g.cancel(), e.g = null) } function yd(e) { sc(e), e.u && (l.clearTimeout(e.u), e.u = null), rc(e), e.h.cancel(), e.m && (typeof e.m == "number" && l.clearTimeout(e.m), e.m = null) } function zc$1(e) { Yc$1(e.h) || e.m || (e.m = !0, sb(e.Ja, e), e.C = 0) } function Bd(e, s) { return uc(e.h) >= e.h.j - (e.m ? 1 : 0) ? !1 : e.m ? (e.i = s.D.concat(e.i), !0) : e.G == 1 || e.G == 2 || e.C >= (e.Za ? 0 : e.$a) ? !1 : (e.m = J(q$1(e.Ja, e, s), Cd(e, e.C)), e.C++, !0) } k$1.Ja = function (e) { if (this.m) if (this.m = null, this.G == 1) { if (!e) { this.U = Math.floor(1e5 * Math.random()), e = this.U++; const et = new L$1(this, this.j, e, void 0); let at = this.s; if (this.S && (at ? (at = Ra(at), Ta(at, this.S)) : at = this.S), this.o !== null || this.N || (et.H = at, at = null), this.O) e: { for (var s = 0, o = 0; o < this.i.length; o++) { t: { var c = this.i[o]; if ("__data__" in c.g && (c = c.g.__data__, typeof c == "string")) { c = c.length; break t } c = void 0 } if (c === void 0) break; if (s += c, 4096 < s) { s = o; break e } if (s === 4096 || o === this.i.length - 1) { s = o + 1; break e } } s = 1e3 } else s = 1e3; s = Dd(this, et, s), o = M$1(this.F), S$1(o, "RID", e), S$1(o, "CVER", 22), this.D && S$1(o, "X-HTTP-Session-Id", this.D), zd(this, o), at && (this.N ? s = "headers=" + encodeURIComponent(String(ud(at))) + "&" + s : this.o && vd(o, this.o, at)), vc(this.h, et), this.Ya && S$1(o, "TYPE", "init"), this.O ? (S$1(o, "$req", s), S$1(o, "SID", "null"), et.Z = !0, cc$1(et, o, null)) : cc$1(et, o, s), this.G = 2 } } else this.G == 3 && (e ? Ed(this, e) : this.i.length == 0 || Yc$1(this.h) || Ed(this)) }; function Ed(e, s) { var o; s ? o = s.m : o = e.U++; const c = M$1(e.F); S$1(c, "SID", e.I), S$1(c, "RID", o), S$1(c, "AID", e.T), zd(e, c), e.o && e.s && vd(c, e.o, e.s), o = new L$1(e, e.j, o, e.C + 1), e.o === null && (o.H = e.s), s && (e.i = s.D.concat(e.i)), s = Dd(e, o, 1e3), o.setTimeout(Math.round(.5 * e.ta) + Math.round(.5 * e.ta * Math.random())), vc(e.h, o), cc$1(o, c, s) } function zd(e, s) { e.ia && Qa(e.ia, function (o, c) { S$1(s, c, o) }), e.l && Dc({}, function (o, c) { S$1(s, c, o) }) } function Dd(e, s, o) { o = Math.min(e.i.length, o); var c = e.l ? q$1(e.l.Ra, e.l, e) : null; e: { var et = e.i; let at = -1; for (; ;) { const lt = ["count=" + o]; at == -1 ? 0 < o ? (at = et[0].h, lt.push("ofs=" + at)) : at = 0 : lt.push("ofs=" + at); let ft = !0; for (let dt = 0; dt < o; dt++) { let ht = et[dt].h; const vt = et[dt].g; if (ht -= at, 0 > ht) at = Math.max(0, et[dt].h - 100), ft = !1; else try { bd(vt, lt, "req" + ht + "_") } catch { c && c(vt) } } if (ft) { c = lt.join("&"); break e } } } return e = e.i.splice(0, o), s.D = e, c } function yc(e) { e.g || e.u || (e.Z = 1, sb(e.Ia, e), e.A = 0) } function tc(e) { return e.g || e.u || 3 <= e.A ? !1 : (e.Z++, e.u = J(q$1(e.Ia, e), Cd(e, e.A)), e.A++, !0) } k$1.Ia = function () { if (this.u = null, Fd(this), this.$ && !(this.K || this.g == null || 0 >= this.P)) { var e = 2 * this.P; this.j.info("BP detection timer enabled: " + e), this.B = J(q$1(this.eb, this), e) } }; k$1.eb = function () { this.B && (this.B = null, this.j.info("BP detection timeout reached."), this.j.info("Buffering proxy detected and switch to long-polling!"), this.L = !1, this.K = !0, I(10), sc(this), Fd(this)) }; function oc(e) { e.B != null && (l.clearTimeout(e.B), e.B = null) } function Fd(e) { e.g = new L$1(e, e.j, "rpc", e.Z), e.o === null && (e.g.H = e.s), e.g.N = 0; var s = M$1(e.sa); S$1(s, "RID", "rpc"), S$1(s, "SID", e.I), S$1(s, "CI", e.L ? "0" : "1"), S$1(s, "AID", e.T), S$1(s, "TYPE", "xmlhttp"), zd(e, s), e.o && e.s && vd(s, e.o, e.s), e.J && e.g.setTimeout(e.J); var o = e.g; e = e.ka, o.K = 1, o.v = dc$1(M$1(s)), o.s = null, o.P = !0, ec(o, e) } k$1.cb = function () { this.v != null && (this.v = null, sc(this), tc(this), I(19)) }; function rc(e) { e.v != null && (l.clearTimeout(e.v), e.v = null) } function mc$1(e, s) { var o = null; if (e.g == s) { rc(e), oc(e), e.g = null; var c = 2 } else if (qc$1(e.h, s)) o = s.D, xc(e.h, s), c = 1; else return; if (e.G != 0) { if (e.pa = s.Y, s.i) if (c == 1) { o = s.s ? s.s.length : 0, s = Date.now() - s.F; var et = e.C; c = Mb(), C$1(c, new Pb(c, o)), zc$1(e) } else yc(e); else if (et = s.o, et == 3 || et == 0 && 0 < e.pa || !(c == 1 && Bd(e, s) || c == 2 && tc(e))) switch (o && 0 < o.length && (s = e.h, s.i = s.i.concat(o)), et) { case 1: R(e, 5); break; case 4: R(e, 10); break; case 3: R(e, 6); break; default: R(e, 2) } } } function Cd(e, s) { let o = e.Xa + Math.floor(Math.random() * e.bb); return e.l || (o *= 2), o * s } function R(e, s) { if (e.j.info("Error code " + s), s == 2) { var o = null; e.l && (o = null); var c = q$1(e.kb, e); o || (o = new T("//www.google.com/images/cleardot.gif"), l.location && l.location.protocol == "http" || Gc$1(o, "https"), dc$1(o)), cd(o.toString(), c) } else I(2); e.G = 0, e.l && e.l.va(s), Ad(e), yd(e) } k$1.kb = function (e) { e ? (this.j.info("Successfully pinged google.com"), I(2)) : (this.j.info("Failed to ping google.com"), I(1)) }; function Ad(e) { if (e.G = 0, e.la = [], e.l) { const s = Zc$1(e.h); (s.length != 0 || e.i.length != 0) && (na(e.la, s), na(e.la, e.i), e.h.i.length = 0, ma$1(e.i), e.i.length = 0), e.l.ua() } } function wc$1(e, s, o) { var c = o instanceof T ? M$1(o) : new T(o, void 0); if (c.g != "") s && (c.g = s + "." + c.g), Hc$1(c, c.m); else { var et = l.location; c = et.protocol, s = s ? s + "." + et.hostname : et.hostname, et = +et.port; var at = new T(null, void 0); c && Gc$1(at, c), s && (at.g = s), et && Hc$1(at, et), o && (at.l = o), c = at } return o = e.D, s = e.za, o && s && S$1(c, o, s), S$1(c, "VER", e.ma), zd(e, c), c } function gc(e, s, o) { if (s && !e.H) throw Error("Can't create secondary domain capable XhrIo object."); return s = o && e.Da && !e.ra ? new W$1(new ed({ jb: !0 })) : new W$1(e.ra), s.Ka(e.H), s } function Gd() { } k$1 = Gd.prototype; k$1.xa = function () { }; k$1.wa = function () { }; k$1.va = function () { }; k$1.ua = function () { }; k$1.Ra = function () { }; function Hd() { if (y && !(10 <= Number(La$1))) throw Error("Environmental error: no available transport.") } Hd.prototype.g = function (e, s) { return new X$1(e, s) }; function X$1(e, s) { B$1.call(this), this.g = new xd(s), this.l = e, this.h = s && s.messageUrlParams || null, e = s && s.messageHeaders || null, s && s.clientProtocolHeaderRequired && (e ? e["X-Client-Protocol"] = "webchannel" : e = { "X-Client-Protocol": "webchannel" }), this.g.s = e, e = s && s.initMessageHeaders || null, s && s.messageContentType && (e ? e["X-WebChannel-Content-Type"] = s.messageContentType : e = { "X-WebChannel-Content-Type": s.messageContentType }), s && s.ya && (e ? e["X-WebChannel-Client-Profile"] = s.ya : e = { "X-WebChannel-Client-Profile": s.ya }), this.g.S = e, (e = s && s.Yb) && !pa(e) && (this.g.o = e), this.A = s && s.supportsCrossDomainXhr || !1, this.v = s && s.sendRawJson || !1, (s = s && s.httpSessionIdParam) && !pa(s) && (this.g.D = s, e = this.h, e !== null && s in e && (e = this.h, s in e && delete e[s])), this.j = new Y$1(this) } t(X$1, B$1); X$1.prototype.m = function () { this.g.l = this.j, this.A && (this.g.H = !0); var e = this.g, s = this.l, o = this.h || void 0; I(0), e.V = s, e.ia = o || {}, e.L = e.Y, e.F = wc$1(e, null, e.V), zc$1(e) }; X$1.prototype.close = function () { Ac$1(this.g) }; X$1.prototype.u = function (e) { var s = this.g; if (typeof e == "string") { var o = {}; o.__data__ = e, e = o } else this.v && (o = {}, o.__data__ = lb(e), e = o); s.i.push(new Vc(s.ab++, e)), s.G == 3 && zc$1(s) }; X$1.prototype.M = function () { this.g.l = null, delete this.j, Ac$1(this.g), delete this.g, X$1.X.M.call(this) }; function Id(e) { Vb.call(this); var s = e.__sm__; if (s) { e: { for (const o in s) { e = o; break e } e = void 0 } (this.i = e) && (e = this.i, s = s !== null && e in s ? s[e] : void 0), this.data = s } else this.data = e } t(Id, Vb); function Jd() { Wb.call(this), this.status = 1 } t(Jd, Wb); function Y$1(e) { this.g = e } t(Y$1, Gd); Y$1.prototype.xa = function () { C$1(this.g, "a") }; Y$1.prototype.wa = function (e) { C$1(this.g, new Id(e)) }; Y$1.prototype.va = function (e) { C$1(this.g, new Jd) }; Y$1.prototype.ua = function () { C$1(this.g, "b") }; Hd.prototype.createWebChannel = Hd.prototype.g; X$1.prototype.send = X$1.prototype.u; X$1.prototype.open = X$1.prototype.m; X$1.prototype.close = X$1.prototype.close; Qb.NO_ERROR = 0; Qb.TIMEOUT = 8; Qb.HTTP_ERROR = 6; Rb.COMPLETE = "complete"; Ub.EventType = K$1; K$1.OPEN = "a"; K$1.CLOSE = "b"; K$1.ERROR = "c"; K$1.MESSAGE = "d"; B$1.prototype.listen = B$1.prototype.N; W$1.prototype.listenOnce = W$1.prototype.O; W$1.prototype.getLastError = W$1.prototype.Oa; W$1.prototype.getLastErrorCode = W$1.prototype.Ea; W$1.prototype.getStatus = W$1.prototype.aa; W$1.prototype.getResponseJson = W$1.prototype.Sa; W$1.prototype.getResponseText = W$1.prototype.fa; W$1.prototype.send = W$1.prototype.da; W$1.prototype.setWithCredentials = W$1.prototype.Ka; var createWebChannelTransport = function () { return new Hd }, getStatEventTarget = function () { return Mb() }, ErrorCode = Qb, EventType = Rb, Event$1 = G$1, Stat = { sb: 0, vb: 1, wb: 2, Pb: 3, Ub: 4, Rb: 5, Sb: 6, Qb: 7, Ob: 8, Tb: 9, PROXY: 10, NOPROXY: 11, Mb: 12, Ib: 13, Jb: 14, Hb: 15, Kb: 16, Lb: 17, ob: 18, nb: 19, pb: 20 }, FetchXmlHttpFactory = ed, WebChannel = Ub, XhrIo = W$1; const b = "@firebase/firestore";/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class P { constructor(s) { this.uid = s } isAuthenticated() { return this.uid != null } toKey() { return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user" } isEqual(s) { return s.uid === this.uid } } P.UNAUTHENTICATED = new P(null), P.GOOGLE_CREDENTIALS = new P("google-credentials-uid"), P.FIRST_PARTY = new P("first-party-uid"), P.MOCK_USER = new P("mock-user");/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let v = "9.13.0";/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const V = new Logger("@firebase/firestore"); function S() { return V.logLevel } function C(e, ...s) { if (V.logLevel <= LogLevel.DEBUG) { const o = s.map(k); V.debug(`Firestore (${v}): ${e}`, ...o) } } function x(e, ...s) { if (V.logLevel <= LogLevel.ERROR) { const o = s.map(k); V.error(`Firestore (${v}): ${e}`, ...o) } } function N(e, ...s) { if (V.logLevel <= LogLevel.WARN) { const o = s.map(k); V.warn(`Firestore (${v}): ${e}`, ...o) } } function k(e) {
	if (typeof e == "string") return e; try { return s = e, JSON.stringify(s) } catch { return e }/**
* @license
* Copyright 2020 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/var s
}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function O(e = "Unexpected state") { const s = `FIRESTORE (${v}) INTERNAL ASSERTION FAILED: ` + e; throw x(s), new Error(s) } function M(e, s) { e || O() } function $(e, s) { return e }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const B = { OK: "ok", CANCELLED: "cancelled", UNKNOWN: "unknown", INVALID_ARGUMENT: "invalid-argument", DEADLINE_EXCEEDED: "deadline-exceeded", NOT_FOUND: "not-found", ALREADY_EXISTS: "already-exists", PERMISSION_DENIED: "permission-denied", UNAUTHENTICATED: "unauthenticated", RESOURCE_EXHAUSTED: "resource-exhausted", FAILED_PRECONDITION: "failed-precondition", ABORTED: "aborted", OUT_OF_RANGE: "out-of-range", UNIMPLEMENTED: "unimplemented", INTERNAL: "internal", UNAVAILABLE: "unavailable", DATA_LOSS: "data-loss" }; class L extends FirebaseError { constructor(s, o) { super(s, o), this.code = s, this.message = o, this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}` } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class U { constructor() { this.promise = new Promise((s, o) => { this.resolve = s, this.reject = o }) } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class q { constructor(s, o) { this.user = o, this.type = "OAuth", this.headers = new Map, this.headers.set("Authorization", `Bearer ${s}`) } } class K { getToken() { return Promise.resolve(null) } invalidateToken() { } start(s, o) { s.enqueueRetryable(() => o(P.UNAUTHENTICATED)) } shutdown() { } } class G { constructor(s) { this.token = s, this.changeListener = null } getToken() { return Promise.resolve(this.token) } invalidateToken() { } start(s, o) { this.changeListener = o, s.enqueueRetryable(() => o(this.token.user)) } shutdown() { this.changeListener = null } } class Q { constructor(s) { this.t = s, this.currentUser = P.UNAUTHENTICATED, this.i = 0, this.forceRefresh = !1, this.auth = null } start(s, o) { let c = this.i; const et = dt => this.i !== c ? (c = this.i, o(dt)) : Promise.resolve(); let at = new U; this.o = () => { this.i++, this.currentUser = this.u(), at.resolve(), at = new U, s.enqueueRetryable(() => et(this.currentUser)) }; const lt = () => { const dt = at; s.enqueueRetryable(async () => { await dt.promise, await et(this.currentUser) }) }, ft = dt => { C("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = dt, this.auth.addAuthTokenListener(this.o), lt() }; this.t.onInit(dt => ft(dt)), setTimeout(() => { if (!this.auth) { const dt = this.t.getImmediate({ optional: !0 }); dt ? ft(dt) : (C("FirebaseAuthCredentialsProvider", "Auth not yet detected"), at.resolve(), at = new U) } }, 0), lt() } getToken() { const s = this.i, o = this.forceRefresh; return this.forceRefresh = !1, this.auth ? this.auth.getToken(o).then(c => this.i !== s ? (C("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : c ? (M(typeof c.accessToken == "string"), new q(c.accessToken, this.currentUser)) : null) : Promise.resolve(null) } invalidateToken() { this.forceRefresh = !0 } shutdown() { this.auth && this.auth.removeAuthTokenListener(this.o) } u() { const s = this.auth && this.auth.getUid(); return M(s === null || typeof s == "string"), new P(s) } } class j { constructor(s, o, c, et) { this.h = s, this.l = o, this.m = c, this.g = et, this.type = "FirstParty", this.user = P.FIRST_PARTY, this.p = new Map } I() { return this.g ? this.g() : (M(!(typeof this.h != "object" || this.h === null || !this.h.auth || !this.h.auth.getAuthHeaderValueForFirstParty)), this.h.auth.getAuthHeaderValueForFirstParty([])) } get headers() { this.p.set("X-Goog-AuthUser", this.l); const s = this.I(); return s && this.p.set("Authorization", s), this.m && this.p.set("X-Goog-Iam-Authorization-Token", this.m), this.p } } class W { constructor(s, o, c, et) { this.h = s, this.l = o, this.m = c, this.g = et } getToken() { return Promise.resolve(new j(this.h, this.l, this.m, this.g)) } start(s, o) { s.enqueueRetryable(() => o(P.FIRST_PARTY)) } shutdown() { } invalidateToken() { } } class z { constructor(s) { this.value = s, this.type = "AppCheck", this.headers = new Map, s && s.length > 0 && this.headers.set("x-firebase-appcheck", this.value) } } class H { constructor(s) { this.T = s, this.forceRefresh = !1, this.appCheck = null, this.A = null } start(s, o) { const c = at => { at.error != null && C("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${at.error.message}`); const lt = at.token !== this.A; return this.A = at.token, C("FirebaseAppCheckTokenProvider", `Received ${lt ? "new" : "existing"} token.`), lt ? o(at.token) : Promise.resolve() }; this.o = at => { s.enqueueRetryable(() => c(at)) }; const et = at => { C("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = at, this.appCheck.addTokenListener(this.o) }; this.T.onInit(at => et(at)), setTimeout(() => { if (!this.appCheck) { const at = this.T.getImmediate({ optional: !0 }); at ? et(at) : C("FirebaseAppCheckTokenProvider", "AppCheck not yet detected") } }, 0) } getToken() { const s = this.forceRefresh; return this.forceRefresh = !1, this.appCheck ? this.appCheck.getToken(s).then(o => o ? (M(typeof o.token == "string"), this.A = o.token, new z(o.token)) : null) : Promise.resolve(null) } invalidateToken() { this.forceRefresh = !0 } shutdown() { this.appCheck && this.appCheck.removeTokenListener(this.o) } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Y(e) { const s = typeof self < "u" && (self.crypto || self.msCrypto), o = new Uint8Array(e); if (s && typeof s.getRandomValues == "function") s.getRandomValues(o); else for (let c = 0; c < e; c++)o[c] = Math.floor(256 * Math.random()); return o }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class X { static R() { const s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", o = Math.floor(256 / s.length) * s.length; let c = ""; for (; c.length < 20;) { const et = Y(40); for (let at = 0; at < et.length; ++at)c.length < 20 && et[at] < o && (c += s.charAt(et[at] % s.length)) } return c } } function Z(e, s) { return e < s ? -1 : e > s ? 1 : 0 } function tt(e, s, o) { return e.length === s.length && e.every((c, et) => o(c, s[et])) }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class nt { constructor(s, o) { if (this.seconds = s, this.nanoseconds = o, o < 0) throw new L(B.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + o); if (o >= 1e9) throw new L(B.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + o); if (s < -62135596800) throw new L(B.INVALID_ARGUMENT, "Timestamp seconds out of range: " + s); if (s >= 253402300800) throw new L(B.INVALID_ARGUMENT, "Timestamp seconds out of range: " + s) } static now() { return nt.fromMillis(Date.now()) } static fromDate(s) { return nt.fromMillis(s.getTime()) } static fromMillis(s) { const o = Math.floor(s / 1e3), c = Math.floor(1e6 * (s - 1e3 * o)); return new nt(o, c) } toDate() { return new Date(this.toMillis()) } toMillis() { return 1e3 * this.seconds + this.nanoseconds / 1e6 } _compareTo(s) { return this.seconds === s.seconds ? Z(this.nanoseconds, s.nanoseconds) : Z(this.seconds, s.seconds) } isEqual(s) { return s.seconds === this.seconds && s.nanoseconds === this.nanoseconds } toString() { return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")" } toJSON() { return { seconds: this.seconds, nanoseconds: this.nanoseconds } } valueOf() { const s = this.seconds - -62135596800; return String(s).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0") } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class st { constructor(s) { this.timestamp = s } static fromTimestamp(s) { return new st(s) } static min() { return new st(new nt(0, 0)) } static max() { return new st(new nt(253402300799, 999999999)) } compareTo(s) { return this.timestamp._compareTo(s.timestamp) } isEqual(s) { return this.timestamp.isEqual(s.timestamp) } toMicroseconds() { return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3 } toString() { return "SnapshotVersion(" + this.timestamp.toString() + ")" } toTimestamp() { return this.timestamp } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class it { constructor(s, o, c) { o === void 0 ? o = 0 : o > s.length && O(), c === void 0 ? c = s.length - o : c > s.length - o && O(), this.segments = s, this.offset = o, this.len = c } get length() { return this.len } isEqual(s) { return it.comparator(this, s) === 0 } child(s) { const o = this.segments.slice(this.offset, this.limit()); return s instanceof it ? s.forEach(c => { o.push(c) }) : o.push(s), this.construct(o) } limit() { return this.offset + this.length } popFirst(s) { return s = s === void 0 ? 1 : s, this.construct(this.segments, this.offset + s, this.length - s) } popLast() { return this.construct(this.segments, this.offset, this.length - 1) } firstSegment() { return this.segments[this.offset] } lastSegment() { return this.get(this.length - 1) } get(s) { return this.segments[this.offset + s] } isEmpty() { return this.length === 0 } isPrefixOf(s) { if (s.length < this.length) return !1; for (let o = 0; o < this.length; o++)if (this.get(o) !== s.get(o)) return !1; return !0 } isImmediateParentOf(s) { if (this.length + 1 !== s.length) return !1; for (let o = 0; o < this.length; o++)if (this.get(o) !== s.get(o)) return !1; return !0 } forEach(s) { for (let o = this.offset, c = this.limit(); o < c; o++)s(this.segments[o]) } toArray() { return this.segments.slice(this.offset, this.limit()) } static comparator(s, o) { const c = Math.min(s.length, o.length); for (let et = 0; et < c; et++) { const at = s.get(et), lt = o.get(et); if (at < lt) return -1; if (at > lt) return 1 } return s.length < o.length ? -1 : s.length > o.length ? 1 : 0 } } class rt extends it { construct(s, o, c) { return new rt(s, o, c) } canonicalString() { return this.toArray().join("/") } toString() { return this.canonicalString() } static fromString(...s) { const o = []; for (const c of s) { if (c.indexOf("//") >= 0) throw new L(B.INVALID_ARGUMENT, `Invalid segment (${c}). Paths must not contain // in them.`); o.push(...c.split("/").filter(et => et.length > 0)) } return new rt(o) } static emptyPath() { return new rt([]) } } const ot = /^[_a-zA-Z][_a-zA-Z0-9]*$/; class ut extends it { construct(s, o, c) { return new ut(s, o, c) } static isValidIdentifier(s) { return ot.test(s) } canonicalString() { return this.toArray().map(s => (s = s.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), ut.isValidIdentifier(s) || (s = "`" + s + "`"), s)).join(".") } toString() { return this.canonicalString() } isKeyField() { return this.length === 1 && this.get(0) === "__name__" } static keyField() { return new ut(["__name__"]) } static fromServerFormat(s) { const o = []; let c = "", et = 0; const at = () => { if (c.length === 0) throw new L(B.INVALID_ARGUMENT, `Invalid field path (${s}). Paths must not be empty, begin with '.', end with '.', or contain '..'`); o.push(c), c = "" }; let lt = !1; for (; et < s.length;) { const ft = s[et]; if (ft === "\\") { if (et + 1 === s.length) throw new L(B.INVALID_ARGUMENT, "Path has trailing escape character: " + s); const dt = s[et + 1]; if (dt !== "\\" && dt !== "." && dt !== "`") throw new L(B.INVALID_ARGUMENT, "Path has invalid escape sequence: " + s); c += dt, et += 2 } else ft === "`" ? (lt = !lt, et++) : ft !== "." || lt ? (c += ft, et++) : (at(), et++) } if (at(), lt) throw new L(B.INVALID_ARGUMENT, "Unterminated ` in path: " + s); return new ut(o) } static emptyPath() { return new ut([]) } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class ct { constructor(s) { this.path = s } static fromPath(s) { return new ct(rt.fromString(s)) } static fromName(s) { return new ct(rt.fromString(s).popFirst(5)) } static empty() { return new ct(rt.emptyPath()) } get collectionGroup() { return this.path.popLast().lastSegment() } hasCollectionId(s) { return this.path.length >= 2 && this.path.get(this.path.length - 2) === s } getCollectionGroup() { return this.path.get(this.path.length - 2) } getCollectionPath() { return this.path.popLast() } isEqual(s) { return s !== null && rt.comparator(this.path, s.path) === 0 } toString() { return this.path.toString() } static comparator(s, o) { return rt.comparator(s.path, o.path) } static isDocumentKey(s) { return s.length % 2 == 0 } static fromSegments(s) { return new ct(new rt(s.slice())) } } function mt(e, s) { const o = e.toTimestamp().seconds, c = e.toTimestamp().nanoseconds + 1, et = st.fromTimestamp(c === 1e9 ? new nt(o + 1, 0) : new nt(o, c)); return new yt(et, ct.empty(), s) } function gt(e) { return new yt(e.readTime, e.key, -1) } class yt { constructor(s, o, c) { this.readTime = s, this.documentKey = o, this.largestBatchId = c } static min() { return new yt(st.min(), ct.empty(), -1) } static max() { return new yt(st.max(), ct.empty(), -1) } } function pt(e, s) { let o = e.readTime.compareTo(s.readTime); return o !== 0 ? o : (o = ct.comparator(e.documentKey, s.documentKey), o !== 0 ? o : Z(e.largestBatchId, s.largestBatchId)) }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const It = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab."; class Tt { constructor() { this.onCommittedListeners = [] } addOnCommittedListener(s) { this.onCommittedListeners.push(s) } raiseOnCommittedEvent() { this.onCommittedListeners.forEach(s => s()) } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function Et(e) { if (e.code !== B.FAILED_PRECONDITION || e.message !== It) throw e; C("LocalStore", "Unexpectedly lost primary lease") }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class At { constructor(s) { this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = !1, this.callbackAttached = !1, s(o => { this.isDone = !0, this.result = o, this.nextCallback && this.nextCallback(o) }, o => { this.isDone = !0, this.error = o, this.catchCallback && this.catchCallback(o) }) } catch(s) { return this.next(void 0, s) } next(s, o) { return this.callbackAttached && O(), this.callbackAttached = !0, this.isDone ? this.error ? this.wrapFailure(o, this.error) : this.wrapSuccess(s, this.result) : new At((c, et) => { this.nextCallback = at => { this.wrapSuccess(s, at).next(c, et) }, this.catchCallback = at => { this.wrapFailure(o, at).next(c, et) } }) } toPromise() { return new Promise((s, o) => { this.next(s, o) }) } wrapUserFunction(s) { try { const o = s(); return o instanceof At ? o : At.resolve(o) } catch (o) { return At.reject(o) } } wrapSuccess(s, o) { return s ? this.wrapUserFunction(() => s(o)) : At.resolve(o) } wrapFailure(s, o) { return s ? this.wrapUserFunction(() => s(o)) : At.reject(o) } static resolve(s) { return new At((o, c) => { o(s) }) } static reject(s) { return new At((o, c) => { c(s) }) } static waitFor(s) { return new At((o, c) => { let et = 0, at = 0, lt = !1; s.forEach(ft => { ++et, ft.next(() => { ++at, lt && at === et && o() }, dt => c(dt)) }), lt = !0, at === et && o() }) } static or(s) { let o = At.resolve(!1); for (const c of s) o = o.next(et => et ? At.resolve(et) : c()); return o } static forEach(s, o) { const c = []; return s.forEach((et, at) => { c.push(o.call(this, et, at)) }), this.waitFor(c) } static mapArray(s, o) { return new At((c, et) => { const at = s.length, lt = new Array(at); let ft = 0; for (let dt = 0; dt < at; dt++) { const ht = dt; o(s[ht]).next(vt => { lt[ht] = vt, ++ft, ft === at && c(lt) }, vt => et(vt)) } }) } static doWhile(s, o) { return new At((c, et) => { const at = () => { s() === !0 ? o().next(() => { at() }, et) : c() }; at() }) } } function Vt(e) { return e.name === "IndexedDbTransactionError" }/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Ot { constructor(s, o) { this.previousValue = s, o && (o.sequenceNumberHandler = c => this.ut(c), this.ct = c => o.writeSequenceNumber(c)) } ut(s) { return this.previousValue = Math.max(s, this.previousValue), this.previousValue } next() { const s = ++this.previousValue; return this.ct && this.ct(s), s } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Mt(e) { let s = 0; for (const o in e) Object.prototype.hasOwnProperty.call(e, o) && s++; return s } function Ft(e, s) { for (const o in e) Object.prototype.hasOwnProperty.call(e, o) && s(o, e[o]) } function $t(e) { for (const s in e) if (Object.prototype.hasOwnProperty.call(e, s)) return !1; return !0 }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */Ot.at = -1; class Bt { constructor(s, o) { this.comparator = s, this.root = o || Ut.EMPTY } insert(s, o) { return new Bt(this.comparator, this.root.insert(s, o, this.comparator).copy(null, null, Ut.BLACK, null, null)) } remove(s) { return new Bt(this.comparator, this.root.remove(s, this.comparator).copy(null, null, Ut.BLACK, null, null)) } get(s) { let o = this.root; for (; !o.isEmpty();) { const c = this.comparator(s, o.key); if (c === 0) return o.value; c < 0 ? o = o.left : c > 0 && (o = o.right) } return null } indexOf(s) { let o = 0, c = this.root; for (; !c.isEmpty();) { const et = this.comparator(s, c.key); if (et === 0) return o + c.left.size; et < 0 ? c = c.left : (o += c.left.size + 1, c = c.right) } return -1 } isEmpty() { return this.root.isEmpty() } get size() { return this.root.size } minKey() { return this.root.minKey() } maxKey() { return this.root.maxKey() } inorderTraversal(s) { return this.root.inorderTraversal(s) } forEach(s) { this.inorderTraversal((o, c) => (s(o, c), !1)) } toString() { const s = []; return this.inorderTraversal((o, c) => (s.push(`${o}:${c}`), !1)), `{${s.join(", ")}}` } reverseTraversal(s) { return this.root.reverseTraversal(s) } getIterator() { return new Lt(this.root, null, this.comparator, !1) } getIteratorFrom(s) { return new Lt(this.root, s, this.comparator, !1) } getReverseIterator() { return new Lt(this.root, null, this.comparator, !0) } getReverseIteratorFrom(s) { return new Lt(this.root, s, this.comparator, !0) } } class Lt { constructor(s, o, c, et) { this.isReverse = et, this.nodeStack = []; let at = 1; for (; !s.isEmpty();)if (at = o ? c(s.key, o) : 1, o && et && (at *= -1), at < 0) s = this.isReverse ? s.left : s.right; else { if (at === 0) { this.nodeStack.push(s); break } this.nodeStack.push(s), s = this.isReverse ? s.right : s.left } } getNext() { let s = this.nodeStack.pop(); const o = { key: s.key, value: s.value }; if (this.isReverse) for (s = s.left; !s.isEmpty();)this.nodeStack.push(s), s = s.right; else for (s = s.right; !s.isEmpty();)this.nodeStack.push(s), s = s.left; return o } hasNext() { return this.nodeStack.length > 0 } peek() { if (this.nodeStack.length === 0) return null; const s = this.nodeStack[this.nodeStack.length - 1]; return { key: s.key, value: s.value } } } class Ut { constructor(s, o, c, et, at) { this.key = s, this.value = o, this.color = c != null ? c : Ut.RED, this.left = et != null ? et : Ut.EMPTY, this.right = at != null ? at : Ut.EMPTY, this.size = this.left.size + 1 + this.right.size } copy(s, o, c, et, at) { return new Ut(s != null ? s : this.key, o != null ? o : this.value, c != null ? c : this.color, et != null ? et : this.left, at != null ? at : this.right) } isEmpty() { return !1 } inorderTraversal(s) { return this.left.inorderTraversal(s) || s(this.key, this.value) || this.right.inorderTraversal(s) } reverseTraversal(s) { return this.right.reverseTraversal(s) || s(this.key, this.value) || this.left.reverseTraversal(s) } min() { return this.left.isEmpty() ? this : this.left.min() } minKey() { return this.min().key } maxKey() { return this.right.isEmpty() ? this.key : this.right.maxKey() } insert(s, o, c) { let et = this; const at = c(s, et.key); return et = at < 0 ? et.copy(null, null, null, et.left.insert(s, o, c), null) : at === 0 ? et.copy(null, o, null, null, null) : et.copy(null, null, null, null, et.right.insert(s, o, c)), et.fixUp() } removeMin() { if (this.left.isEmpty()) return Ut.EMPTY; let s = this; return s.left.isRed() || s.left.left.isRed() || (s = s.moveRedLeft()), s = s.copy(null, null, null, s.left.removeMin(), null), s.fixUp() } remove(s, o) { let c, et = this; if (o(s, et.key) < 0) et.left.isEmpty() || et.left.isRed() || et.left.left.isRed() || (et = et.moveRedLeft()), et = et.copy(null, null, null, et.left.remove(s, o), null); else { if (et.left.isRed() && (et = et.rotateRight()), et.right.isEmpty() || et.right.isRed() || et.right.left.isRed() || (et = et.moveRedRight()), o(s, et.key) === 0) { if (et.right.isEmpty()) return Ut.EMPTY; c = et.right.min(), et = et.copy(c.key, c.value, null, null, et.right.removeMin()) } et = et.copy(null, null, null, null, et.right.remove(s, o)) } return et.fixUp() } isRed() { return this.color } fixUp() { let s = this; return s.right.isRed() && !s.left.isRed() && (s = s.rotateLeft()), s.left.isRed() && s.left.left.isRed() && (s = s.rotateRight()), s.left.isRed() && s.right.isRed() && (s = s.colorFlip()), s } moveRedLeft() { let s = this.colorFlip(); return s.right.left.isRed() && (s = s.copy(null, null, null, null, s.right.rotateRight()), s = s.rotateLeft(), s = s.colorFlip()), s } moveRedRight() { let s = this.colorFlip(); return s.left.left.isRed() && (s = s.rotateRight(), s = s.colorFlip()), s } rotateLeft() { const s = this.copy(null, null, Ut.RED, null, this.right.left); return this.right.copy(null, null, this.color, s, null) } rotateRight() { const s = this.copy(null, null, Ut.RED, this.left.right, null); return this.left.copy(null, null, this.color, null, s) } colorFlip() { const s = this.left.copy(null, null, !this.left.color, null, null), o = this.right.copy(null, null, !this.right.color, null, null); return this.copy(null, null, !this.color, s, o) } checkMaxDepth() { const s = this.check(); return Math.pow(2, s) <= this.size + 1 } check() { if (this.isRed() && this.left.isRed() || this.right.isRed()) throw O(); const s = this.left.check(); if (s !== this.right.check()) throw O(); return s + (this.isRed() ? 0 : 1) } } Ut.EMPTY = null, Ut.RED = !0, Ut.BLACK = !1; Ut.EMPTY = new class { constructor() { this.size = 0 } get key() { throw O() } get value() { throw O() } get color() { throw O() } get left() { throw O() } get right() { throw O() } copy(e, s, o, c, et) { return this } insert(e, s, o) { return new Ut(e, s) } remove(e, s) { return this } isEmpty() { return !0 } inorderTraversal(e) { return !1 } reverseTraversal(e) { return !1 } minKey() { return null } maxKey() { return null } isRed() { return !1 } checkMaxDepth() { return !0 } check() { return 0 } };/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class qt { constructor(s) { this.comparator = s, this.data = new Bt(this.comparator) } has(s) { return this.data.get(s) !== null } first() { return this.data.minKey() } last() { return this.data.maxKey() } get size() { return this.data.size } indexOf(s) { return this.data.indexOf(s) } forEach(s) { this.data.inorderTraversal((o, c) => (s(o), !1)) } forEachInRange(s, o) { const c = this.data.getIteratorFrom(s[0]); for (; c.hasNext();) { const et = c.getNext(); if (this.comparator(et.key, s[1]) >= 0) return; o(et.key) } } forEachWhile(s, o) { let c; for (c = o !== void 0 ? this.data.getIteratorFrom(o) : this.data.getIterator(); c.hasNext();)if (!s(c.getNext().key)) return } firstAfterOrEqual(s) { const o = this.data.getIteratorFrom(s); return o.hasNext() ? o.getNext().key : null } getIterator() { return new Kt(this.data.getIterator()) } getIteratorFrom(s) { return new Kt(this.data.getIteratorFrom(s)) } add(s) { return this.copy(this.data.remove(s).insert(s, !0)) } delete(s) { return this.has(s) ? this.copy(this.data.remove(s)) : this } isEmpty() { return this.data.isEmpty() } unionWith(s) { let o = this; return o.size < s.size && (o = s, s = this), s.forEach(c => { o = o.add(c) }), o } isEqual(s) { if (!(s instanceof qt) || this.size !== s.size) return !1; const o = this.data.getIterator(), c = s.data.getIterator(); for (; o.hasNext();) { const et = o.getNext().key, at = c.getNext().key; if (this.comparator(et, at) !== 0) return !1 } return !0 } toArray() { const s = []; return this.forEach(o => { s.push(o) }), s } toString() { const s = []; return this.forEach(o => s.push(o)), "SortedSet(" + s.toString() + ")" } copy(s) { const o = new qt(this.comparator); return o.data = s, o } } class Kt { constructor(s) { this.iter = s } getNext() { return this.iter.getNext().key } hasNext() { return this.iter.hasNext() } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Qt { constructor(s) { this.fields = s, s.sort(ut.comparator) } static empty() { return new Qt([]) } unionWith(s) { let o = new qt(ut.comparator); for (const c of this.fields) o = o.add(c); for (const c of s) o = o.add(c); return new Qt(o.toArray()) } covers(s) { for (const o of this.fields) if (o.isPrefixOf(s)) return !0; return !1 } isEqual(s) { return tt(this.fields, s.fields, (o, c) => o.isEqual(c)) } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Wt { constructor(s) { this.binaryString = s } static fromBase64String(s) { const o = atob(s); return new Wt(o) } static fromUint8Array(s) { const o = function (c) { let et = ""; for (let at = 0; at < c.length; ++at)et += String.fromCharCode(c[at]); return et }(s); return new Wt(o) } [Symbol.iterator]() { let s = 0; return { next: () => s < this.binaryString.length ? { value: this.binaryString.charCodeAt(s++), done: !1 } : { value: void 0, done: !0 } } } toBase64() { return s = this.binaryString, btoa(s); var s } toUint8Array() { return function (s) { const o = new Uint8Array(s.length); for (let c = 0; c < s.length; c++)o[c] = s.charCodeAt(c); return o }(this.binaryString) } approximateByteSize() { return 2 * this.binaryString.length } compareTo(s) { return Z(this.binaryString, s.binaryString) } isEqual(s) { return this.binaryString === s.binaryString } } Wt.EMPTY_BYTE_STRING = new Wt(""); const zt = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/); function Ht(e) { if (M(!!e), typeof e == "string") { let s = 0; const o = zt.exec(e); if (M(!!o), o[1]) { let et = o[1]; et = (et + "000000000").substr(0, 9), s = Number(et) } const c = new Date(e); return { seconds: Math.floor(c.getTime() / 1e3), nanos: s } } return { seconds: Jt(e.seconds), nanos: Jt(e.nanos) } } function Jt(e) { return typeof e == "number" ? e : typeof e == "string" ? Number(e) : 0 } function Yt(e) { return typeof e == "string" ? Wt.fromBase64String(e) : Wt.fromUint8Array(e) }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Xt(e) { var s, o; return ((o = (((s = e == null ? void 0 : e.mapValue) === null || s === void 0 ? void 0 : s.fields) || {}).__type__) === null || o === void 0 ? void 0 : o.stringValue) === "server_timestamp" } function te(e) { const s = Ht(e.mapValue.fields.__local_write_time__.timestampValue); return new nt(s.seconds, s.nanos) }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class ee { constructor(s, o, c, et, at, lt, ft, dt) { this.databaseId = s, this.appId = o, this.persistenceKey = c, this.host = et, this.ssl = at, this.forceLongPolling = lt, this.autoDetectLongPolling = ft, this.useFetchStreams = dt } } class ne { constructor(s, o) { this.projectId = s, this.database = o || "(default)" } static empty() { return new ne("", "") } get isDefaultDatabase() { return this.database === "(default)" } isEqual(s) { return s instanceof ne && s.projectId === this.projectId && s.database === this.database } } function se(e) { return e == null } function ie(e) { return e === 0 && 1 / e == -1 / 0 } function re(e) { return typeof e == "number" && Number.isInteger(e) && !ie(e) && e <= Number.MAX_SAFE_INTEGER && e >= Number.MIN_SAFE_INTEGER }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const oe = { mapValue: { fields: { __type__: { stringValue: "__max__" } } } }; function ce(e) { return "nullValue" in e ? 0 : "booleanValue" in e ? 1 : "integerValue" in e || "doubleValue" in e ? 2 : "timestampValue" in e ? 3 : "stringValue" in e ? 5 : "bytesValue" in e ? 6 : "referenceValue" in e ? 7 : "geoPointValue" in e ? 8 : "arrayValue" in e ? 9 : "mapValue" in e ? Xt(e) ? 4 : Ee(e) ? 9007199254740991 : 10 : O() } function ae(e, s) { if (e === s) return !0; const o = ce(e); if (o !== ce(s)) return !1; switch (o) { case 0: case 9007199254740991: return !0; case 1: return e.booleanValue === s.booleanValue; case 4: return te(e).isEqual(te(s)); case 3: return function (c, et) { if (typeof c.timestampValue == "string" && typeof et.timestampValue == "string" && c.timestampValue.length === et.timestampValue.length) return c.timestampValue === et.timestampValue; const at = Ht(c.timestampValue), lt = Ht(et.timestampValue); return at.seconds === lt.seconds && at.nanos === lt.nanos }(e, s); case 5: return e.stringValue === s.stringValue; case 6: return function (c, et) { return Yt(c.bytesValue).isEqual(Yt(et.bytesValue)) }(e, s); case 7: return e.referenceValue === s.referenceValue; case 8: return function (c, et) { return Jt(c.geoPointValue.latitude) === Jt(et.geoPointValue.latitude) && Jt(c.geoPointValue.longitude) === Jt(et.geoPointValue.longitude) }(e, s); case 2: return function (c, et) { if ("integerValue" in c && "integerValue" in et) return Jt(c.integerValue) === Jt(et.integerValue); if ("doubleValue" in c && "doubleValue" in et) { const at = Jt(c.doubleValue), lt = Jt(et.doubleValue); return at === lt ? ie(at) === ie(lt) : isNaN(at) && isNaN(lt) } return !1 }(e, s); case 9: return tt(e.arrayValue.values || [], s.arrayValue.values || [], ae); case 10: return function (c, et) { const at = c.mapValue.fields || {}, lt = et.mapValue.fields || {}; if (Mt(at) !== Mt(lt)) return !1; for (const ft in at) if (at.hasOwnProperty(ft) && (lt[ft] === void 0 || !ae(at[ft], lt[ft]))) return !1; return !0 }(e, s); default: return O() } } function he(e, s) { return (e.values || []).find(o => ae(o, s)) !== void 0 } function le(e, s) { if (e === s) return 0; const o = ce(e), c = ce(s); if (o !== c) return Z(o, c); switch (o) { case 0: case 9007199254740991: return 0; case 1: return Z(e.booleanValue, s.booleanValue); case 2: return function (et, at) { const lt = Jt(et.integerValue || et.doubleValue), ft = Jt(at.integerValue || at.doubleValue); return lt < ft ? -1 : lt > ft ? 1 : lt === ft ? 0 : isNaN(lt) ? isNaN(ft) ? 0 : -1 : 1 }(e, s); case 3: return fe(e.timestampValue, s.timestampValue); case 4: return fe(te(e), te(s)); case 5: return Z(e.stringValue, s.stringValue); case 6: return function (et, at) { const lt = Yt(et), ft = Yt(at); return lt.compareTo(ft) }(e.bytesValue, s.bytesValue); case 7: return function (et, at) { const lt = et.split("/"), ft = at.split("/"); for (let dt = 0; dt < lt.length && dt < ft.length; dt++) { const ht = Z(lt[dt], ft[dt]); if (ht !== 0) return ht } return Z(lt.length, ft.length) }(e.referenceValue, s.referenceValue); case 8: return function (et, at) { const lt = Z(Jt(et.latitude), Jt(at.latitude)); return lt !== 0 ? lt : Z(Jt(et.longitude), Jt(at.longitude)) }(e.geoPointValue, s.geoPointValue); case 9: return function (et, at) { const lt = et.values || [], ft = at.values || []; for (let dt = 0; dt < lt.length && dt < ft.length; ++dt) { const ht = le(lt[dt], ft[dt]); if (ht) return ht } return Z(lt.length, ft.length) }(e.arrayValue, s.arrayValue); case 10: return function (et, at) { if (et === oe.mapValue && at === oe.mapValue) return 0; if (et === oe.mapValue) return 1; if (at === oe.mapValue) return -1; const lt = et.fields || {}, ft = Object.keys(lt), dt = at.fields || {}, ht = Object.keys(dt); ft.sort(), ht.sort(); for (let vt = 0; vt < ft.length && vt < ht.length; ++vt) { const wt = Z(ft[vt], ht[vt]); if (wt !== 0) return wt; const St = le(lt[ft[vt]], dt[ht[vt]]); if (St !== 0) return St } return Z(ft.length, ht.length) }(e.mapValue, s.mapValue); default: throw O() } } function fe(e, s) { if (typeof e == "string" && typeof s == "string" && e.length === s.length) return Z(e, s); const o = Ht(e), c = Ht(s), et = Z(o.seconds, c.seconds); return et !== 0 ? et : Z(o.nanos, c.nanos) } function de(e) { return _e(e) } function _e(e) { return "nullValue" in e ? "null" : "booleanValue" in e ? "" + e.booleanValue : "integerValue" in e ? "" + e.integerValue : "doubleValue" in e ? "" + e.doubleValue : "timestampValue" in e ? function (c) { const et = Ht(c); return `time(${et.seconds},${et.nanos})` }(e.timestampValue) : "stringValue" in e ? e.stringValue : "bytesValue" in e ? Yt(e.bytesValue).toBase64() : "referenceValue" in e ? (o = e.referenceValue, ct.fromName(o).toString()) : "geoPointValue" in e ? `geo(${(s = e.geoPointValue).latitude},${s.longitude})` : "arrayValue" in e ? function (c) { let et = "[", at = !0; for (const lt of c.values || []) at ? at = !1 : et += ",", et += _e(lt); return et + "]" }(e.arrayValue) : "mapValue" in e ? function (c) { const et = Object.keys(c.fields || {}).sort(); let at = "{", lt = !0; for (const ft of et) lt ? lt = !1 : at += ",", at += `${ft}:${_e(c.fields[ft])}`; return at + "}" }(e.mapValue) : O(); var s, o } function me(e) { return !!e && "integerValue" in e } function ge(e) { return !!e && "arrayValue" in e } function Ie(e) { return !!e && "mapValue" in e } function Te(e) { if (e.geoPointValue) return { geoPointValue: Object.assign({}, e.geoPointValue) }; if (e.timestampValue && typeof e.timestampValue == "object") return { timestampValue: Object.assign({}, e.timestampValue) }; if (e.mapValue) { const s = { mapValue: { fields: {} } }; return Ft(e.mapValue.fields, (o, c) => s.mapValue.fields[o] = Te(c)), s } if (e.arrayValue) { const s = { arrayValue: { values: [] } }; for (let o = 0; o < (e.arrayValue.values || []).length; ++o)s.arrayValue.values[o] = Te(e.arrayValue.values[o]); return s } return Object.assign({}, e) } function Ee(e) { return (((e.mapValue || {}).fields || {}).__type__ || {}).stringValue === "__max__" }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class ve { constructor(s) { this.value = s } static empty() { return new ve({ mapValue: {} }) } field(s) { if (s.isEmpty()) return this.value; { let o = this.value; for (let c = 0; c < s.length - 1; ++c)if (o = (o.mapValue.fields || {})[s.get(c)], !Ie(o)) return null; return o = (o.mapValue.fields || {})[s.lastSegment()], o || null } } set(s, o) { this.getFieldsMap(s.popLast())[s.lastSegment()] = Te(o) } setAll(s) { let o = ut.emptyPath(), c = {}, et = []; s.forEach((lt, ft) => { if (!o.isImmediateParentOf(ft)) { const dt = this.getFieldsMap(o); this.applyChanges(dt, c, et), c = {}, et = [], o = ft.popLast() } lt ? c[ft.lastSegment()] = Te(lt) : et.push(ft.lastSegment()) }); const at = this.getFieldsMap(o); this.applyChanges(at, c, et) } delete(s) { const o = this.field(s.popLast()); Ie(o) && o.mapValue.fields && delete o.mapValue.fields[s.lastSegment()] } isEqual(s) { return ae(this.value, s.value) } getFieldsMap(s) { let o = this.value; o.mapValue.fields || (o.mapValue = { fields: {} }); for (let c = 0; c < s.length; ++c) { let et = o.mapValue.fields[s.get(c)]; Ie(et) && et.mapValue.fields || (et = { mapValue: { fields: {} } }, o.mapValue.fields[s.get(c)] = et), o = et } return o.mapValue.fields } applyChanges(s, o, c) { Ft(o, (et, at) => s[et] = at); for (const et of c) delete s[et] } clone() { return new ve(Te(this.value)) } } function Ve(e) { const s = []; return Ft(e.fields, (o, c) => { const et = new ut([o]); if (Ie(c)) { const at = Ve(c.mapValue).fields; if (at.length === 0) s.push(et); else for (const lt of at) s.push(et.child(lt)) } else s.push(et) }), new Qt(s) }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Se { constructor(s, o, c, et, at, lt) { this.key = s, this.documentType = o, this.version = c, this.readTime = et, this.data = at, this.documentState = lt } static newInvalidDocument(s) { return new Se(s, 0, st.min(), st.min(), ve.empty(), 0) } static newFoundDocument(s, o, c) { return new Se(s, 1, o, st.min(), c, 0) } static newNoDocument(s, o) { return new Se(s, 2, o, st.min(), ve.empty(), 0) } static newUnknownDocument(s, o) { return new Se(s, 3, o, st.min(), ve.empty(), 2) } convertToFoundDocument(s, o) { return this.version = s, this.documentType = 1, this.data = o, this.documentState = 0, this } convertToNoDocument(s) { return this.version = s, this.documentType = 2, this.data = ve.empty(), this.documentState = 0, this } convertToUnknownDocument(s) { return this.version = s, this.documentType = 3, this.data = ve.empty(), this.documentState = 2, this } setHasCommittedMutations() { return this.documentState = 2, this } setHasLocalMutations() { return this.documentState = 1, this.version = st.min(), this } setReadTime(s) { return this.readTime = s, this } get hasLocalMutations() { return this.documentState === 1 } get hasCommittedMutations() { return this.documentState === 2 } get hasPendingWrites() { return this.hasLocalMutations || this.hasCommittedMutations } isValidDocument() { return this.documentType !== 0 } isFoundDocument() { return this.documentType === 1 } isNoDocument() { return this.documentType === 2 } isUnknownDocument() { return this.documentType === 3 } isEqual(s) { return s instanceof Se && this.key.isEqual(s.key) && this.version.isEqual(s.version) && this.documentType === s.documentType && this.documentState === s.documentState && this.data.isEqual(s.data) } mutableCopy() { return new Se(this.key, this.documentType, this.version, this.readTime, this.data.clone(), this.documentState) } toString() { return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {documentType: ${this.documentType}}), {documentState: ${this.documentState}})` } }/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class De { constructor(s, o = null, c = [], et = [], at = null, lt = null, ft = null) { this.path = s, this.collectionGroup = o, this.orderBy = c, this.filters = et, this.limit = at, this.startAt = lt, this.endAt = ft, this.ht = null } } function Ce(e, s = null, o = [], c = [], et = null, at = null, lt = null) { return new De(e, s, o, c, et, at, lt) } function xe(e) { const s = $(e); if (s.ht === null) { let o = s.path.canonicalString(); s.collectionGroup !== null && (o += "|cg:" + s.collectionGroup), o += "|f:", o += s.filters.map(c => { return (et = c).field.canonicalString() + et.op.toString() + de(et.value); var et }).join(","), o += "|ob:", o += s.orderBy.map(c => function (et) { return et.field.canonicalString() + et.dir }(c)).join(","), se(s.limit) || (o += "|l:", o += s.limit), s.startAt && (o += "|lb:", o += s.startAt.inclusive ? "b:" : "a:", o += s.startAt.position.map(c => de(c)).join(",")), s.endAt && (o += "|ub:", o += s.endAt.inclusive ? "a:" : "b:", o += s.endAt.position.map(c => de(c)).join(",")), s.ht = o } return s.ht } function Ne(e) { let s = e.path.canonicalString(); return e.collectionGroup !== null && (s += " collectionGroup=" + e.collectionGroup), e.filters.length > 0 && (s += `, filters: [${e.filters.map(o => { return `${(c = o).field.canonicalString()} ${c.op} ${de(c.value)}`; var c }).join(", ")}]`), se(e.limit) || (s += ", limit: " + e.limit), e.orderBy.length > 0 && (s += `, orderBy: [${e.orderBy.map(o => function (c) { return `${c.field.canonicalString()} (${c.dir})` }(o)).join(", ")}]`), e.startAt && (s += ", startAt: ", s += e.startAt.inclusive ? "b:" : "a:", s += e.startAt.position.map(o => de(o)).join(",")), e.endAt && (s += ", endAt: ", s += e.endAt.inclusive ? "a:" : "b:", s += e.endAt.position.map(o => de(o)).join(",")), `Target(${s})` } function ke(e, s) { if (e.limit !== s.limit || e.orderBy.length !== s.orderBy.length) return !1; for (let et = 0; et < e.orderBy.length; et++)if (!Je(e.orderBy[et], s.orderBy[et])) return !1; if (e.filters.length !== s.filters.length) return !1; for (let et = 0; et < e.filters.length; et++)if (o = e.filters[et], c = s.filters[et], o.op !== c.op || !o.field.isEqual(c.field) || !ae(o.value, c.value)) return !1; var o, c; return e.collectionGroup === s.collectionGroup && !!e.path.isEqual(s.path) && !!Xe(e.startAt, s.startAt) && Xe(e.endAt, s.endAt) } class Be extends class { }{ constructor(s, o, c) { super(), this.field = s, this.op = o, this.value = c } static create(s, o, c) { return s.isKeyField() ? o === "in" || o === "not-in" ? this.lt(s, o, c) : new Le(s, o, c) : o === "array-contains" ? new Ge(s, c) : o === "in" ? new Qe(s, c) : o === "not-in" ? new je(s, c) : o === "array-contains-any" ? new We(s, c) : new Be(s, o, c) } static lt(s, o, c) { return o === "in" ? new Ue(s, c) : new qe(s, c) } matches(s) { const o = s.data.field(this.field); return this.op === "!=" ? o !== null && this.ft(le(o, this.value)) : o !== null && ce(this.value) === ce(o) && this.ft(le(o, this.value)) } ft(s) { switch (this.op) { case "<": return s < 0; case "<=": return s <= 0; case "==": return s === 0; case "!=": return s !== 0; case ">": return s > 0; case ">=": return s >= 0; default: return O() } } dt() { return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0 } } class Le extends Be { constructor(s, o, c) { super(s, o, c), this.key = ct.fromName(c.referenceValue) } matches(s) { const o = ct.comparator(s.key, this.key); return this.ft(o) } } class Ue extends Be { constructor(s, o) { super(s, "in", o), this.keys = Ke("in", o) } matches(s) { return this.keys.some(o => o.isEqual(s.key)) } } class qe extends Be { constructor(s, o) { super(s, "not-in", o), this.keys = Ke("not-in", o) } matches(s) { return !this.keys.some(o => o.isEqual(s.key)) } } function Ke(e, s) { var o; return (((o = s.arrayValue) === null || o === void 0 ? void 0 : o.values) || []).map(c => ct.fromName(c.referenceValue)) } class Ge extends Be { constructor(s, o) { super(s, "array-contains", o) } matches(s) { const o = s.data.field(this.field); return ge(o) && he(o.arrayValue, this.value) } } class Qe extends Be { constructor(s, o) { super(s, "in", o) } matches(s) { const o = s.data.field(this.field); return o !== null && he(this.value.arrayValue, o) } } class je extends Be { constructor(s, o) { super(s, "not-in", o) } matches(s) { if (he(this.value.arrayValue, { nullValue: "NULL_VALUE" })) return !1; const o = s.data.field(this.field); return o !== null && !he(this.value.arrayValue, o) } } class We extends Be { constructor(s, o) { super(s, "array-contains-any", o) } matches(s) { const o = s.data.field(this.field); return !(!ge(o) || !o.arrayValue.values) && o.arrayValue.values.some(c => he(this.value.arrayValue, c)) } } class ze { constructor(s, o) { this.position = s, this.inclusive = o } } class He { constructor(s, o = "asc") { this.field = s, this.dir = o } } function Je(e, s) { return e.dir === s.dir && e.field.isEqual(s.field) } function Ye(e, s, o) { let c = 0; for (let et = 0; et < e.position.length; et++) { const at = s[et], lt = e.position[et]; if (at.field.isKeyField() ? c = ct.comparator(ct.fromName(lt.referenceValue), o.key) : c = le(lt, o.data.field(at.field)), at.dir === "desc" && (c *= -1), c !== 0) break } return c } function Xe(e, s) { if (e === null) return s === null; if (s === null || e.inclusive !== s.inclusive || e.position.length !== s.position.length) return !1; for (let o = 0; o < e.position.length; o++)if (!ae(e.position[o], s.position[o])) return !1; return !0 }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Ze { constructor(s, o = null, c = [], et = [], at = null, lt = "F", ft = null, dt = null) { this.path = s, this.collectionGroup = o, this.explicitOrderBy = c, this.filters = et, this.limit = at, this.limitType = lt, this.startAt = ft, this.endAt = dt, this._t = null, this.wt = null, this.startAt, this.endAt } } function tn(e, s, o, c, et, at, lt, ft) { return new Ze(e, s, o, c, et, at, lt, ft) } function en(e) { return new Ze(e) } function nn(e) { return e.filters.length === 0 && e.limit === null && e.startAt == null && e.endAt == null && (e.explicitOrderBy.length === 0 || e.explicitOrderBy.length === 1 && e.explicitOrderBy[0].field.isKeyField()) } function sn(e) { return e.explicitOrderBy.length > 0 ? e.explicitOrderBy[0].field : null } function rn(e) { for (const s of e.filters) if (s.dt()) return s.field; return null } function on(e) { return e.collectionGroup !== null } function un(e) { const s = $(e); if (s._t === null) { s._t = []; const o = rn(s), c = sn(s); if (o !== null && c === null) o.isKeyField() || s._t.push(new He(o)), s._t.push(new He(ut.keyField(), "asc")); else { let et = !1; for (const at of s.explicitOrderBy) s._t.push(at), at.field.isKeyField() && (et = !0); if (!et) { const at = s.explicitOrderBy.length > 0 ? s.explicitOrderBy[s.explicitOrderBy.length - 1].dir : "asc"; s._t.push(new He(ut.keyField(), at)) } } } return s._t } function cn(e) { const s = $(e); if (!s.wt) if (s.limitType === "F") s.wt = Ce(s.path, s.collectionGroup, un(s), s.filters, s.limit, s.startAt, s.endAt); else { const o = []; for (const at of un(s)) { const lt = at.dir === "desc" ? "asc" : "desc"; o.push(new He(at.field, lt)) } const c = s.endAt ? new ze(s.endAt.position, s.endAt.inclusive) : null, et = s.startAt ? new ze(s.startAt.position, s.startAt.inclusive) : null; s.wt = Ce(s.path, s.collectionGroup, o, s.filters, s.limit, c, et) } return s.wt } function an(e, s, o) { return new Ze(e.path, e.collectionGroup, e.explicitOrderBy.slice(), e.filters.slice(), s, o, e.startAt, e.endAt) } function hn(e, s) { return ke(cn(e), cn(s)) && e.limitType === s.limitType } function ln(e) { return `${xe(cn(e))}|lt:${e.limitType}` } function fn(e) { return `Query(target=${Ne(cn(e))}; limitType=${e.limitType})` } function dn(e, s) { return s.isFoundDocument() && function (o, c) { const et = c.key.path; return o.collectionGroup !== null ? c.key.hasCollectionId(o.collectionGroup) && o.path.isPrefixOf(et) : ct.isDocumentKey(o.path) ? o.path.isEqual(et) : o.path.isImmediateParentOf(et) }(e, s) && function (o, c) { for (const et of o.explicitOrderBy) if (!et.field.isKeyField() && c.data.field(et.field) === null) return !1; return !0 }(e, s) && function (o, c) { for (const et of o.filters) if (!et.matches(c)) return !1; return !0 }(e, s) && function (o, c) { return !(o.startAt && !function (et, at, lt) { const ft = Ye(et, at, lt); return et.inclusive ? ft <= 0 : ft < 0 }(o.startAt, un(o), c) || o.endAt && !function (et, at, lt) { const ft = Ye(et, at, lt); return et.inclusive ? ft >= 0 : ft > 0 }(o.endAt, un(o), c)) }(e, s) } function wn(e) { return (s, o) => { let c = !1; for (const et of un(e)) { const at = mn(et, s, o); if (at !== 0) return at; c = c || et.field.isKeyField() } return 0 } } function mn(e, s, o) { const c = e.field.isKeyField() ? ct.comparator(s.key, o.key) : function (et, at, lt) { const ft = at.data.field(et), dt = lt.data.field(et); return ft !== null && dt !== null ? le(ft, dt) : O() }(e.field, s, o); switch (e.dir) { case "asc": return c; case "desc": return -1 * c; default: return O() } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function gn(e, s) { if (e.gt) { if (isNaN(s)) return { doubleValue: "NaN" }; if (s === 1 / 0) return { doubleValue: "Infinity" }; if (s === -1 / 0) return { doubleValue: "-Infinity" } } return { doubleValue: ie(s) ? "-0" : s } } function yn(e) { return { integerValue: "" + e } } function pn(e, s) { return re(s) ? yn(s) : gn(e, s) }/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class In { constructor() { this._ = void 0 } } function Tn(e, s, o) { return e instanceof Rn ? function (c, et) { const at = { fields: { __type__: { stringValue: "server_timestamp" }, __local_write_time__: { timestampValue: { seconds: c.seconds, nanos: c.nanoseconds } } } }; return et && (at.fields.__previous_value__ = et), { mapValue: at } }(o, s) : e instanceof bn ? Pn(e, s) : e instanceof vn ? Vn(e, s) : function (c, et) { const at = An(c, et), lt = Dn(at) + Dn(c.yt); return me(at) && me(c.yt) ? yn(lt) : gn(c.It, lt) }(e, s) } function En(e, s, o) { return e instanceof bn ? Pn(e, s) : e instanceof vn ? Vn(e, s) : o } function An(e, s) { return e instanceof Sn ? me(o = s) || function (c) { return !!c && "doubleValue" in c }(o) ? s : { integerValue: 0 } : null; var o } class Rn extends In { } class bn extends In { constructor(s) { super(), this.elements = s } } function Pn(e, s) { const o = Cn(s); for (const c of e.elements) o.some(et => ae(et, c)) || o.push(c); return { arrayValue: { values: o } } } class vn extends In { constructor(s) { super(), this.elements = s } } function Vn(e, s) { let o = Cn(s); for (const c of e.elements) o = o.filter(et => !ae(et, c)); return { arrayValue: { values: o } } } class Sn extends In { constructor(s, o) { super(), this.It = s, this.yt = o } } function Dn(e) { return Jt(e.integerValue || e.doubleValue) } function Cn(e) { return ge(e) && e.arrayValue.values ? e.arrayValue.values.slice() : [] } function Nn(e, s) { return e.field.isEqual(s.field) && function (o, c) { return o instanceof bn && c instanceof bn || o instanceof vn && c instanceof vn ? tt(o.elements, c.elements, ae) : o instanceof Sn && c instanceof Sn ? ae(o.yt, c.yt) : o instanceof Rn && c instanceof Rn }(e.transform, s.transform) } class kn { constructor(s, o) { this.version = s, this.transformResults = o } } class On { constructor(s, o) { this.updateTime = s, this.exists = o } static none() { return new On } static exists(s) { return new On(void 0, s) } static updateTime(s) { return new On(s) } get isNone() { return this.updateTime === void 0 && this.exists === void 0 } isEqual(s) { return this.exists === s.exists && (this.updateTime ? !!s.updateTime && this.updateTime.isEqual(s.updateTime) : !s.updateTime) } } function Mn(e, s) { return e.updateTime !== void 0 ? s.isFoundDocument() && s.version.isEqual(e.updateTime) : e.exists === void 0 || e.exists === s.isFoundDocument() } class Fn { } function $n(e, s) { if (!e.hasLocalMutations || s && s.fields.length === 0) return null; if (s === null) return e.isNoDocument() ? new zn(e.key, On.none()) : new Kn(e.key, e.data, On.none()); { const o = e.data, c = ve.empty(); let et = new qt(ut.comparator); for (let at of s.fields) if (!et.has(at)) { let lt = o.field(at); lt === null && at.length > 1 && (at = at.popLast(), lt = o.field(at)), lt === null ? c.delete(at) : c.set(at, lt), et = et.add(at) } return new Gn(e.key, c, new Qt(et.toArray()), On.none()) } } function Bn(e, s, o) { e instanceof Kn ? function (c, et, at) { const lt = c.value.clone(), ft = jn(c.fieldTransforms, et, at.transformResults); lt.setAll(ft), et.convertToFoundDocument(at.version, lt).setHasCommittedMutations() }(e, s, o) : e instanceof Gn ? function (c, et, at) { if (!Mn(c.precondition, et)) return void et.convertToUnknownDocument(at.version); const lt = jn(c.fieldTransforms, et, at.transformResults), ft = et.data; ft.setAll(Qn(c)), ft.setAll(lt), et.convertToFoundDocument(at.version, ft).setHasCommittedMutations() }(e, s, o) : function (c, et, at) { et.convertToNoDocument(at.version).setHasCommittedMutations() }(0, s, o) } function Ln(e, s, o, c) { return e instanceof Kn ? function (et, at, lt, ft) { if (!Mn(et.precondition, at)) return lt; const dt = et.value.clone(), ht = Wn(et.fieldTransforms, ft, at); return dt.setAll(ht), at.convertToFoundDocument(at.version, dt).setHasLocalMutations(), null }(e, s, o, c) : e instanceof Gn ? function (et, at, lt, ft) { if (!Mn(et.precondition, at)) return lt; const dt = Wn(et.fieldTransforms, ft, at), ht = at.data; return ht.setAll(Qn(et)), ht.setAll(dt), at.convertToFoundDocument(at.version, ht).setHasLocalMutations(), lt === null ? null : lt.unionWith(et.fieldMask.fields).unionWith(et.fieldTransforms.map(vt => vt.field)) }(e, s, o, c) : function (et, at, lt) { return Mn(et.precondition, at) ? (at.convertToNoDocument(at.version).setHasLocalMutations(), null) : lt }(e, s, o) } function Un(e, s) { let o = null; for (const c of e.fieldTransforms) { const et = s.data.field(c.field), at = An(c.transform, et || null); at != null && (o === null && (o = ve.empty()), o.set(c.field, at)) } return o || null } function qn(e, s) { return e.type === s.type && !!e.key.isEqual(s.key) && !!e.precondition.isEqual(s.precondition) && !!function (o, c) { return o === void 0 && c === void 0 || !(!o || !c) && tt(o, c, (et, at) => Nn(et, at)) }(e.fieldTransforms, s.fieldTransforms) && (e.type === 0 ? e.value.isEqual(s.value) : e.type !== 1 || e.data.isEqual(s.data) && e.fieldMask.isEqual(s.fieldMask)) } class Kn extends Fn { constructor(s, o, c, et = []) { super(), this.key = s, this.value = o, this.precondition = c, this.fieldTransforms = et, this.type = 0 } getFieldMask() { return null } } class Gn extends Fn { constructor(s, o, c, et, at = []) { super(), this.key = s, this.data = o, this.fieldMask = c, this.precondition = et, this.fieldTransforms = at, this.type = 1 } getFieldMask() { return this.fieldMask } } function Qn(e) { const s = new Map; return e.fieldMask.fields.forEach(o => { if (!o.isEmpty()) { const c = e.data.field(o); s.set(o, c) } }), s } function jn(e, s, o) { const c = new Map; M(e.length === o.length); for (let et = 0; et < o.length; et++) { const at = e[et], lt = at.transform, ft = s.data.field(at.field); c.set(at.field, En(lt, ft, o[et])) } return c } function Wn(e, s, o) { const c = new Map; for (const et of e) { const at = et.transform, lt = o.data.field(et.field); c.set(et.field, Tn(at, lt, s)) } return c } class zn extends Fn { constructor(s, o) { super(), this.key = s, this.precondition = o, this.type = 2, this.fieldTransforms = [] } getFieldMask() { return null } } class Hn extends Fn { constructor(s, o) { super(), this.key = s, this.precondition = o, this.type = 3, this.fieldTransforms = [] } getFieldMask() { return null } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var Yn, Xn; function Zn(e) { switch (e) { default: return O(); case B.CANCELLED: case B.UNKNOWN: case B.DEADLINE_EXCEEDED: case B.RESOURCE_EXHAUSTED: case B.INTERNAL: case B.UNAVAILABLE: case B.UNAUTHENTICATED: return !1; case B.INVALID_ARGUMENT: case B.NOT_FOUND: case B.ALREADY_EXISTS: case B.PERMISSION_DENIED: case B.FAILED_PRECONDITION: case B.ABORTED: case B.OUT_OF_RANGE: case B.UNIMPLEMENTED: case B.DATA_LOSS: return !0 } } function ts(e) { if (e === void 0) return x("GRPC error has no .code"), B.UNKNOWN; switch (e) { case Yn.OK: return B.OK; case Yn.CANCELLED: return B.CANCELLED; case Yn.UNKNOWN: return B.UNKNOWN; case Yn.DEADLINE_EXCEEDED: return B.DEADLINE_EXCEEDED; case Yn.RESOURCE_EXHAUSTED: return B.RESOURCE_EXHAUSTED; case Yn.INTERNAL: return B.INTERNAL; case Yn.UNAVAILABLE: return B.UNAVAILABLE; case Yn.UNAUTHENTICATED: return B.UNAUTHENTICATED; case Yn.INVALID_ARGUMENT: return B.INVALID_ARGUMENT; case Yn.NOT_FOUND: return B.NOT_FOUND; case Yn.ALREADY_EXISTS: return B.ALREADY_EXISTS; case Yn.PERMISSION_DENIED: return B.PERMISSION_DENIED; case Yn.FAILED_PRECONDITION: return B.FAILED_PRECONDITION; case Yn.ABORTED: return B.ABORTED; case Yn.OUT_OF_RANGE: return B.OUT_OF_RANGE; case Yn.UNIMPLEMENTED: return B.UNIMPLEMENTED; case Yn.DATA_LOSS: return B.DATA_LOSS; default: return O() } } (Xn = Yn || (Yn = {}))[Xn.OK = 0] = "OK", Xn[Xn.CANCELLED = 1] = "CANCELLED", Xn[Xn.UNKNOWN = 2] = "UNKNOWN", Xn[Xn.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", Xn[Xn.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", Xn[Xn.NOT_FOUND = 5] = "NOT_FOUND", Xn[Xn.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", Xn[Xn.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", Xn[Xn.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", Xn[Xn.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", Xn[Xn.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", Xn[Xn.ABORTED = 10] = "ABORTED", Xn[Xn.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", Xn[Xn.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", Xn[Xn.INTERNAL = 13] = "INTERNAL", Xn[Xn.UNAVAILABLE = 14] = "UNAVAILABLE", Xn[Xn.DATA_LOSS = 15] = "DATA_LOSS";/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class es { constructor(s, o) { this.mapKeyFn = s, this.equalsFn = o, this.inner = {}, this.innerSize = 0 } get(s) { const o = this.mapKeyFn(s), c = this.inner[o]; if (c !== void 0) { for (const [et, at] of c) if (this.equalsFn(et, s)) return at } } has(s) { return this.get(s) !== void 0 } set(s, o) { const c = this.mapKeyFn(s), et = this.inner[c]; if (et === void 0) return this.inner[c] = [[s, o]], void this.innerSize++; for (let at = 0; at < et.length; at++)if (this.equalsFn(et[at][0], s)) return void (et[at] = [s, o]); et.push([s, o]), this.innerSize++ } delete(s) { const o = this.mapKeyFn(s), c = this.inner[o]; if (c === void 0) return !1; for (let et = 0; et < c.length; et++)if (this.equalsFn(c[et][0], s)) return c.length === 1 ? delete this.inner[o] : c.splice(et, 1), this.innerSize--, !0; return !1 } forEach(s) { Ft(this.inner, (o, c) => { for (const [et, at] of c) s(et, at) }) } isEmpty() { return $t(this.inner) } size() { return this.innerSize } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const ns = new Bt(ct.comparator); function ss() { return ns } const is = new Bt(ct.comparator); function rs(...e) { let s = is; for (const o of e) s = s.insert(o.key, o); return s } function os(e) { let s = is; return e.forEach((o, c) => s = s.insert(o, c.overlayedDocument)), s } function us() { return as() } function cs() { return as() } function as() { return new es(e => e.toString(), (e, s) => e.isEqual(s)) } const hs = new Bt(ct.comparator), ls = new qt(ct.comparator); function fs(...e) { let s = ls; for (const o of e) s = s.add(o); return s } const ds = new qt(Z); function _s() { return ds } class Ps { constructor(s, o) { this.databaseId = s, this.gt = o } } function vs(e, s) { return e.gt ? `${new Date(1e3 * s.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + s.nanoseconds).slice(-9)}Z` : { seconds: "" + s.seconds, nanos: s.nanoseconds } } function Vs(e, s) { return e.gt ? s.toBase64() : s.toUint8Array() } function Ss(e, s) { return vs(e, s.toTimestamp()) } function Ds(e) { return M(!!e), st.fromTimestamp(function (s) { const o = Ht(s); return new nt(o.seconds, o.nanos) }(e)) } function Cs(e, s) { return function (o) { return new rt(["projects", o.projectId, "databases", o.database]) }(e).child("documents").child(s).canonicalString() } function xs(e) { const s = rt.fromString(e); return M(ii(s)), s } function Ns(e, s) { return Cs(e.databaseId, s.path) } function Ms(e) { const s = xs(e); return s.length === 4 ? rt.emptyPath() : $s(s) } function Fs(e) { return new rt(["projects", e.databaseId.projectId, "databases", e.databaseId.database]).canonicalString() } function $s(e) { return M(e.length > 4 && e.get(4) === "documents"), e.popFirst(5) } function Bs(e, s, o) { return { name: Ns(e, s), fields: o.value.mapValue.fields } } function Ks(e, s) { let o; if (s instanceof Kn) o = { update: Bs(e, s.key, s.value) }; else if (s instanceof zn) o = { delete: Ns(e, s.key) }; else if (s instanceof Gn) o = { update: Bs(e, s.key, s.data), updateMask: si(s.fieldMask) }; else { if (!(s instanceof Hn)) return O(); o = { verify: Ns(e, s.key) } } return s.fieldTransforms.length > 0 && (o.updateTransforms = s.fieldTransforms.map(c => function (et, at) { const lt = at.transform; if (lt instanceof Rn) return { fieldPath: at.field.canonicalString(), setToServerValue: "REQUEST_TIME" }; if (lt instanceof bn) return { fieldPath: at.field.canonicalString(), appendMissingElements: { values: lt.elements } }; if (lt instanceof vn) return { fieldPath: at.field.canonicalString(), removeAllFromArray: { values: lt.elements } }; if (lt instanceof Sn) return { fieldPath: at.field.canonicalString(), increment: lt.yt }; throw O() }(0, c))), s.precondition.isNone || (o.currentDocument = function (c, et) { return et.updateTime !== void 0 ? { updateTime: Ss(c, et.updateTime) } : et.exists !== void 0 ? { exists: et.exists } : O() }(e, s.precondition)), o } function Qs(e, s) { return e && e.length > 0 ? (M(s !== void 0), e.map(o => function (c, et) { let at = c.updateTime ? Ds(c.updateTime) : Ds(et); return at.isEqual(st.min()) && (at = Ds(et)), new kn(at, c.transformResults || []) }(o, s))) : [] } function zs(e) { let s = Ms(e.parent); const o = e.structuredQuery, c = o.from ? o.from.length : 0; let et = null; if (c > 0) { M(c === 1); const vt = o.from[0]; vt.allDescendants ? et = vt.collectionId : s = s.child(vt.collectionId) } let at = []; o.where && (at = Js(o.where)); let lt = []; o.orderBy && (lt = o.orderBy.map(vt => function (wt) { return new He(ti(wt.field), function (St) { switch (St) { case "ASCENDING": return "asc"; case "DESCENDING": return "desc"; default: return } }(wt.direction)) }(vt))); let ft = null; o.limit && (ft = function (vt) { let wt; return wt = typeof vt == "object" ? vt.value : vt, se(wt) ? null : wt }(o.limit)); let dt = null; o.startAt && (dt = function (vt) { const wt = !!vt.before, St = vt.values || []; return new ze(St, wt) }(o.startAt)); let ht = null; return o.endAt && (ht = function (vt) { const wt = !vt.before, St = vt.values || []; return new ze(St, wt) }(o.endAt)), tn(s, et, lt, at, ft, "F", dt, ht) } function Js(e) { return e ? e.unaryFilter !== void 0 ? [ni(e)] : e.fieldFilter !== void 0 ? [ei(e)] : e.compositeFilter !== void 0 ? e.compositeFilter.filters.map(s => Js(s)).reduce((s, o) => s.concat(o)) : O() : [] } function ti(e) { return ut.fromServerFormat(e.fieldPath) } function ei(e) { return Be.create(ti(e.fieldFilter.field), function (s) { switch (s) { case "EQUAL": return "=="; case "NOT_EQUAL": return "!="; case "GREATER_THAN": return ">"; case "GREATER_THAN_OR_EQUAL": return ">="; case "LESS_THAN": return "<"; case "LESS_THAN_OR_EQUAL": return "<="; case "ARRAY_CONTAINS": return "array-contains"; case "IN": return "in"; case "NOT_IN": return "not-in"; case "ARRAY_CONTAINS_ANY": return "array-contains-any"; default: return O() } }(e.fieldFilter.op), e.fieldFilter.value) } function ni(e) { switch (e.unaryFilter.op) { case "IS_NAN": const s = ti(e.unaryFilter.field); return Be.create(s, "==", { doubleValue: NaN }); case "IS_NULL": const o = ti(e.unaryFilter.field); return Be.create(o, "==", { nullValue: "NULL_VALUE" }); case "IS_NOT_NAN": const c = ti(e.unaryFilter.field); return Be.create(c, "!=", { doubleValue: NaN }); case "IS_NOT_NULL": const et = ti(e.unaryFilter.field); return Be.create(et, "!=", { nullValue: "NULL_VALUE" }); default: return O() } } function si(e) { const s = []; return e.fields.forEach(o => s.push(o.canonicalString())), { fieldPaths: s } } function ii(e) { return e.length >= 4 && e.get(0) === "projects" && e.get(2) === "databases" }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class ki { constructor(s, o, c, et) { this.batchId = s, this.localWriteTime = o, this.baseMutations = c, this.mutations = et } applyToRemoteDocument(s, o) { const c = o.mutationResults; for (let et = 0; et < this.mutations.length; et++) { const at = this.mutations[et]; at.key.isEqual(s.key) && Bn(at, s, c[et]) } } applyToLocalView(s, o) { for (const c of this.baseMutations) c.key.isEqual(s.key) && (o = Ln(c, s, o, this.localWriteTime)); for (const c of this.mutations) c.key.isEqual(s.key) && (o = Ln(c, s, o, this.localWriteTime)); return o } applyToLocalDocumentSet(s, o) { const c = cs(); return this.mutations.forEach(et => { const at = s.get(et.key), lt = at.overlayedDocument; let ft = this.applyToLocalView(lt, at.mutatedFields); ft = o.has(et.key) ? null : ft; const dt = $n(lt, ft); dt !== null && c.set(et.key, dt), lt.isValidDocument() || lt.convertToNoDocument(st.min()) }), c } keys() { return this.mutations.reduce((s, o) => s.add(o.key), fs()) } isEqual(s) { return this.batchId === s.batchId && tt(this.mutations, s.mutations, (o, c) => qn(o, c)) && tt(this.baseMutations, s.baseMutations, (o, c) => qn(o, c)) } } class Oi { constructor(s, o, c, et) { this.batch = s, this.commitVersion = o, this.mutationResults = c, this.docVersions = et } static from(s, o, c) { M(s.mutations.length === c.length); let et = hs; const at = s.mutations; for (let lt = 0; lt < at.length; lt++)et = et.insert(at[lt].key, c[lt].version); return new Oi(s, o, c, et) } }/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Mi {
	constructor(s, o) { this.largestBatchId = s, this.mutation = o } getKey() { return this.mutation.key } isEqual(s) { return s !== null && this.mutation === s.mutation } toString() {
		return `Overlay{
      largestBatchId: ${this.largestBatchId},
      mutation: ${this.mutation.toString()}
    }`}
}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class $i { constructor(s) { this.re = s } } function Wi(e) { const s = zs({ parent: e.parent, structuredQuery: e.structuredQuery }); return e.limitType === "LAST" ? an(s, s.limit, "L") : s }/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class dr { constructor() { this.Ye = new _r } addToCollectionParentIndex(s, o) { return this.Ye.add(o), At.resolve() } getCollectionParents(s, o) { return At.resolve(this.Ye.getEntries(o)) } addFieldIndex(s, o) { return At.resolve() } deleteFieldIndex(s, o) { return At.resolve() } getDocumentsMatchingTarget(s, o) { return At.resolve(null) } getIndexType(s, o) { return At.resolve(0) } getFieldIndexes(s, o) { return At.resolve([]) } getNextCollectionGroupToUpdate(s) { return At.resolve(null) } getMinOffset(s, o) { return At.resolve(yt.min()) } getMinOffsetFromCollectionGroup(s, o) { return At.resolve(yt.min()) } updateCollectionGroup(s, o, c) { return At.resolve() } updateIndexEntries(s, o) { return At.resolve() } } class _r { constructor() { this.index = {} } add(s) { const o = s.lastSegment(), c = s.popLast(), et = this.index[o] || new qt(rt.comparator), at = !et.has(c); return this.index[o] = et.add(c), at } has(s) { const o = s.lastSegment(), c = s.popLast(), et = this.index[o]; return et && et.has(c) } getEntries(s) { return (this.index[s] || new qt(rt.comparator)).toArray() } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Cr { constructor(s) { this.bn = s } next() { return this.bn += 2, this.bn } static Pn() { return new Cr(0) } static vn() { return new Cr(-1) } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class qr { constructor() { this.changes = new es(s => s.toString(), (s, o) => s.isEqual(o)), this.changesApplied = !1 } addEntry(s) { this.assertNotApplied(), this.changes.set(s.key, s) } removeEntry(s, o) { this.assertNotApplied(), this.changes.set(s, Se.newInvalidDocument(s).setReadTime(o)) } getEntry(s, o) { this.assertNotApplied(); const c = this.changes.get(o); return c !== void 0 ? At.resolve(c) : this.getFromCache(s, o) } getEntries(s, o) { return this.getAllFromCache(s, o) } apply(s) { return this.assertNotApplied(), this.changesApplied = !0, this.applyChanges(s) } assertNotApplied() { } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Yr { constructor(s, o) { this.overlayedDocument = s, this.mutatedFields = o } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Xr { constructor(s, o, c, et) { this.remoteDocumentCache = s, this.mutationQueue = o, this.documentOverlayCache = c, this.indexManager = et } getDocument(s, o) { let c = null; return this.documentOverlayCache.getOverlay(s, o).next(et => (c = et, this.getBaseDocument(s, o, c))).next(et => (c !== null && Ln(c.mutation, et, Qt.empty(), nt.now()), et)) } getDocuments(s, o) { return this.remoteDocumentCache.getEntries(s, o).next(c => this.getLocalViewOfDocuments(s, c, fs()).next(() => c)) } getLocalViewOfDocuments(s, o, c = fs()) { const et = us(); return this.populateOverlays(s, et, o).next(() => this.computeViews(s, o, et, c).next(at => { let lt = rs(); return at.forEach((ft, dt) => { lt = lt.insert(ft, dt.overlayedDocument) }), lt })) } getOverlayedDocuments(s, o) { const c = us(); return this.populateOverlays(s, c, o).next(() => this.computeViews(s, o, c, fs())) } populateOverlays(s, o, c) { const et = []; return c.forEach(at => { o.has(at) || et.push(at) }), this.documentOverlayCache.getOverlays(s, et).next(at => { at.forEach((lt, ft) => { o.set(lt, ft) }) }) } computeViews(s, o, c, et) { let at = ss(); const lt = as(), ft = as(); return o.forEach((dt, ht) => { const vt = c.get(ht.key); et.has(ht.key) && (vt === void 0 || vt.mutation instanceof Gn) ? at = at.insert(ht.key, ht) : vt !== void 0 && (lt.set(ht.key, vt.mutation.getFieldMask()), Ln(vt.mutation, ht, vt.mutation.getFieldMask(), nt.now())) }), this.recalculateAndSaveOverlays(s, at).next(dt => (dt.forEach((ht, vt) => lt.set(ht, vt)), o.forEach((ht, vt) => { var wt; return ft.set(ht, new Yr(vt, (wt = lt.get(ht)) !== null && wt !== void 0 ? wt : null)) }), ft)) } recalculateAndSaveOverlays(s, o) { const c = as(); let et = new Bt((lt, ft) => lt - ft), at = fs(); return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(s, o).next(lt => { for (const ft of lt) ft.keys().forEach(dt => { const ht = o.get(dt); if (ht === null) return; let vt = c.get(dt) || Qt.empty(); vt = ft.applyToLocalView(ht, vt), c.set(dt, vt); const wt = (et.get(ft.batchId) || fs()).add(dt); et = et.insert(ft.batchId, wt) }) }).next(() => { const lt = [], ft = et.getReverseIterator(); for (; ft.hasNext();) { const dt = ft.getNext(), ht = dt.key, vt = dt.value, wt = cs(); vt.forEach(St => { if (!at.has(St)) { const _t = $n(o.get(St), c.get(St)); _t !== null && wt.set(St, _t), at = at.add(St) } }), lt.push(this.documentOverlayCache.saveOverlays(s, ht, wt)) } return At.waitFor(lt) }).next(() => c) } recalculateAndSaveOverlaysForDocumentKeys(s, o) { return this.remoteDocumentCache.getEntries(s, o).next(c => this.recalculateAndSaveOverlays(s, c)) } getDocumentsMatchingQuery(s, o, c) { return function (et) { return ct.isDocumentKey(et.path) && et.collectionGroup === null && et.filters.length === 0 }(o) ? this.getDocumentsMatchingDocumentQuery(s, o.path) : on(o) ? this.getDocumentsMatchingCollectionGroupQuery(s, o, c) : this.getDocumentsMatchingCollectionQuery(s, o, c) } getNextDocuments(s, o, c, et) { return this.remoteDocumentCache.getAllFromCollectionGroup(s, o, c, et).next(at => { const lt = et - at.size > 0 ? this.documentOverlayCache.getOverlaysForCollectionGroup(s, o, c.largestBatchId, et - at.size) : At.resolve(us()); let ft = -1, dt = at; return lt.next(ht => At.forEach(ht, (vt, wt) => (ft < wt.largestBatchId && (ft = wt.largestBatchId), at.get(vt) ? At.resolve() : this.getBaseDocument(s, vt, wt).next(St => { dt = dt.insert(vt, St) }))).next(() => this.populateOverlays(s, ht, at)).next(() => this.computeViews(s, dt, ht, fs())).next(vt => ({ batchId: ft, changes: os(vt) }))) }) } getDocumentsMatchingDocumentQuery(s, o) { return this.getDocument(s, new ct(o)).next(c => { let et = rs(); return c.isFoundDocument() && (et = et.insert(c.key, c)), et }) } getDocumentsMatchingCollectionGroupQuery(s, o, c) { const et = o.collectionGroup; let at = rs(); return this.indexManager.getCollectionParents(s, et).next(lt => At.forEach(lt, ft => { const dt = function (ht, vt) { return new Ze(vt, null, ht.explicitOrderBy.slice(), ht.filters.slice(), ht.limit, ht.limitType, ht.startAt, ht.endAt) }(o, ft.child(et)); return this.getDocumentsMatchingCollectionQuery(s, dt, c).next(ht => { ht.forEach((vt, wt) => { at = at.insert(vt, wt) }) }) }).next(() => at)) } getDocumentsMatchingCollectionQuery(s, o, c) { let et; return this.remoteDocumentCache.getAllFromCollection(s, o.path, c).next(at => (et = at, this.documentOverlayCache.getOverlaysForCollection(s, o.path, c.largestBatchId))).next(at => { at.forEach((ft, dt) => { const ht = dt.getKey(); et.get(ht) === null && (et = et.insert(ht, Se.newInvalidDocument(ht))) }); let lt = rs(); return et.forEach((ft, dt) => { const ht = at.get(ft); ht !== void 0 && Ln(ht.mutation, dt, Qt.empty(), nt.now()), dn(o, dt) && (lt = lt.insert(ft, dt)) }), lt }) } getBaseDocument(s, o, c) { return c === null || c.mutation.type === 1 ? this.remoteDocumentCache.getEntry(s, o) : At.resolve(Se.newInvalidDocument(o)) } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Zr { constructor(s) { this.It = s, this.Zn = new Map, this.ts = new Map } getBundleMetadata(s, o) { return At.resolve(this.Zn.get(o)) } saveBundleMetadata(s, o) { var c; return this.Zn.set(o.id, { id: (c = o).id, version: c.version, createTime: Ds(c.createTime) }), At.resolve() } getNamedQuery(s, o) { return At.resolve(this.ts.get(o)) } saveNamedQuery(s, o) { return this.ts.set(o.name, function (c) { return { name: c.name, query: Wi(c.bundledQuery), readTime: Ds(c.readTime) } }(o)), At.resolve() } }/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class to { constructor() { this.overlays = new Bt(ct.comparator), this.es = new Map } getOverlay(s, o) { return At.resolve(this.overlays.get(o)) } getOverlays(s, o) { const c = us(); return At.forEach(o, et => this.getOverlay(s, et).next(at => { at !== null && c.set(et, at) })).next(() => c) } saveOverlays(s, o, c) { return c.forEach((et, at) => { this.ue(s, o, at) }), At.resolve() } removeOverlaysForBatchId(s, o, c) { const et = this.es.get(c); return et !== void 0 && (et.forEach(at => this.overlays = this.overlays.remove(at)), this.es.delete(c)), At.resolve() } getOverlaysForCollection(s, o, c) { const et = us(), at = o.length + 1, lt = new ct(o.child("")), ft = this.overlays.getIteratorFrom(lt); for (; ft.hasNext();) { const dt = ft.getNext().value, ht = dt.getKey(); if (!o.isPrefixOf(ht.path)) break; ht.path.length === at && dt.largestBatchId > c && et.set(dt.getKey(), dt) } return At.resolve(et) } getOverlaysForCollectionGroup(s, o, c, et) { let at = new Bt((ht, vt) => ht - vt); const lt = this.overlays.getIterator(); for (; lt.hasNext();) { const ht = lt.getNext().value; if (ht.getKey().getCollectionGroup() === o && ht.largestBatchId > c) { let vt = at.get(ht.largestBatchId); vt === null && (vt = us(), at = at.insert(ht.largestBatchId, vt)), vt.set(ht.getKey(), ht) } } const ft = us(), dt = at.getIterator(); for (; dt.hasNext() && (dt.getNext().value.forEach((ht, vt) => ft.set(ht, vt)), !(ft.size() >= et));); return At.resolve(ft) } ue(s, o, c) { const et = this.overlays.get(c.key); if (et !== null) { const lt = this.es.get(et.largestBatchId).delete(c.key); this.es.set(et.largestBatchId, lt) } this.overlays = this.overlays.insert(c.key, new Mi(o, c)); let at = this.es.get(o); at === void 0 && (at = fs(), this.es.set(o, at)), this.es.set(o, at.add(c.key)) } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class eo { constructor() { this.ns = new qt(no.ss), this.rs = new qt(no.os) } isEmpty() { return this.ns.isEmpty() } addReference(s, o) { const c = new no(s, o); this.ns = this.ns.add(c), this.rs = this.rs.add(c) } us(s, o) { s.forEach(c => this.addReference(c, o)) } removeReference(s, o) { this.cs(new no(s, o)) } hs(s, o) { s.forEach(c => this.removeReference(c, o)) } ls(s) { const o = new ct(new rt([])), c = new no(o, s), et = new no(o, s + 1), at = []; return this.rs.forEachInRange([c, et], lt => { this.cs(lt), at.push(lt.key) }), at } fs() { this.ns.forEach(s => this.cs(s)) } cs(s) { this.ns = this.ns.delete(s), this.rs = this.rs.delete(s) } ds(s) { const o = new ct(new rt([])), c = new no(o, s), et = new no(o, s + 1); let at = fs(); return this.rs.forEachInRange([c, et], lt => { at = at.add(lt.key) }), at } containsKey(s) { const o = new no(s, 0), c = this.ns.firstAfterOrEqual(o); return c !== null && s.isEqual(c.key) } } class no { constructor(s, o) { this.key = s, this._s = o } static ss(s, o) { return ct.comparator(s.key, o.key) || Z(s._s, o._s) } static os(s, o) { return Z(s._s, o._s) || ct.comparator(s.key, o.key) } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class so { constructor(s, o) { this.indexManager = s, this.referenceDelegate = o, this.mutationQueue = [], this.ws = 1, this.gs = new qt(no.ss) } checkEmpty(s) { return At.resolve(this.mutationQueue.length === 0) } addMutationBatch(s, o, c, et) { const at = this.ws; this.ws++, this.mutationQueue.length > 0 && this.mutationQueue[this.mutationQueue.length - 1]; const lt = new ki(at, o, c, et); this.mutationQueue.push(lt); for (const ft of et) this.gs = this.gs.add(new no(ft.key, at)), this.indexManager.addToCollectionParentIndex(s, ft.key.path.popLast()); return At.resolve(lt) } lookupMutationBatch(s, o) { return At.resolve(this.ys(o)) } getNextMutationBatchAfterBatchId(s, o) { const c = o + 1, et = this.ps(c), at = et < 0 ? 0 : et; return At.resolve(this.mutationQueue.length > at ? this.mutationQueue[at] : null) } getHighestUnacknowledgedBatchId() { return At.resolve(this.mutationQueue.length === 0 ? -1 : this.ws - 1) } getAllMutationBatches(s) { return At.resolve(this.mutationQueue.slice()) } getAllMutationBatchesAffectingDocumentKey(s, o) { const c = new no(o, 0), et = new no(o, Number.POSITIVE_INFINITY), at = []; return this.gs.forEachInRange([c, et], lt => { const ft = this.ys(lt._s); at.push(ft) }), At.resolve(at) } getAllMutationBatchesAffectingDocumentKeys(s, o) { let c = new qt(Z); return o.forEach(et => { const at = new no(et, 0), lt = new no(et, Number.POSITIVE_INFINITY); this.gs.forEachInRange([at, lt], ft => { c = c.add(ft._s) }) }), At.resolve(this.Is(c)) } getAllMutationBatchesAffectingQuery(s, o) { const c = o.path, et = c.length + 1; let at = c; ct.isDocumentKey(at) || (at = at.child("")); const lt = new no(new ct(at), 0); let ft = new qt(Z); return this.gs.forEachWhile(dt => { const ht = dt.key.path; return !!c.isPrefixOf(ht) && (ht.length === et && (ft = ft.add(dt._s)), !0) }, lt), At.resolve(this.Is(ft)) } Is(s) { const o = []; return s.forEach(c => { const et = this.ys(c); et !== null && o.push(et) }), o } removeMutationBatch(s, o) { M(this.Ts(o.batchId, "removed") === 0), this.mutationQueue.shift(); let c = this.gs; return At.forEach(o.mutations, et => { const at = new no(et.key, o.batchId); return c = c.delete(at), this.referenceDelegate.markPotentiallyOrphaned(s, et.key) }).next(() => { this.gs = c }) } An(s) { } containsKey(s, o) { const c = new no(o, 0), et = this.gs.firstAfterOrEqual(c); return At.resolve(o.isEqual(et && et.key)) } performConsistencyCheck(s) { return this.mutationQueue.length, At.resolve() } Ts(s, o) { return this.ps(s) } ps(s) { return this.mutationQueue.length === 0 ? 0 : s - this.mutationQueue[0].batchId } ys(s) { const o = this.ps(s); return o < 0 || o >= this.mutationQueue.length ? null : this.mutationQueue[o] } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class io { constructor(s) { this.Es = s, this.docs = new Bt(ct.comparator), this.size = 0 } setIndexManager(s) { this.indexManager = s } addEntry(s, o) { const c = o.key, et = this.docs.get(c), at = et ? et.size : 0, lt = this.Es(o); return this.docs = this.docs.insert(c, { document: o.mutableCopy(), size: lt }), this.size += lt - at, this.indexManager.addToCollectionParentIndex(s, c.path.popLast()) } removeEntry(s) { const o = this.docs.get(s); o && (this.docs = this.docs.remove(s), this.size -= o.size) } getEntry(s, o) { const c = this.docs.get(o); return At.resolve(c ? c.document.mutableCopy() : Se.newInvalidDocument(o)) } getEntries(s, o) { let c = ss(); return o.forEach(et => { const at = this.docs.get(et); c = c.insert(et, at ? at.document.mutableCopy() : Se.newInvalidDocument(et)) }), At.resolve(c) } getAllFromCollection(s, o, c) { let et = ss(); const at = new ct(o.child("")), lt = this.docs.getIteratorFrom(at); for (; lt.hasNext();) { const { key: ft, value: { document: dt } } = lt.getNext(); if (!o.isPrefixOf(ft.path)) break; ft.path.length > o.length + 1 || pt(gt(dt), c) <= 0 || (et = et.insert(dt.key, dt.mutableCopy())) } return At.resolve(et) } getAllFromCollectionGroup(s, o, c, et) { O() } As(s, o) { return At.forEach(this.docs, c => o(c)) } newChangeBuffer(s) { return new ro(this) } getSize(s) { return At.resolve(this.size) } } class ro extends qr { constructor(s) { super(), this.Yn = s } applyChanges(s) { const o = []; return this.changes.forEach((c, et) => { et.isValidDocument() ? o.push(this.Yn.addEntry(s, et)) : this.Yn.removeEntry(c) }), At.waitFor(o) } getFromCache(s, o) { return this.Yn.getEntry(s, o) } getAllFromCache(s, o) { return this.Yn.getEntries(s, o) } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class oo { constructor(s) { this.persistence = s, this.Rs = new es(o => xe(o), ke), this.lastRemoteSnapshotVersion = st.min(), this.highestTargetId = 0, this.bs = 0, this.Ps = new eo, this.targetCount = 0, this.vs = Cr.Pn() } forEachTarget(s, o) { return this.Rs.forEach((c, et) => o(et)), At.resolve() } getLastRemoteSnapshotVersion(s) { return At.resolve(this.lastRemoteSnapshotVersion) } getHighestSequenceNumber(s) { return At.resolve(this.bs) } allocateTargetId(s) { return this.highestTargetId = this.vs.next(), At.resolve(this.highestTargetId) } setTargetsMetadata(s, o, c) { return c && (this.lastRemoteSnapshotVersion = c), o > this.bs && (this.bs = o), At.resolve() } Dn(s) { this.Rs.set(s.target, s); const o = s.targetId; o > this.highestTargetId && (this.vs = new Cr(o), this.highestTargetId = o), s.sequenceNumber > this.bs && (this.bs = s.sequenceNumber) } addTargetData(s, o) { return this.Dn(o), this.targetCount += 1, At.resolve() } updateTargetData(s, o) { return this.Dn(o), At.resolve() } removeTargetData(s, o) { return this.Rs.delete(o.target), this.Ps.ls(o.targetId), this.targetCount -= 1, At.resolve() } removeTargets(s, o, c) { let et = 0; const at = []; return this.Rs.forEach((lt, ft) => { ft.sequenceNumber <= o && c.get(ft.targetId) === null && (this.Rs.delete(lt), at.push(this.removeMatchingKeysForTargetId(s, ft.targetId)), et++) }), At.waitFor(at).next(() => et) } getTargetCount(s) { return At.resolve(this.targetCount) } getTargetData(s, o) { const c = this.Rs.get(o) || null; return At.resolve(c) } addMatchingKeys(s, o, c) { return this.Ps.us(o, c), At.resolve() } removeMatchingKeys(s, o, c) { this.Ps.hs(o, c); const et = this.persistence.referenceDelegate, at = []; return et && o.forEach(lt => { at.push(et.markPotentiallyOrphaned(s, lt)) }), At.waitFor(at) } removeMatchingKeysForTargetId(s, o) { return this.Ps.ls(o), At.resolve() } getMatchingKeysForTargetId(s, o) { const c = this.Ps.ds(o); return At.resolve(c) } containsKey(s, o) { return At.resolve(this.Ps.containsKey(o)) } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class uo { constructor(s, o) { this.Vs = {}, this.overlays = {}, this.Ss = new Ot(0), this.Ds = !1, this.Ds = !0, this.referenceDelegate = s(this), this.Cs = new oo(this), this.indexManager = new dr, this.remoteDocumentCache = function (c) { return new io(c) }(c => this.referenceDelegate.xs(c)), this.It = new $i(o), this.Ns = new Zr(this.It) } start() { return Promise.resolve() } shutdown() { return this.Ds = !1, Promise.resolve() } get started() { return this.Ds } setDatabaseDeletedListener() { } setNetworkEnabled() { } getIndexManager(s) { return this.indexManager } getDocumentOverlayCache(s) { let o = this.overlays[s.toKey()]; return o || (o = new to, this.overlays[s.toKey()] = o), o } getMutationQueue(s, o) { let c = this.Vs[s.toKey()]; return c || (c = new so(o, this.referenceDelegate), this.Vs[s.toKey()] = c), c } getTargetCache() { return this.Cs } getRemoteDocumentCache() { return this.remoteDocumentCache } getBundleCache() { return this.Ns } runTransaction(s, o, c) { C("MemoryPersistence", "Starting transaction:", s); const et = new co(this.Ss.next()); return this.referenceDelegate.ks(), c(et).next(at => this.referenceDelegate.Os(et).next(() => at)).toPromise().then(at => (et.raiseOnCommittedEvent(), at)) } Ms(s, o) { return At.or(Object.values(this.Vs).map(c => () => c.containsKey(s, o))) } } class co extends Tt { constructor(s) { super(), this.currentSequenceNumber = s } } class ao { constructor(s) { this.persistence = s, this.Fs = new eo, this.$s = null } static Bs(s) { return new ao(s) } get Ls() { if (this.$s) return this.$s; throw O() } addReference(s, o, c) { return this.Fs.addReference(c, o), this.Ls.delete(c.toString()), At.resolve() } removeReference(s, o, c) { return this.Fs.removeReference(c, o), this.Ls.add(c.toString()), At.resolve() } markPotentiallyOrphaned(s, o) { return this.Ls.add(o.toString()), At.resolve() } removeTarget(s, o) { this.Fs.ls(o.targetId).forEach(et => this.Ls.add(et.toString())); const c = this.persistence.getTargetCache(); return c.getMatchingKeysForTargetId(s, o.targetId).next(et => { et.forEach(at => this.Ls.add(at.toString())) }).next(() => c.removeTargetData(s, o)) } ks() { this.$s = new Set } Os(s) { const o = this.persistence.getRemoteDocumentCache().newChangeBuffer(); return At.forEach(this.Ls, c => { const et = ct.fromPath(c); return this.Us(s, et).next(at => { at || o.removeEntry(et, st.min()) }) }).next(() => (this.$s = null, o.apply(s))) } updateLimboDocument(s, o) { return this.Us(s, o).next(c => { c ? this.Ls.delete(o.toString()) : this.Ls.add(o.toString()) }) } xs(s) { return 0 } Us(s, o) { return At.or([() => At.resolve(this.Fs.containsKey(o)), () => this.persistence.getTargetCache().containsKey(s, o), () => this.persistence.Ms(s, o)]) } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class yo { constructor(s, o, c, et) { this.targetId = s, this.fromCache = o, this.Si = c, this.Di = et } static Ci(s, o) { let c = fs(), et = fs(); for (const at of o.docChanges) switch (at.type) { case 0: c = c.add(at.doc.key); break; case 1: et = et.add(at.doc.key) }return new yo(s, o.fromCache, c, et) } }/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class po { constructor() { this.xi = !1 } initialize(s, o) { this.Ni = s, this.indexManager = o, this.xi = !0 } getDocumentsMatchingQuery(s, o, c, et) { return this.ki(s, o).next(at => at || this.Oi(s, o, et, c)).next(at => at || this.Mi(s, o)) } ki(s, o) { if (nn(o)) return At.resolve(null); let c = cn(o); return this.indexManager.getIndexType(s, c).next(et => et === 0 ? null : (o.limit !== null && et === 1 && (o = an(o, null, "F"), c = cn(o)), this.indexManager.getDocumentsMatchingTarget(s, c).next(at => { const lt = fs(...at); return this.Ni.getDocuments(s, lt).next(ft => this.indexManager.getMinOffset(s, c).next(dt => { const ht = this.Fi(o, ft); return this.$i(o, ht, lt, dt.readTime) ? this.ki(s, an(o, null, "F")) : this.Bi(s, ht, o, dt) })) }))) } Oi(s, o, c, et) { return nn(o) || et.isEqual(st.min()) ? this.Mi(s, o) : this.Ni.getDocuments(s, c).next(at => { const lt = this.Fi(o, at); return this.$i(o, lt, c, et) ? this.Mi(s, o) : (S() <= LogLevel.DEBUG && C("QueryEngine", "Re-using previous result from %s to execute query: %s", et.toString(), fn(o)), this.Bi(s, lt, o, mt(et, -1))) }) } Fi(s, o) { let c = new qt(wn(s)); return o.forEach((et, at) => { dn(s, at) && (c = c.add(at)) }), c } $i(s, o, c, et) { if (s.limit === null) return !1; if (c.size !== o.size) return !0; const at = s.limitType === "F" ? o.last() : o.first(); return !!at && (at.hasPendingWrites || at.version.compareTo(et) > 0) } Mi(s, o) { return S() <= LogLevel.DEBUG && C("QueryEngine", "Using full collection scan to execute query:", fn(o)), this.Ni.getDocumentsMatchingQuery(s, o, yt.min()) } Bi(s, o, c, et) { return this.Ni.getDocumentsMatchingQuery(s, c, et).next(at => (o.forEach(lt => { at = at.insert(lt.key, lt) }), at)) } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Io { constructor(s, o, c, et) { this.persistence = s, this.Li = o, this.It = et, this.Ui = new Bt(Z), this.qi = new es(at => xe(at), ke), this.Ki = new Map, this.Gi = s.getRemoteDocumentCache(), this.Cs = s.getTargetCache(), this.Ns = s.getBundleCache(), this.Qi(c) } Qi(s) { this.documentOverlayCache = this.persistence.getDocumentOverlayCache(s), this.indexManager = this.persistence.getIndexManager(s), this.mutationQueue = this.persistence.getMutationQueue(s, this.indexManager), this.localDocuments = new Xr(this.Gi, this.mutationQueue, this.documentOverlayCache, this.indexManager), this.Gi.setIndexManager(this.indexManager), this.Li.initialize(this.localDocuments, this.indexManager) } collectGarbage(s) { return this.persistence.runTransaction("Collect garbage", "readwrite-primary", o => s.collect(o, this.Ui)) } } function To(e, s, o, c) { return new Io(e, s, o, c) } async function Eo(e, s) { const o = $(e); return await o.persistence.runTransaction("Handle user change", "readonly", c => { let et; return o.mutationQueue.getAllMutationBatches(c).next(at => (et = at, o.Qi(s), o.mutationQueue.getAllMutationBatches(c))).next(at => { const lt = [], ft = []; let dt = fs(); for (const ht of et) { lt.push(ht.batchId); for (const vt of ht.mutations) dt = dt.add(vt.key) } for (const ht of at) { ft.push(ht.batchId); for (const vt of ht.mutations) dt = dt.add(vt.key) } return o.localDocuments.getDocuments(c, dt).next(ht => ({ ji: ht, removedBatchIds: lt, addedBatchIds: ft })) }) }) } function Ao(e, s) { const o = $(e); return o.persistence.runTransaction("Acknowledge batch", "readwrite-primary", c => { const et = s.batch.keys(), at = o.Gi.newChangeBuffer({ trackRemovals: !0 }); return function (lt, ft, dt, ht) { const vt = dt.batch, wt = vt.keys(); let St = At.resolve(); return wt.forEach(_t => { St = St.next(() => ht.getEntry(ft, _t)).next(Nt => { const kt = dt.docVersions.get(_t); M(kt !== null), Nt.version.compareTo(kt) < 0 && (vt.applyToRemoteDocument(Nt, dt), Nt.isValidDocument() && (Nt.setReadTime(dt.commitVersion), ht.addEntry(Nt))) }) }), St.next(() => lt.mutationQueue.removeMutationBatch(ft, vt)) }(o, c, s, at).next(() => at.apply(c)).next(() => o.mutationQueue.performConsistencyCheck(c)).next(() => o.documentOverlayCache.removeOverlaysForBatchId(c, et, s.batch.batchId)).next(() => o.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(c, function (lt) { let ft = fs(); for (let dt = 0; dt < lt.mutationResults.length; ++dt)lt.mutationResults[dt].transformResults.length > 0 && (ft = ft.add(lt.batch.mutations[dt].key)); return ft }(s))).next(() => o.localDocuments.getDocuments(c, et)) }) } function Ro(e) { const s = $(e); return s.persistence.runTransaction("Get last remote snapshot version", "readonly", o => s.Cs.getLastRemoteSnapshotVersion(o)) } function vo(e, s) { const o = $(e); return o.persistence.runTransaction("Get next mutation batch", "readonly", c => (s === void 0 && (s = -1), o.mutationQueue.getNextMutationBatchAfterBatchId(c, s))) } class Ko { constructor() { this.activeTargetIds = _s() } er(s) { this.activeTargetIds = this.activeTargetIds.add(s) } nr(s) { this.activeTargetIds = this.activeTargetIds.delete(s) } tr() { const s = { activeTargetIds: this.activeTargetIds.toArray(), updateTimeMs: Date.now() }; return JSON.stringify(s) } } class Qo { constructor() { this.Lr = new Ko, this.Ur = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null } addPendingMutation(s) { } updateMutationState(s, o, c) { } addLocalQueryTarget(s) { return this.Lr.er(s), this.Ur[s] || "not-current" } updateQueryState(s, o, c) { this.Ur[s] = o } removeLocalQueryTarget(s) { this.Lr.nr(s) } isLocalQueryTarget(s) { return this.Lr.activeTargetIds.has(s) } clearQueryState(s) { delete this.Ur[s] } getAllActiveQueryTargets() { return this.Lr.activeTargetIds } isActiveQueryTarget(s) { return this.Lr.activeTargetIds.has(s) } start() { return this.Lr = new Ko, Promise.resolve() } handleUserChange(s, o, c) { } setOnlineState(s) { } shutdown() { } writeSequenceNumber(s) { } notifyBundleLoaded(s) { } }/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class jo { qr(s) { } shutdown() { } }/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Wo { constructor() { this.Kr = () => this.Gr(), this.Qr = () => this.jr(), this.Wr = [], this.zr() } qr(s) { this.Wr.push(s) } shutdown() { window.removeEventListener("online", this.Kr), window.removeEventListener("offline", this.Qr) } zr() { window.addEventListener("online", this.Kr), window.addEventListener("offline", this.Qr) } Gr() { C("ConnectivityMonitor", "Network connectivity changed: AVAILABLE"); for (const s of this.Wr) s(0) } jr() { C("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE"); for (const s of this.Wr) s(1) } static C() { return typeof window < "u" && window.addEventListener !== void 0 && window.removeEventListener !== void 0 } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const zo = { BatchGetDocuments: "batchGet", Commit: "commit", RunQuery: "runQuery", RunAggregationQuery: "runAggregationQuery" };/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Ho { constructor(s) { this.Hr = s.Hr, this.Jr = s.Jr } Yr(s) { this.Xr = s } Zr(s) { this.eo = s } onMessage(s) { this.no = s } close() { this.Jr() } send(s) { this.Hr(s) } so() { this.Xr() } io(s) { this.eo(s) } ro(s) { this.no(s) } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Jo extends class { constructor(s) { this.databaseInfo = s, this.databaseId = s.databaseId; const o = s.ssl ? "https" : "http"; this.oo = o + "://" + s.host, this.uo = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents" } get co() { return !1 } ao(s, o, c, et, at) { const lt = this.ho(s, o); C("RestConnection", "Sending: ", lt, c); const ft = {}; return this.lo(ft, et, at), this.fo(s, lt, ft, c).then(dt => (C("RestConnection", "Received: ", dt), dt), dt => { throw N("RestConnection", `${s} failed with error: `, dt, "url: ", lt, "request:", c), dt }) } _o(s, o, c, et, at, lt) { return this.ao(s, o, c, et, at) } lo(s, o, c) { s["X-Goog-Api-Client"] = "gl-js/ fire/" + v, s["Content-Type"] = "text/plain", this.databaseInfo.appId && (s["X-Firebase-GMPID"] = this.databaseInfo.appId), o && o.headers.forEach((et, at) => s[at] = et), c && c.headers.forEach((et, at) => s[at] = et) } ho(s, o) { const c = zo[s]; return `${this.oo}/v1/${o}:${c}` } }{ constructor(s) { super(s), this.forceLongPolling = s.forceLongPolling, this.autoDetectLongPolling = s.autoDetectLongPolling, this.useFetchStreams = s.useFetchStreams } fo(s, o, c, et) { return new Promise((at, lt) => { const ft = new XhrIo; ft.setWithCredentials(!0), ft.listenOnce(EventType.COMPLETE, () => { try { switch (ft.getLastErrorCode()) { case ErrorCode.NO_ERROR: const ht = ft.getResponseJson(); C("Connection", "XHR received:", JSON.stringify(ht)), at(ht); break; case ErrorCode.TIMEOUT: C("Connection", 'RPC "' + s + '" timed out'), lt(new L(B.DEADLINE_EXCEEDED, "Request time out")); break; case ErrorCode.HTTP_ERROR: const vt = ft.getStatus(); if (C("Connection", 'RPC "' + s + '" failed with status:', vt, "response text:", ft.getResponseText()), vt > 0) { const wt = ft.getResponseJson().error; if (wt && wt.status && wt.message) { const St = function (_t) { const Nt = _t.toLowerCase().replace(/_/g, "-"); return Object.values(B).indexOf(Nt) >= 0 ? Nt : B.UNKNOWN }(wt.status); lt(new L(St, wt.message)) } else lt(new L(B.UNKNOWN, "Server responded with status " + ft.getStatus())) } else lt(new L(B.UNAVAILABLE, "Connection failed.")); break; default: O() } } finally { C("Connection", 'RPC "' + s + '" completed.') } }); const dt = JSON.stringify(et); ft.send(o, "POST", dt, c, 15) }) } wo(s, o, c) { const et = [this.oo, "/", "google.firestore.v1.Firestore", "/", s, "/channel"], at = createWebChannelTransport(), lt = getStatEventTarget(), ft = { httpSessionIdParam: "gsessionid", initMessageHeaders: {}, messageUrlParams: { database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}` }, sendRawJson: !0, supportsCrossDomainXhr: !0, internalChannelParams: { forwardChannelRequestTimeoutMs: 6e5 }, forceLongPolling: this.forceLongPolling, detectBufferingProxy: this.autoDetectLongPolling }; this.useFetchStreams && (ft.xmlHttpFactory = new FetchXmlHttpFactory({})), this.lo(ft.initMessageHeaders, o, c), ft.encodeInitMessageHeaders = !0; const dt = et.join(""); C("Connection", "Creating WebChannel: " + dt, ft); const ht = at.createWebChannel(dt, ft); let vt = !1, wt = !1; const St = new Ho({ Hr: Nt => { wt ? C("Connection", "Not sending because WebChannel is closed:", Nt) : (vt || (C("Connection", "Opening WebChannel transport."), ht.open(), vt = !0), C("Connection", "WebChannel sending:", Nt), ht.send(Nt)) }, Jr: () => ht.close() }), _t = (Nt, kt, Dt) => { Nt.listen(kt, xt => { try { Dt(xt) } catch (Ct) { setTimeout(() => { throw Ct }, 0) } }) }; return _t(ht, WebChannel.EventType.OPEN, () => { wt || C("Connection", "WebChannel transport opened.") }), _t(ht, WebChannel.EventType.CLOSE, () => { wt || (wt = !0, C("Connection", "WebChannel transport closed"), St.io()) }), _t(ht, WebChannel.EventType.ERROR, Nt => { wt || (wt = !0, N("Connection", "WebChannel transport errored:", Nt), St.io(new L(B.UNAVAILABLE, "The operation could not be completed"))) }), _t(ht, WebChannel.EventType.MESSAGE, Nt => { var kt; if (!wt) { const Dt = Nt.data[0]; M(!!Dt); const xt = Dt, Ct = xt.error || ((kt = xt[0]) === null || kt === void 0 ? void 0 : kt.error); if (Ct) { C("Connection", "WebChannel received error:", Ct); const bt = Ct.status; let Pt = function (Jn) { const er = Yn[Jn]; if (er !== void 0) return ts(er) }(bt), Rt = Ct.message; Pt === void 0 && (Pt = B.INTERNAL, Rt = "Unknown error status: " + bt + " with message " + Ct.message), wt = !0, St.io(new L(Pt, Rt)), ht.close() } else C("Connection", "WebChannel received:", Dt), St.ro(Dt) } }), _t(lt, Event$1.STAT_EVENT, Nt => { Nt.stat === Stat.PROXY ? C("Connection", "Detected buffering proxy") : Nt.stat === Stat.NOPROXY && C("Connection", "Detected no buffering proxy") }), setTimeout(() => { St.so() }, 0), St } } function Xo() { return typeof document < "u" ? document : null }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Zo(e) { return new Ps(e, !0) } class tu { constructor(s, o, c = 1e3, et = 1.5, at = 6e4) { this.Hs = s, this.timerId = o, this.mo = c, this.yo = et, this.po = at, this.Io = 0, this.To = null, this.Eo = Date.now(), this.reset() } reset() { this.Io = 0 } Ao() { this.Io = this.po } Ro(s) { this.cancel(); const o = Math.floor(this.Io + this.bo()), c = Math.max(0, Date.now() - this.Eo), et = Math.max(0, o - c); et > 0 && C("ExponentialBackoff", `Backing off for ${et} ms (base delay: ${this.Io} ms, delay with jitter: ${o} ms, last attempt: ${c} ms ago)`), this.To = this.Hs.enqueueAfterDelay(this.timerId, et, () => (this.Eo = Date.now(), s())), this.Io *= this.yo, this.Io < this.mo && (this.Io = this.mo), this.Io > this.po && (this.Io = this.po) } Po() { this.To !== null && (this.To.skipDelay(), this.To = null) } cancel() { this.To !== null && (this.To.cancel(), this.To = null) } bo() { return (Math.random() - .5) * this.Io } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class eu { constructor(s, o, c, et, at, lt, ft, dt) { this.Hs = s, this.vo = c, this.Vo = et, this.connection = at, this.authCredentialsProvider = lt, this.appCheckCredentialsProvider = ft, this.listener = dt, this.state = 0, this.So = 0, this.Do = null, this.Co = null, this.stream = null, this.xo = new tu(s, o) } No() { return this.state === 1 || this.state === 5 || this.ko() } ko() { return this.state === 2 || this.state === 3 } start() { this.state !== 4 ? this.auth() : this.Oo() } async stop() { this.No() && await this.close(0) } Mo() { this.state = 0, this.xo.reset() } Fo() { this.ko() && this.Do === null && (this.Do = this.Hs.enqueueAfterDelay(this.vo, 6e4, () => this.$o())) } Bo(s) { this.Lo(), this.stream.send(s) } async $o() { if (this.ko()) return this.close(0) } Lo() { this.Do && (this.Do.cancel(), this.Do = null) } Uo() { this.Co && (this.Co.cancel(), this.Co = null) } async close(s, o) { this.Lo(), this.Uo(), this.xo.cancel(), this.So++, s !== 4 ? this.xo.reset() : o && o.code === B.RESOURCE_EXHAUSTED ? (x(o.toString()), x("Using maximum backoff delay to prevent overloading the backend."), this.xo.Ao()) : o && o.code === B.UNAUTHENTICATED && this.state !== 3 && (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()), this.stream !== null && (this.qo(), this.stream.close(), this.stream = null), this.state = s, await this.listener.Zr(o) } qo() { } auth() { this.state = 1; const s = this.Ko(this.So), o = this.So; Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then(([c, et]) => { this.So === o && this.Go(c, et) }, c => { s(() => { const et = new L(B.UNKNOWN, "Fetching auth token failed: " + c.message); return this.Qo(et) }) }) } Go(s, o) { const c = this.Ko(this.So); this.stream = this.jo(s, o), this.stream.Yr(() => { c(() => (this.state = 2, this.Co = this.Hs.enqueueAfterDelay(this.Vo, 1e4, () => (this.ko() && (this.state = 3), Promise.resolve())), this.listener.Yr())) }), this.stream.Zr(et => { c(() => this.Qo(et)) }), this.stream.onMessage(et => { c(() => this.onMessage(et)) }) } Oo() { this.state = 5, this.xo.Ro(async () => { this.state = 0, this.start() }) } Qo(s) { return C("PersistentStream", `close with error: ${s}`), this.stream = null, this.close(4, s) } Ko(s) { return o => { this.Hs.enqueueAndForget(() => this.So === s ? o() : (C("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve())) } } } class su extends eu { constructor(s, o, c, et, at, lt) { super(s, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", o, c, et, lt), this.It = at, this.Jo = !1 } get Yo() { return this.Jo } start() { this.Jo = !1, this.lastStreamToken = void 0, super.start() } qo() { this.Jo && this.Xo([]) } jo(s, o) { return this.connection.wo("Write", s, o) } onMessage(s) { if (M(!!s.streamToken), this.lastStreamToken = s.streamToken, this.Jo) { this.xo.reset(); const o = Qs(s.writeResults, s.commitTime), c = Ds(s.commitTime); return this.listener.Zo(c, o) } return M(!s.writeResults || s.writeResults.length === 0), this.Jo = !0, this.listener.tu() } eu() { const s = {}; s.database = Fs(this.It), this.Bo(s) } Xo(s) { const o = { streamToken: this.lastStreamToken, writes: s.map(c => Ks(this.It, c)) }; this.Bo(o) } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class iu extends class { }{ constructor(s, o, c, et) { super(), this.authCredentials = s, this.appCheckCredentials = o, this.connection = c, this.It = et, this.nu = !1 } su() { if (this.nu) throw new L(B.FAILED_PRECONDITION, "The client has already been terminated.") } ao(s, o, c) { return this.su(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([et, at]) => this.connection.ao(s, o, c, et, at)).catch(et => { throw et.name === "FirebaseError" ? (et.code === B.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), et) : new L(B.UNKNOWN, et.toString()) }) } _o(s, o, c, et) { return this.su(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([at, lt]) => this.connection._o(s, o, c, at, lt, et)).catch(at => { throw at.name === "FirebaseError" ? (at.code === B.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), at) : new L(B.UNKNOWN, at.toString()) }) } terminate() { this.nu = !0 } } class ou {
	constructor(s, o) { this.asyncQueue = s, this.onlineStateHandler = o, this.state = "Unknown", this.iu = 0, this.ru = null, this.ou = !0 } uu() { this.iu === 0 && (this.cu("Unknown"), this.ru = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.ru = null, this.au("Backend didn't respond within 10 seconds."), this.cu("Offline"), Promise.resolve()))) } hu(s) { this.state === "Online" ? this.cu("Unknown") : (this.iu++, this.iu >= 1 && (this.lu(), this.au(`Connection failed 1 times. Most recent error: ${s.toString()}`), this.cu("Offline"))) } set(s) { this.lu(), this.iu = 0, s === "Online" && (this.ou = !1), this.cu(s) } cu(s) { s !== this.state && (this.state = s, this.onlineStateHandler(s)) } au(s) {
		const o = `Could not reach Cloud Firestore backend. ${s}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`; this.ou ? (x(o), this.ou = !1) : C("OnlineStateTracker", o)
	} lu() { this.ru !== null && (this.ru.cancel(), this.ru = null) }
}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class uu { constructor(s, o, c, et, at) { this.localStore = s, this.datastore = o, this.asyncQueue = c, this.remoteSyncer = {}, this.fu = [], this.du = new Map, this._u = new Set, this.wu = [], this.mu = at, this.mu.qr(lt => { c.enqueueAndForget(async () => { mu(this) && (C("RemoteStore", "Restarting streams for network reachability change."), await async function (ft) { const dt = $(ft); dt._u.add(4), await au(dt), dt.gu.set("Unknown"), dt._u.delete(4), await cu(dt) }(this)) }) }), this.gu = new ou(c, et) } } async function cu(e) { if (mu(e)) for (const s of e.wu) await s(!0) } async function au(e) { for (const s of e.wu) await s(!1) } function mu(e) { return $(e)._u.size === 0 } async function Tu(e, s, o) { if (!Vt(s)) throw s; e._u.add(1), await au(e), e.gu.set("Offline"), o || (o = () => Ro(e.localStore)), e.asyncQueue.enqueueRetryable(async () => { C("RemoteStore", "Retrying IndexedDB access"), await o(), e._u.delete(1), await cu(e) }) } function Eu(e, s) { return s().catch(o => Tu(e, o, s)) } async function Au(e) { const s = $(e), o = Ou(s); let c = s.fu.length > 0 ? s.fu[s.fu.length - 1].batchId : -1; for (; Ru(s);)try { const et = await vo(s.localStore, c); if (et === null) { s.fu.length === 0 && o.Fo(); break } c = et.batchId, bu(s, et) } catch (et) { await Tu(s, et) } Pu(s) && vu(s) } function Ru(e) { return mu(e) && e.fu.length < 10 } function bu(e, s) { e.fu.push(s); const o = Ou(e); o.ko() && o.Yo && o.Xo(s.mutations) } function Pu(e) { return mu(e) && !Ou(e).No() && e.fu.length > 0 } function vu(e) { Ou(e).start() } async function Vu(e) { Ou(e).eu() } async function Su(e) { const s = Ou(e); for (const o of e.fu) s.Xo(o.mutations) } async function Du(e, s, o) { const c = e.fu.shift(), et = Oi.from(c, s, o); await Eu(e, () => e.remoteSyncer.applySuccessfulWrite(et)), await Au(e) } async function Cu(e, s) { s && Ou(e).Yo && await async function (o, c) { if (et = c.code, Zn(et) && et !== B.ABORTED) { const at = o.fu.shift(); Ou(o).Mo(), await Eu(o, () => o.remoteSyncer.rejectFailedWrite(at.batchId, c)), await Au(o) } var et }(e, s), Pu(e) && vu(e) } async function xu(e, s) { const o = $(e); o.asyncQueue.verifyOperationInProgress(), C("RemoteStore", "RemoteStore received new credentials"); const c = mu(o); o._u.add(3), await au(o), c && o.gu.set("Unknown"), await o.remoteSyncer.handleCredentialChange(s), o._u.delete(3), await cu(o) } async function Nu(e, s) { const o = $(e); s ? (o._u.delete(2), await cu(o)) : s || (o._u.add(2), await au(o), o.gu.set("Unknown")) } function Ou(e) { return e.Iu || (e.Iu = function (s, o, c) { const et = $(s); return et.su(), new su(o, et.connection, et.authCredentials, et.appCheckCredentials, et.It, c) }(e.datastore, e.asyncQueue, { Yr: Vu.bind(null, e), Zr: Cu.bind(null, e), tu: Su.bind(null, e), Zo: Du.bind(null, e) }), e.wu.push(async s => { s ? (e.Iu.Mo(), await Au(e)) : (await e.Iu.stop(), e.fu.length > 0 && (C("RemoteStore", `Stopping write stream with ${e.fu.length} pending writes`), e.fu = [])) })), e.Iu }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Mu { constructor(s, o, c, et, at) { this.asyncQueue = s, this.timerId = o, this.targetTimeMs = c, this.op = et, this.removalCallback = at, this.deferred = new U, this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch(lt => { }) } static createAndSchedule(s, o, c, et, at) { const lt = Date.now() + c, ft = new Mu(s, o, lt, et, at); return ft.start(c), ft } start(s) { this.timerHandle = setTimeout(() => this.handleDelayElapsed(), s) } skipDelay() { return this.handleDelayElapsed() } cancel(s) { this.timerHandle !== null && (this.clearTimeout(), this.deferred.reject(new L(B.CANCELLED, "Operation cancelled" + (s ? ": " + s : "")))) } handleDelayElapsed() { this.asyncQueue.enqueueAndForget(() => this.timerHandle !== null ? (this.clearTimeout(), this.op().then(s => this.deferred.resolve(s))) : Promise.resolve()) } clearTimeout() { this.timerHandle !== null && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null) } } function Fu(e, s) { if (x("AsyncQueue", `${s}: ${e}`), Vt(e)) return new L(B.UNAVAILABLE, `${s}: ${e}`); throw e } class qu { constructor() { this.queries = new es(s => ln(s), hn), this.onlineState = "Unknown", this.Ru = new Set } } function Wu(e) { e.Ru.forEach(s => { s.next() }) } class ic { constructor(s, o, c, et, at, lt) { this.localStore = s, this.remoteStore = o, this.eventManager = c, this.sharedClientState = et, this.currentUser = at, this.maxConcurrentLimboResolutions = lt, this.sc = {}, this.ic = new es(ft => ln(ft), hn), this.rc = new Map, this.oc = new Set, this.uc = new Bt(ct.comparator), this.cc = new Map, this.ac = new eo, this.hc = {}, this.lc = new Map, this.fc = Cr.vn(), this.onlineState = "Unknown", this.dc = void 0 } get isPrimaryClient() { return this.dc === !0 } } async function cc(e, s, o) { const c = Oc(e); try { const et = await function (at, lt) { const ft = $(at), dt = nt.now(), ht = lt.reduce((St, _t) => St.add(_t.key), fs()); let vt, wt; return ft.persistence.runTransaction("Locally write mutations", "readwrite", St => { let _t = ss(), Nt = fs(); return ft.Gi.getEntries(St, ht).next(kt => { _t = kt, _t.forEach((Dt, xt) => { xt.isValidDocument() || (Nt = Nt.add(Dt)) }) }).next(() => ft.localDocuments.getOverlayedDocuments(St, _t)).next(kt => { vt = kt; const Dt = []; for (const xt of lt) { const Ct = Un(xt, vt.get(xt.key).overlayedDocument); Ct != null && Dt.push(new Gn(xt.key, Ct, Ve(Ct.value.mapValue), On.exists(!0))) } return ft.mutationQueue.addMutationBatch(St, dt, Dt, lt) }).next(kt => { wt = kt; const Dt = kt.applyToLocalDocumentSet(vt, Nt); return ft.documentOverlayCache.saveOverlays(St, kt.batchId, Dt) }) }).then(() => ({ batchId: wt.batchId, changes: os(vt) })) }(c.localStore, s); c.sharedClientState.addPendingMutation(et.batchId), function (at, lt, ft) { let dt = at.hc[at.currentUser.toKey()]; dt || (dt = new Bt(Z)), dt = dt.insert(lt, ft), at.hc[at.currentUser.toKey()] = dt }(c, et.batchId, o), await Ec(c, et.changes), await Au(c.remoteStore) } catch (et) { const at = Fu(et, "Failed to persist write"); o.reject(at) } } function hc(e, s, o) { const c = $(e); if (c.isPrimaryClient && o === 0 || !c.isPrimaryClient && o === 1) { const et = []; c.ic.forEach((at, lt) => { const ft = lt.view.bu(s); ft.snapshot && et.push(ft.snapshot) }), function (at, lt) { const ft = $(at); ft.onlineState = lt; let dt = !1; ft.queries.forEach((ht, vt) => { for (const wt of vt.listeners) wt.bu(lt) && (dt = !0) }), dt && Wu(ft) }(c.eventManager, s), et.length && c.sc.Wo(et), c.onlineState = s, c.isPrimaryClient && c.sharedClientState.setOnlineState(s) } } async function fc(e, s) { const o = $(e), c = s.batch.batchId; try { const et = await Ao(o.localStore, s); mc(o, c, null), wc(o, c), o.sharedClientState.updateMutationState(c, "acknowledged"), await Ec(o, et) } catch (et) { await Et(et) } } async function dc(e, s, o) { const c = $(e); try { const et = await function (at, lt) { const ft = $(at); return ft.persistence.runTransaction("Reject batch", "readwrite-primary", dt => { let ht; return ft.mutationQueue.lookupMutationBatch(dt, lt).next(vt => (M(vt !== null), ht = vt.keys(), ft.mutationQueue.removeMutationBatch(dt, vt))).next(() => ft.mutationQueue.performConsistencyCheck(dt)).next(() => ft.documentOverlayCache.removeOverlaysForBatchId(dt, ht, lt)).next(() => ft.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(dt, ht)).next(() => ft.localDocuments.getDocuments(dt, ht)) }) }(c.localStore, s); mc(c, s, o), wc(c, s), c.sharedClientState.updateMutationState(s, "rejected", o), await Ec(c, et) } catch (et) { await Et(et) } } function wc(e, s) { (e.lc.get(s) || []).forEach(o => { o.resolve() }), e.lc.delete(s) } function mc(e, s, o) { const c = $(e); let et = c.hc[c.currentUser.toKey()]; if (et) { const at = et.get(s); at && (o ? at.reject(o) : at.resolve(), et = et.remove(s)), c.hc[c.currentUser.toKey()] = et } } async function Ec(e, s, o) { const c = $(e), et = [], at = [], lt = []; c.ic.isEmpty() || (c.ic.forEach((ft, dt) => { lt.push(c._c(dt, s, o).then(ht => { if ((ht || o) && c.isPrimaryClient && c.sharedClientState.updateQueryState(dt.targetId, ht != null && ht.fromCache ? "not-current" : "current"), ht) { et.push(ht); const vt = yo.Ci(dt.targetId, ht); at.push(vt) } })) }), await Promise.all(lt), c.sc.Wo(et), await async function (ft, dt) { const ht = $(ft); try { await ht.persistence.runTransaction("notifyLocalViewChanges", "readwrite", vt => At.forEach(dt, wt => At.forEach(wt.Si, St => ht.persistence.referenceDelegate.addReference(vt, wt.targetId, St)).next(() => At.forEach(wt.Di, St => ht.persistence.referenceDelegate.removeReference(vt, wt.targetId, St))))) } catch (vt) { if (!Vt(vt)) throw vt; C("LocalStore", "Failed to update sequence numbers: " + vt) } for (const vt of dt) { const wt = vt.targetId; if (!vt.fromCache) { const St = ht.Ui.get(wt), _t = St.snapshotVersion, Nt = St.withLastLimboFreeSnapshotVersion(_t); ht.Ui = ht.Ui.insert(wt, Nt) } } }(c.localStore, at)) } async function Ac(e, s) { const o = $(e); if (!o.currentUser.isEqual(s)) { C("SyncEngine", "User change. New user:", s.toKey()); const c = await Eo(o.localStore, s); o.currentUser = s, function (et, at) { et.lc.forEach(lt => { lt.forEach(ft => { ft.reject(new L(B.CANCELLED, at)) }) }), et.lc.clear() }(o, "'waitForPendingWrites' promise is rejected due to a user change."), o.sharedClientState.handleUserChange(s, c.removedBatchIds, c.addedBatchIds), await Ec(o, c.ji) } } function Oc(e) { const s = $(e); return s.remoteStore.remoteSyncer.applySuccessfulWrite = fc.bind(null, s), s.remoteStore.remoteSyncer.rejectFailedWrite = dc.bind(null, s), s } class Fc { constructor() { this.synchronizeTabs = !1 } async initialize(s) { this.It = Zo(s.databaseInfo.databaseId), this.sharedClientState = this.gc(s), this.persistence = this.yc(s), await this.persistence.start(), this.localStore = this.Ic(s), this.gcScheduler = this.Tc(s, this.localStore), this.indexBackfillerScheduler = this.Ec(s, this.localStore) } Tc(s, o) { return null } Ec(s, o) { return null } Ic(s) { return To(this.persistence, new po, s.initialUser, this.It) } yc(s) { return new uo(ao.Bs, this.It) } gc(s) { return new Qo } async terminate() { this.gcScheduler && this.gcScheduler.stop(), await this.sharedClientState.shutdown(), await this.persistence.shutdown() } } class Lc { async initialize(s, o) { this.localStore || (this.localStore = s.localStore, this.sharedClientState = s.sharedClientState, this.datastore = this.createDatastore(o), this.remoteStore = this.createRemoteStore(o), this.eventManager = this.createEventManager(o), this.syncEngine = this.createSyncEngine(o, !s.synchronizeTabs), this.sharedClientState.onlineStateHandler = c => hc(this.syncEngine, c, 1), this.remoteStore.remoteSyncer.handleCredentialChange = Ac.bind(null, this.syncEngine), await Nu(this.remoteStore, this.syncEngine.isPrimaryClient)) } createEventManager(s) { return new qu } createDatastore(s) { const o = Zo(s.databaseInfo.databaseId), c = (et = s.databaseInfo, new Jo(et)); var et; return function (at, lt, ft, dt) { return new iu(at, lt, ft, dt) }(s.authCredentials, s.appCheckCredentials, c, o) } createRemoteStore(s) { return o = this.localStore, c = this.datastore, et = s.asyncQueue, at = ft => hc(this.syncEngine, ft, 0), lt = Wo.C() ? new Wo : new jo, new uu(o, c, et, at, lt); var o, c, et, at, lt } createSyncEngine(s, o) { return function (c, et, at, lt, ft, dt, ht) { const vt = new ic(c, et, at, lt, ft, dt); return ht && (vt.dc = !0), vt }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, s.initialUser, s.maxConcurrentLimboResolutions, o) } terminate() { return async function (s) { const o = $(s); C("RemoteStore", "RemoteStore shutting down."), o._u.add(5), await au(o), o.mu.shutdown(), o.gu.set("Unknown") }(this.remoteStore) } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Uc(e, s, o) { if (!o) throw new L(B.INVALID_ARGUMENT, `Function ${e}() cannot be called with an empty ${s}.`) } function qc(e, s, o, c) { if (s === !0 && c === !0) throw new L(B.INVALID_ARGUMENT, `${e} and ${o} cannot be used together.`) } function Kc(e) { if (!ct.isDocumentKey(e)) throw new L(B.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${e} has ${e.length}.`) } function Gc(e) { if (ct.isDocumentKey(e)) throw new L(B.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${e} has ${e.length}.`) } function Qc(e) { if (e === void 0) return "undefined"; if (e === null) return "null"; if (typeof e == "string") return e.length > 20 && (e = `${e.substring(0, 20)}...`), JSON.stringify(e); if (typeof e == "number" || typeof e == "boolean") return "" + e; if (typeof e == "object") { if (e instanceof Array) return "an array"; { const s = function (o) { return o.constructor ? o.constructor.name : null }(e); return s ? `a custom ${s} object` : "an object" } } return typeof e == "function" ? "a function" : O() } function jc(e, s) { if ("_delegate" in e && (e = e._delegate), !(e instanceof s)) { if (s.name === e.constructor.name) throw new L(B.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?"); { const o = Qc(e); throw new L(B.INVALID_ARGUMENT, `Expected type '${s.name}', but it was: ${o}`) } } return e }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const zc = new Map; class Hc { constructor(s) { var o; if (s.host === void 0) { if (s.ssl !== void 0) throw new L(B.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set"); this.host = "firestore.googleapis.com", this.ssl = !0 } else this.host = s.host, this.ssl = (o = s.ssl) === null || o === void 0 || o; if (this.credentials = s.credentials, this.ignoreUndefinedProperties = !!s.ignoreUndefinedProperties, s.cacheSizeBytes === void 0) this.cacheSizeBytes = 41943040; else { if (s.cacheSizeBytes !== -1 && s.cacheSizeBytes < 1048576) throw new L(B.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576"); this.cacheSizeBytes = s.cacheSizeBytes } this.experimentalForceLongPolling = !!s.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !!s.experimentalAutoDetectLongPolling, this.useFetchStreams = !!s.useFetchStreams, qc("experimentalForceLongPolling", s.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", s.experimentalAutoDetectLongPolling) } isEqual(s) { return this.host === s.host && this.ssl === s.ssl && this.credentials === s.credentials && this.cacheSizeBytes === s.cacheSizeBytes && this.experimentalForceLongPolling === s.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === s.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === s.ignoreUndefinedProperties && this.useFetchStreams === s.useFetchStreams } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Jc { constructor(s, o, c, et) { this._authCredentials = s, this._appCheckCredentials = o, this._databaseId = c, this._app = et, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new Hc({}), this._settingsFrozen = !1 } get app() { if (!this._app) throw new L(B.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available"); return this._app } get _initialized() { return this._settingsFrozen } get _terminated() { return this._terminateTask !== void 0 } _setSettings(s) { if (this._settingsFrozen) throw new L(B.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object."); this._settings = new Hc(s), s.credentials !== void 0 && (this._authCredentials = function (o) { if (!o) return new K; switch (o.type) { case "gapi": const c = o.client; return new W(c, o.sessionIndex || "0", o.iamToken || null, o.authTokenFactory || null); case "provider": return o.client; default: throw new L(B.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type") } }(s.credentials)) } _getSettings() { return this._settings } _freezeSettings() { return this._settingsFrozen = !0, this._settings } _delete() { return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask } toJSON() { return { app: this._app, databaseId: this._databaseId, settings: this._settings } } _terminate() { return function (s) { const o = zc.get(s); o && (C("ComponentProvider", "Removing Datastore"), zc.delete(s), o.terminate()) }(this), Promise.resolve() } } function Yc(e, s, o, c = {}) { var et; const at = (e = jc(e, Jc))._getSettings(); if (at.host !== "firestore.googleapis.com" && at.host !== s && N("Host has been set in both settings() and useEmulator(), emulator host will be used"), e._setSettings(Object.assign(Object.assign({}, at), { host: `${s}:${o}`, ssl: !1 })), c.mockUserToken) { let lt, ft; if (typeof c.mockUserToken == "string") lt = c.mockUserToken, ft = P.MOCK_USER; else { lt = createMockUserToken(c.mockUserToken, (et = e._app) === null || et === void 0 ? void 0 : et.options.projectId); const dt = c.mockUserToken.sub || c.mockUserToken.user_id; if (!dt) throw new L(B.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!"); ft = new P(dt) } e._authCredentials = new G(new q(lt, ft)) } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Xc { constructor(s, o, c) { this.converter = o, this._key = c, this.type = "document", this.firestore = s } get _path() { return this._key.path } get id() { return this._key.path.lastSegment() } get path() { return this._key.path.canonicalString() } get parent() { return new ta(this.firestore, this.converter, this._key.path.popLast()) } withConverter(s) { return new Xc(this.firestore, s, this._key) } } class Zc { constructor(s, o, c) { this.converter = o, this._query = c, this.type = "query", this.firestore = s } withConverter(s) { return new Zc(this.firestore, s, this._query) } } class ta extends Zc { constructor(s, o, c) { super(s, o, en(c)), this._path = c, this.type = "collection" } get id() { return this._query.path.lastSegment() } get path() { return this._query.path.canonicalString() } get parent() { const s = this._path.popLast(); return s.isEmpty() ? null : new Xc(this.firestore, null, new ct(s)) } withConverter(s) { return new ta(this.firestore, s, this._path) } } function ea(e, s, ...o) { if (e = getModularInstance(e), Uc("collection", "path", s), e instanceof Jc) { const c = rt.fromString(s, ...o); return Gc(c), new ta(e, null, c) } { if (!(e instanceof Xc || e instanceof ta)) throw new L(B.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore"); const c = e._path.child(rt.fromString(s, ...o)); return Gc(c), new ta(e.firestore, null, c) } } function sa(e, s, ...o) { if (e = getModularInstance(e), arguments.length === 1 && (s = X.R()), Uc("doc", "path", s), e instanceof Jc) { const c = rt.fromString(s, ...o); return Kc(c), new Xc(e, null, new ct(c)) } { if (!(e instanceof Xc || e instanceof ta)) throw new L(B.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore"); const c = e._path.child(rt.fromString(s, ...o)); return Kc(c), new Xc(e.firestore, e instanceof ta ? e.converter : null, new ct(c)) } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class _a { constructor(s, o, c, et) { this.authCredentials = s, this.appCheckCredentials = o, this.asyncQueue = c, this.databaseInfo = et, this.user = P.UNAUTHENTICATED, this.clientId = X.R(), this.authCredentialListener = () => Promise.resolve(), this.appCheckCredentialListener = () => Promise.resolve(), this.authCredentials.start(c, async at => { C("FirestoreClient", "Received user=", at.uid), await this.authCredentialListener(at), this.user = at }), this.appCheckCredentials.start(c, at => (C("FirestoreClient", "Received new app check token=", at), this.appCheckCredentialListener(at, this.user))) } async getConfiguration() { return { asyncQueue: this.asyncQueue, databaseInfo: this.databaseInfo, clientId: this.clientId, authCredentials: this.authCredentials, appCheckCredentials: this.appCheckCredentials, initialUser: this.user, maxConcurrentLimboResolutions: 100 } } setCredentialChangeListener(s) { this.authCredentialListener = s } setAppCheckTokenChangeListener(s) { this.appCheckCredentialListener = s } verifyNotTerminated() { if (this.asyncQueue.isShuttingDown) throw new L(B.FAILED_PRECONDITION, "The client has already been terminated.") } terminate() { this.asyncQueue.enterRestrictedMode(); const s = new U; return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => { try { this.onlineComponents && await this.onlineComponents.terminate(), this.offlineComponents && await this.offlineComponents.terminate(), this.authCredentials.shutdown(), this.appCheckCredentials.shutdown(), s.resolve() } catch (o) { const c = Fu(o, "Failed to shutdown persistence"); s.reject(c) } }), s.promise } } async function wa(e, s) { e.asyncQueue.verifyOperationInProgress(), C("FirestoreClient", "Initializing OfflineComponentProvider"); const o = await e.getConfiguration(); await s.initialize(o); let c = o.initialUser; e.setCredentialChangeListener(async et => { c.isEqual(et) || (await Eo(s.localStore, et), c = et) }), s.persistence.setDatabaseDeletedListener(() => e.terminate()), e.offlineComponents = s } async function ma(e, s) { e.asyncQueue.verifyOperationInProgress(); const o = await ga(e); C("FirestoreClient", "Initializing OnlineComponentProvider"); const c = await e.getConfiguration(); await s.initialize(o, c), e.setCredentialChangeListener(et => xu(s.remoteStore, et)), e.setAppCheckTokenChangeListener((et, at) => xu(s.remoteStore, at)), e.onlineComponents = s } async function ga(e) { return e.offlineComponents || (C("FirestoreClient", "Using default OfflineComponentProvider"), await wa(e, new Fc)), e.offlineComponents } async function ya(e) { return e.onlineComponents || (C("FirestoreClient", "Using default OnlineComponentProvider"), await ma(e, new Lc)), e.onlineComponents } function Ea(e) { return ya(e).then(s => s.syncEngine) } class ka {
	constructor() { this.Bc = Promise.resolve(), this.Lc = [], this.Uc = !1, this.qc = [], this.Kc = null, this.Gc = !1, this.Qc = !1, this.jc = [], this.xo = new tu(this, "async_queue_retry"), this.Wc = () => { const o = Xo(); o && C("AsyncQueue", "Visibility state changed to " + o.visibilityState), this.xo.Po() }; const s = Xo(); s && typeof s.addEventListener == "function" && s.addEventListener("visibilitychange", this.Wc) } get isShuttingDown() { return this.Uc } enqueueAndForget(s) { this.enqueue(s) } enqueueAndForgetEvenWhileRestricted(s) { this.zc(), this.Hc(s) } enterRestrictedMode(s) { if (!this.Uc) { this.Uc = !0, this.Qc = s || !1; const o = Xo(); o && typeof o.removeEventListener == "function" && o.removeEventListener("visibilitychange", this.Wc) } } enqueue(s) { if (this.zc(), this.Uc) return new Promise(() => { }); const o = new U; return this.Hc(() => this.Uc && this.Qc ? Promise.resolve() : (s().then(o.resolve, o.reject), o.promise)).then(() => o.promise) } enqueueRetryable(s) { this.enqueueAndForget(() => (this.Lc.push(s), this.Jc())) } async Jc() { if (this.Lc.length !== 0) { try { await this.Lc[0](), this.Lc.shift(), this.xo.reset() } catch (s) { if (!Vt(s)) throw s; C("AsyncQueue", "Operation failed with retryable error: " + s) } this.Lc.length > 0 && this.xo.Ro(() => this.Jc()) } } Hc(s) {
		const o = this.Bc.then(() => (this.Gc = !0, s().catch(c => {
			this.Kc = c, this.Gc = !1; const et = function (at) {
				let lt = at.message || ""; return at.stack && (lt = at.stack.includes(at.message) ? at.stack : at.message + `
`+ at.stack), lt
			}(c); throw x("INTERNAL UNHANDLED ERROR: ", et), c
		}).then(c => (this.Gc = !1, c)))); return this.Bc = o, o
	} enqueueAfterDelay(s, o, c) { this.zc(), this.jc.indexOf(s) > -1 && (o = 0); const et = Mu.createAndSchedule(this, s, o, c, at => this.Yc(at)); return this.qc.push(et), et } zc() { this.Kc && O() } verifyOperationInProgress() { } async Xc() { let s; do s = this.Bc, await s; while (s !== this.Bc) } Zc(s) { for (const o of this.qc) if (o.timerId === s) return !0; return !1 } ta(s) { return this.Xc().then(() => { this.qc.sort((o, c) => o.targetTimeMs - c.targetTimeMs); for (const o of this.qc) if (o.skipDelay(), s !== "all" && o.timerId === s) break; return this.Xc() }) } ea(s) { this.jc.push(s) } Yc(s) { const o = this.qc.indexOf(s); this.qc.splice(o, 1) }
} class $a extends Jc { constructor(s, o, c, et) { super(s, o, c, et), this.type = "firestore", this._queue = new ka, this._persistenceKey = (et == null ? void 0 : et.name) || "[DEFAULT]" } _terminate() { return this._firestoreClient || qa(this), this._firestoreClient.terminate() } } function La(e, s) { const o = typeof e == "object" ? e : getApp(), c = typeof e == "string" ? e : s || "(default)", et = _getProvider(o, "firestore").getImmediate({ identifier: c }); if (!et._initialized) { const at = getDefaultEmulatorHostnameAndPort("firestore"); at && Yc(et, ...at) } return et } function Ua(e) { return e._firestoreClient || qa(e), e._firestoreClient.verifyNotTerminated(), e._firestoreClient } function qa(e) { var s; const o = e._freezeSettings(), c = function (et, at, lt, ft) { return new ee(et, at, lt, ft.host, ft.ssl, ft.experimentalForceLongPolling, ft.experimentalAutoDetectLongPolling, ft.useFetchStreams) }(e._databaseId, ((s = e._app) === null || s === void 0 ? void 0 : s.options.appId) || "", e._persistenceKey, o); e._firestoreClient = new _a(e._authCredentials, e._appCheckCredentials, e._queue, c) }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class th { constructor(s) { this._byteString = s } static fromBase64String(s) { try { return new th(Wt.fromBase64String(s)) } catch (o) { throw new L(B.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + o) } } static fromUint8Array(s) { return new th(Wt.fromUint8Array(s)) } toBase64() { return this._byteString.toBase64() } toUint8Array() { return this._byteString.toUint8Array() } toString() { return "Bytes(base64: " + this.toBase64() + ")" } isEqual(s) { return this._byteString.isEqual(s._byteString) } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class eh { constructor(...s) { for (let o = 0; o < s.length; ++o)if (s[o].length === 0) throw new L(B.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty."); this._internalPath = new ut(s) } isEqual(s) { return this._internalPath.isEqual(s._internalPath) } }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class sh { constructor(s) { this._methodName = s } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class ih { constructor(s, o) { if (!isFinite(s) || s < -90 || s > 90) throw new L(B.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + s); if (!isFinite(o) || o < -180 || o > 180) throw new L(B.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + o); this._lat = s, this._long = o } get latitude() { return this._lat } get longitude() { return this._long } isEqual(s) { return this._lat === s._lat && this._long === s._long } toJSON() { return { latitude: this._lat, longitude: this._long } } _compareTo(s) { return Z(this._lat, s._lat) || Z(this._long, s._long) } }/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const rh = /^__.*__$/; class oh { constructor(s, o, c) { this.data = s, this.fieldMask = o, this.fieldTransforms = c } toMutation(s, o) { return this.fieldMask !== null ? new Gn(s, this.data, this.fieldMask, o, this.fieldTransforms) : new Kn(s, this.data, o, this.fieldTransforms) } } function ch(e) { switch (e) { case 0: case 2: case 1: return !0; case 3: case 4: return !1; default: throw O() } } class ah { constructor(s, o, c, et, at, lt) { this.settings = s, this.databaseId = o, this.It = c, this.ignoreUndefinedProperties = et, at === void 0 && this.na(), this.fieldTransforms = at || [], this.fieldMask = lt || [] } get path() { return this.settings.path } get sa() { return this.settings.sa } ia(s) { return new ah(Object.assign(Object.assign({}, this.settings), s), this.databaseId, this.It, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask) } ra(s) { var o; const c = (o = this.path) === null || o === void 0 ? void 0 : o.child(s), et = this.ia({ path: c, oa: !1 }); return et.ua(s), et } ca(s) { var o; const c = (o = this.path) === null || o === void 0 ? void 0 : o.child(s), et = this.ia({ path: c, oa: !1 }); return et.na(), et } aa(s) { return this.ia({ path: void 0, oa: !0 }) } ha(s) { return Sh(s, this.settings.methodName, this.settings.la || !1, this.path, this.settings.fa) } contains(s) { return this.fieldMask.find(o => s.isPrefixOf(o)) !== void 0 || this.fieldTransforms.find(o => s.isPrefixOf(o.field)) !== void 0 } na() { if (this.path) for (let s = 0; s < this.path.length; s++)this.ua(this.path.get(s)) } ua(s) { if (s.length === 0) throw this.ha("Document fields must not be empty"); if (ch(this.sa) && rh.test(s)) throw this.ha('Document fields cannot begin and end with "__"') } } class hh { constructor(s, o, c) { this.databaseId = s, this.ignoreUndefinedProperties = o, this.It = c || Zo(s) } da(s, o, c, et = !1) { return new ah({ sa: s, methodName: o, fa: c, path: ut.emptyPath(), oa: !1, la: et }, this.databaseId, this.It, this.ignoreUndefinedProperties) } } function lh(e) { const s = e._freezeSettings(), o = Zo(e._databaseId); return new hh(e._databaseId, !!s.ignoreUndefinedProperties, o) } function fh(e, s, o, c, et, at = {}) { const lt = e.da(at.merge || at.mergeFields ? 2 : 0, s, o, et); bh("Data must be an object, but it was:", lt, c); const ft = Ah(c, lt); let dt, ht; if (at.merge) dt = new Qt(lt.fieldMask), ht = lt.fieldTransforms; else if (at.mergeFields) { const vt = []; for (const wt of at.mergeFields) { const St = Ph(s, wt, o); if (!lt.contains(St)) throw new L(B.INVALID_ARGUMENT, `Field '${St}' is specified in your field mask but missing from your input data.`); Dh(vt, St) || vt.push(St) } dt = new Qt(vt), ht = lt.fieldTransforms.filter(wt => dt.covers(wt.field)) } else dt = null, ht = lt.fieldTransforms; return new oh(new ve(ft), dt, ht) } function Eh(e, s) { if (Rh(e = getModularInstance(e))) return bh("Unsupported field value:", s, e), Ah(e, s); if (e instanceof sh) return function (o, c) { if (!ch(c.sa)) throw c.ha(`${o._methodName}() can only be used with update() and set()`); if (!c.path) throw c.ha(`${o._methodName}() is not currently supported inside arrays`); const et = o._toFieldTransform(c); et && c.fieldTransforms.push(et) }(e, s), null; if (e === void 0 && s.ignoreUndefinedProperties) return null; if (s.path && s.fieldMask.push(s.path), e instanceof Array) { if (s.settings.oa && s.sa !== 4) throw s.ha("Nested arrays are not supported"); return function (o, c) { const et = []; let at = 0; for (const lt of o) { let ft = Eh(lt, c.aa(at)); ft == null && (ft = { nullValue: "NULL_VALUE" }), et.push(ft), at++ } return { arrayValue: { values: et } } }(e, s) } return function (o, c) { if ((o = getModularInstance(o)) === null) return { nullValue: "NULL_VALUE" }; if (typeof o == "number") return pn(c.It, o); if (typeof o == "boolean") return { booleanValue: o }; if (typeof o == "string") return { stringValue: o }; if (o instanceof Date) { const et = nt.fromDate(o); return { timestampValue: vs(c.It, et) } } if (o instanceof nt) { const et = new nt(o.seconds, 1e3 * Math.floor(o.nanoseconds / 1e3)); return { timestampValue: vs(c.It, et) } } if (o instanceof ih) return { geoPointValue: { latitude: o.latitude, longitude: o.longitude } }; if (o instanceof th) return { bytesValue: Vs(c.It, o._byteString) }; if (o instanceof Xc) { const et = c.databaseId, at = o.firestore._databaseId; if (!at.isEqual(et)) throw c.ha(`Document reference is for database ${at.projectId}/${at.database} but should be for database ${et.projectId}/${et.database}`); return { referenceValue: Cs(o.firestore._databaseId || c.databaseId, o._key.path) } } throw c.ha(`Unsupported field value: ${Qc(o)}`) }(e, s) } function Ah(e, s) { const o = {}; return $t(e) ? s.path && s.path.length > 0 && s.fieldMask.push(s.path) : Ft(e, (c, et) => { const at = Eh(et, s.ra(c)); at != null && (o[c] = at) }), { mapValue: { fields: o } } } function Rh(e) { return !(typeof e != "object" || e === null || e instanceof Array || e instanceof Date || e instanceof nt || e instanceof ih || e instanceof th || e instanceof Xc || e instanceof sh) } function bh(e, s, o) { if (!Rh(o) || !function (c) { return typeof c == "object" && c !== null && (Object.getPrototypeOf(c) === Object.prototype || Object.getPrototypeOf(c) === null) }(o)) { const c = Qc(o); throw c === "an object" ? s.ha(e + " a custom object") : s.ha(e + " " + c) } } function Ph(e, s, o) { if ((s = getModularInstance(s)) instanceof eh) return s._internalPath; if (typeof s == "string") return Vh(e, s); throw Sh("Field path arguments must be of type string or ", e, !1, void 0, o) } const vh = new RegExp("[~\\*/\\[\\]]"); function Vh(e, s, o) { if (s.search(vh) >= 0) throw Sh(`Invalid field path (${s}). Paths must not contain '~', '*', '/', '[', or ']'`, e, !1, void 0, o); try { return new eh(...s.split("."))._internalPath } catch { throw Sh(`Invalid field path (${s}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, e, !1, void 0, o) } } function Sh(e, s, o, c, et) { const at = c && !c.isEmpty(), lt = et !== void 0; let ft = `Function ${s}() called with invalid data`; o && (ft += " (via `toFirestore()`)"), ft += ". "; let dt = ""; return (at || lt) && (dt += " (found", at && (dt += ` in field ${c}`), lt && (dt += ` in document ${et}`), dt += ")"), new L(B.INVALID_ARGUMENT, ft + e + dt) } function Dh(e, s) { return e.some(o => o.isEqual(s)) }/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function el(e, s, o) { let c; return c = e ? o && (o.merge || o.mergeFields) ? e.toFirestore(s, o) : e.toFirestore(s) : s, c } function pl(e, s) { const o = jc(e.firestore, $a), c = sa(e), et = el(e.converter, s); return El(o, [fh(lh(e.firestore), "addDoc", c._key, et, e.converter !== null, {}).toMutation(c._key, On.exists(!1))]).then(() => c) } function El(e, s) { return function (o, c) { const et = new U; return o.asyncQueue.enqueueAndForget(async () => cc(await Ea(o), c, et)), et.promise }(Ua(e), s) } (function (e, s = !0) { (function (o) { v = o })(SDK_VERSION), _registerComponent(new Component("firestore", (o, { instanceIdentifier: c, options: et }) => { const at = o.getProvider("app").getImmediate(), lt = new $a(new Q(o.getProvider("auth-internal")), new H(o.getProvider("app-check-internal")), function (ft, dt) { if (!Object.prototype.hasOwnProperty.apply(ft.options, ["projectId"])) throw new L(B.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.'); return new ne(ft.options.projectId, dt) }(at, c), at); return et = Object.assign({ useFetchStreams: s }, et), lt._setSettings(et), lt }, "PUBLIC").setMultipleInstances(!0)), registerVersion(b, "3.7.2", e), registerVersion(b, "3.7.2", "esm2017") })(); const firebaseConfig = { apiKey: "AIzaSyA5MkVLmOLt2MA_Mfye9d1w_BV0QcyBiBw", authDomain: "biteezy-crypto-web.firebaseapp.com", projectId: "biteezy-crypto-web", storageBucket: "biteezy-crypto-web.appspot.com", messagingSenderId: "677266202061", appId: "1:677266202061:web:fb5ec1089010d338753884" }, app = initializeApp(firebaseConfig), db = La(app), ContactModal = ({ close: e }) => { const [s, o] = react.exports.useState({ name: "", email: "", subject: "", message: "" }), [c, et] = react.exports.useState(!1), at = ft => { const dt = ft.target.name, ht = ft.target.value; o({ ...s, [dt]: ht }) }, lt = ft => { ft.preventDefault(), et(!0), s.name && s.email && s.subject && s.message ? pl(ea(db, "queries"), s).then(() => { Q$2("Message Send Successfully"), o({ name: "", email: "", subject: "", message: "" }), et(!1) }).catch(dt => { Q$2(dt.message), o({ name: "", email: "", subject: "", message: "" }), et(!1) }) : (Q$2(" All Fields are required"), et(!1)) }; return jsxs(Fragment, { children: [jsx(k$2, { position: "top-right", autoClose: 5e3, hideProgressBar: !1, newestOnTop: !1, closeOnClick: !0, rtl: !1, pauseOnFocusLoss: !0, draggable: !0, pauseOnHover: !0, theme: "light" }), jsx(k$2, {}), jsx("div", { className: "justify-center items-center flex overflow-x-hidden overflow-y-auto fixed inset-0 z-50 outline-none focus:outline-none", children: jsx("div", { className: "relative w-auto my-6 mx-auto max-w-3xl", children: jsxs("div", { className: "border-0 rounded-lg shadow-lg relative flex flex-col bg-black-gradient-2  outline-none focus:outline-none w-[340px] xs:w-[500px] sm:w-[750px]", children: [jsxs("div", { className: "p-3 sm:p-10 flex justify-between border-b border-solid border-slate-50 pb-5", children: [jsxs("div", { children: [jsx("h2", { className: "text-2xl font-semibold my-2", children: " Have any Queries? " }), jsx("p", { className: `${styles$1.paragraph}`, children: " No worries, Send your queries to us. " })] }), jsx("div", { className: "p-3 sm:p-0 text-2xl sm:text-3xl font-extrabold cursor-pointer", onClick: e, children: jsx(AiOutlineClose, {}) })] }), jsx("div", { children: jsxs("form", { onSubmit: lt, className: "text-white flex flex-col", children: [jsxs("div", { className: "px-3 py-3 sm:px-10 sm:py-8 border-b border-solid border-slate-50", children: [jsx("div", { className: "my-5", children: jsx("input", { onChange: at, value: s.name, name: "name", type: "text", placeholder: "Your Name", className: "border border-solid border-Slate-50 outline-none px-5 py-3 rounded-2xl w-full bg-transparent" }) }), jsx("div", { className: "my-5", children: jsx("input", { onChange: at, value: s.email, name: "email", type: "email", placeholder: "Your Work Email", className: "border border-solid border-Slate-50 outline-none px-5 py-3 rounded-2xl w-full bg-transparent" }) }), jsx("div", { className: "my-5", children: jsx("input", { onChange: at, value: s.subject, name: "subject", type: "subject", placeholder: "Your Subject", className: "border border-solid border-Slate-50 outline-none px-5 py-3 rounded-2xl w-full bg-transparent" }) }), jsx("div", { className: "my-5", children: jsx("textarea", { onChange: at, value: s.message, name: "message", rows: "2", id: "", className: "border border-solid border-Slate-50 outline-none px-5 py-3 rounded-2xl w-full bg-transparent", placeholder: "Your Message" }) })] }), jsx("div", { className: "sm:px-10", children: jsxs("button", { disabled: c, type: "submit", className: `flex ${styles$1.flexCenter} py-4 px-8 my-3 sm:my-8 font-poppins font-medium text-[16px] text-primary primary_gradient rounded-full outline-none ${c && "opacity-50"}`, children: ["Send Message ", jsxs("span", { className: "ml-3", children: [" ", jsx(AiOutlineSend, {}), " "] })] }) })] }) })] }) }) }), jsx("div", { className: "opacity-50 fixed inset-0 z-40 bg-black" })] }) }, Footer = () => { const e = new Date().getFullYear(); return jsxs("section", { className: `${styles$1.flexCenter} ${styles$1.paddingY} flex-col`, children: [jsxs("div", { className: `${styles$1.flexStart} md:flex-row flex-col mb-8 w-full`, children: [jsxs("div", { className: "flex-[1] flex flex-col justify-start", children: [jsx("img", { src: logo, alt: "biteezy", className: "w-[150px] h-[72.14px] object-contain ml-[-12px]" }), jsx("p", { className: `${styles$1.paragraph} mt-4 max-w-[312px]`, children: "Best Crypto App to Buy and sell crypto assets in present world." })] }), jsx("div", { className: "flex-[1.5] w-full flex flex-row justify-between flex-wrap md:mt-0 mt-10", children: footer_menu.map(s => jsxs("div", { className: "flex flex-col ss:my-0 my-4 min-w-[150px]", children: [jsx("h4", { className: "font-poppins font-medium text-[18px] leading-[27px] text-white", children: s.title }), jsx("ul", { className: "list-none mt-4", children: s.links.map((o, c) => o.isImg ? jsxs("li", { className: `font-poppins font-normal text-[16px] leading-[24px] flex items-center text-dimWhite hover:text-secondary cursor-pointer ${c !== s.links.length - 1 ? "mb-4" : "mb-0"}`, children: [jsx(o.name, { className: "text-4xl mr-2" }), " ", o.title] }, o.name) : jsx("li", { className: `font-poppins font-normal text-[16px] leading-[24px] text-dimWhite hover:text-secondary cursor-pointer ${c !== s.links.length - 1 ? "mb-4" : "mb-0"}`, children: o.name }, o.name)) })] }, s.title)) })] }), jsxs("div", { className: "w-full text-center flex justify-between items-center md:flex-row flex-col pt-6 border-t-[1px] border-t-[#3F3E45]", children: [jsxs("p", { className: `${styles$1.paragraph}`, children: ["Copyright \u24B8 ", e, " Biteezy. All Rights Reserved."] }), jsx("div", { className: "flex flex-row md:mt-0 mt-6", children: socail_media_icons.map((s, o) => jsx("div", { onClick: () => window.open(s.link), className: `cursor-pointer ${o !== socail_media_icons.length - 1 ? "mr-6" : "mr-0"}`, children: jsx(s.icon, { className: "text-2xl" }) }, s.id)) })] })] }) }, Counter = () => { const [e, s] = react.exports.useState(20), [o, c] = react.exports.useState(10), [et, at] = react.exports.useState(10), [lt, ft] = react.exports.useState(10); let dt; const ht = () => { let vt = new Date("April 6,2023").getTime(); dt = setInterval(() => { const wt = new Date().getTime(), St = vt - wt, _t = Math.floor(St / (24 * 60 * 60 * 1e3)), Nt = Math.floor(St % (24 * 60 * 60 * 1e3) / (1e3 * 60 * 60)), kt = Math.floor(St % (60 * 60 * 1e3) / (1e3 * 60)), Dt = Math.floor(St % (60 * 1e3) / 1e3); St < 0 ? clearInterval(dt.current) : (s(_t), c(Nt), at(kt), ft(Dt)) }, 1e3) }; return react.exports.useEffect(() => { ht() }), jsxs("div", { className: "flex text-center items-center justify-center flex-wrap", children: [jsxs("div", { className: "mx-1 sm:mx-3", children: [jsx("div", { className: "flex items-center justify-between", children: jsxs("h1", { className: "flex-1 font-poppins font-semibold  ss:text-[52px] sm:text-[72px] text-[35px] text-white ss:leading-[100.8px] leading-[75px]", children: [" ", e, " ", jsx("span", { className: "primary_text_shade", children: ": " }), "   "] }) }), jsx("p", { className: "sm:mr-10", children: " Days" })] }), jsxs("div", { className: "mx-1 sm:mx-3", children: [jsx("div", { className: "flex items-center justify-between", children: jsxs("h1", { className: "flex-1 font-poppins font-semibold ss:text-[52px] sm:text-[72px] text-[35px] text-white ss:leading-[100.8px] leading-[75px]", children: [" ", o, " ", jsx("span", { className: "primary_text_shade", children: ": " }), "   "] }) }), jsx("p", { className: "mx-1 sm:mr-12", children: " Hours" })] }), jsxs("div", { className: "sm:mx-3", children: [jsx("div", { className: "flex items-center justify-between", children: jsxs("h1", { className: "flex-1 font-poppins font-semibold  ss:text-[52px] sm:text-[72px] text-[35px] text-white ss:leading-[100.8px] leading-[75px]", children: [" ", et, " ", jsx("span", { className: "primary_text_shade", children: ": " }), "   "] }) }), jsx("p", { className: "mx-1 sm:mr-12", children: " Minutes" })] }), jsxs("div", { className: "sm:mx-3", children: [jsx("div", { className: "flex items-center justify-between", children: jsxs("h1", { className: "flex-1 font-poppins font-semibold  ss:text-[52px] sm:text-[72px] text-[35px] text-white ss:leading-[100.8px] leading-[75px]", children: [" ", lt, " ", jsx("span", { className: "primary_text_shade", children: " " }), "   "] }) }), jsx("p", { children: " Seconds" })] })] }) }, PopUp = ({ close: e }) => jsxs(Fragment, { children: [jsx("div", { className: "justify-center items-center flex overflow-x-hidden overflow-y-auto fixed inset-0 z-50 outline-none focus:outline-none", children: jsx("div", { className: "relative w-[300px] ss:w-[550px] sm:w-[700px] md:w-[1000px] my-6 mx-auto", children: jsxs("div", { className: "border-0 rounded-lg shadow-lg relative flex flex-col bg-black-gradient-2  outline-none focus:outline-none", children: [jsx("div", { className: "text-center pb-5 pt-10 ", children: jsxs("h1", { className: "flex-1 font-poppins font-semibold ss:text-[55px] sm:text-[65px] text-[30px] text-white ss:leading-[100.8px] leading-[75px]", children: [" Best ", jsx("span", { className: "primary_text_shade", children: "Deals " }), " Ends In  "] }) }), jsx("div", { className: "sm:p-5 p-1", children: jsx(Counter, {}) }), jsx("div", { className: "pb-5 text-center", onClick: e, children: jsx("button", { className: "py-4 px-8 my-8 font-poppins font-medium text-[16px] text-primary primary_gradient rounded-lg outline-none", children: " OK, Got it " }) })] }) }) }), jsx("div", { className: "opacity-50 fixed inset-0 z-40 bg-black" })] }), useScrollPosition = () => { const [e, s] = react.exports.useState(0); return react.exports.useEffect(() => { const o = () => { s(window.pageYOffset) }; return window.addEventListener("scroll", o), o(), () => window.removeEventListener("scroll", o) }, []), e }, App = () => { const [e, s] = react.exports.useState(!1), o = useScrollPosition(); react.exports.useEffect(() => { s(!0) }, []); const c = () => { s(!1) }; return jsxs("div", { className: "bg-primary text-white w-full overflow-hidden", children: [jsx("div", { className: `${o > 300 && "fixed z-50 top-0 w-full drop-shadow-2xl transparent_box_shadow bg-primary"} ${styles$1.paddingX} ${styles$1.flexCenter}`, children: jsx("div", { className: `${styles$1.boxWidth}`, children: jsx(Navbar, {}) }) }), jsx("div", { className: `${styles$1.paddingX} ${styles$1.flexCenter}`, children: jsx("div", { className: `${styles$1.boxWidth}`, children: jsx(Hero, {}) }) }), jsx("div", { className: `${styles$1.paddingX} ${styles$1.flexCenter}`, children: jsxs("div", { className: `${styles$1.boxWidth}`, children: [jsx(Community, {}), jsx(Converter, {}), jsx(Features, {}), jsx(Market, {}), jsx(Testimonials, {}), jsx(Explore, {}), jsx(Connect, {}), jsx(Footer, {}), e && jsx(PopUp, { close: c })] }) })] }) }, index = ""; client.createRoot(document.getElementById("root")).render(jsx(React.StrictMode, { children: jsx(App, {}) }));
